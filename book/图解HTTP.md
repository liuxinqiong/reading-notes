图解HTTP

读《HTTP图解》笔记。

# Web及网络基础
Web使用HTTP(HyperText Transfer Protocol，超文本传输协议)协议作为规范，Web是建立在HTTP协议上通信的。

## HTTP诞生
* 为知识共享而规划Web，借助多文档之间相互关联形成的超文本，连成可相互参阅的WWW(World Wide Web万维网)
  + 页面文本标记语言HTML
  + 文档传递协议HTTP
  * 指定文档所在地址的URL
* Web成长时代
  + Web服务器：CGI、Apache
  + HTML：in-line
  + 浏览器：Netscape、IE、Firefox、Chrome、Opera、Safari
  + 浏览器竞争，不遵循Web标准化导致棘手的兼容性
* 驻足不前的HTTP
  + 1990：HTTP/0.9
  + 1996：HTTP/1.0 正式版
  + 1997：HTTP/1.1 目前主流的HTTP协议版本

## 网络基础TCP/IP
通常使用的网络是在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集。

### TCP/IP协议族
计算机和网络设备要相互通信，双方就必须基于相同的方案，不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则，我们把这种规则称为协议。

### TCP/IP分层管理
层次化之后，设计变得相对简单了，协议族按层次分别为
* 应用层
  + 决定了向用户提供应用服务时通信的活动
  + FTP、DNS、HTTP
* 传输层
  + 对上层应用层，提供处于网络连接中的两台计算机之间的数据传输
  + TCP、UDP
* 网络层
  + 处理在网络上流动的数据包，数据包是网络传输的最小数据单元，规定了通过怎样的路径到达对方计算机，并把数据包传送给对方
  + 与对方计算机之间通过多台计算机或网络设备进行传输是，网络层所起的作用就是在众多的选项内选择一条传输路线
  + IP
* 数据链路层
  + 处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、网络适配器、光纤等物理可见部分

### TCP/IP通信传输流
利用TCP/IP协议族进行网络通信时，会通过分成顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。
1. 应用层发送HTTP请求
2. 传输层TCP把应用层接收到的数据进行分割，并在各个报文上打上标记序号及端口号后发给网络层
3. 网络层增加作为通信目的地的MAC地址后转发给链路层
4. 接受端在链路层收到数据，按序往上层发送，一直到应用层，当传输到应用层，才能算真正接受到客户端发送过来的HTTP请求

> 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息，接收端在层与层传输数据时，每经过一层时会把对应的首部消去，这种把数据信息包装起来的做法称为封装。

## IP、TCP、DNS
这三个协议是与HTTP密不可分的。

### 负责传输的IP协议
作用把各种数据包传送给对方，而要保证确实传送到对方地址，则需要满足各类条件，其中两个最重要的条件是IP地址和MAC地址。

IP地址指名了节点分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。

在网络上，通信的双方在同一局域网内的情况是很少见的，通常需要经过多台计算机和网络设备中转才能连接到对方，而在中转时，会利用下一站设备的MAC地址来搜索下一个中转目标，这时就需要ARP协议了，ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。

### 确保可靠的TCP协议
可供可靠的字节流服务。所谓的字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。

为了准确无误的把数据送达目标处，TCP协议采用了三次握手策略。TCP不会对传送后的情况置之不理，他一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和ACK。

大致过程：发送端先发送带有SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后发送端再回传一个带ACK标志的数据包，表示握手结束。

### 负责域名解析的DNS服务
DNS服务是和HTTP协议一样位于应用层的协议，提供域名到IP地址的解析服务。

DNS提供域名查找IP地址，或逆向IP地址反查域名的服务。

## URL和URL
与URL（统一资源标识符）相比，我们更熟悉URL（统一资源定位符）。

URI全称Uniform Resource Identifier。
* Uniform：规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式
* Resource：可标识的任何东西
* Identifier：表示可标识的对象

> URL就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型的名称。

URI是用字符串标识某一互联网资源，而URL表示资源的地点。URL是URI的子集。

URI格式
* 登录信息（可选）
* 服务器地址
* 端口号
* 带层次的文件路径
* 查询字符串
* 片段标识符

# HTTP协议
请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。

响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

HTTP是一种不保存状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。设计成这样是为了更快的处理大量事务，确保协议的可伸缩性，而特意把协议设计的如此简单。

Cookie状态管理：保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入Cookie技术。
* 服务端发送响应报文内Set-Cookie的首部字段信息，通知客户端保存Cookie
* 下次往服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去
* 服务器发送客户端发送过来的Cookie后，会检查究竟是哪一个客户端发来的连接请求，然后对比服务器记录，最后得到之前的状态信息

## HTTP方法
* GET：获取资源
  + 请求资源是文本，则保持原样返回
  + 如果是像CGI(通用网关接口)那样的程序，则返回经过执行后的输出结果
* POST：传输实体主体
  + 虽然GET也可以传输实体的主体，但是一般不用GET
  + POST的功能和GET类似，但主要目的不是获取响应的主体内容
* PUT：传输文件
  + 要求在请求报文主体中包含文件内容，然后保存到URI指定的位置
  + 自身不带验证机制，任何人都可以上传文件，存在安全性问题
* HEAD：获得报文首部
  + 不返回主体部分
  + 用于确定URI的有效性及资源更新的日期时间等
* DELETE：删除文件
  + 与PUT相反，按请求URI删除指定的资源
  + 自身同样不带验证机制
* OPTIONS：询问支持的方法
  + 查询针对请求URI指定的资源支持的方法
* TRACE：追踪路径
  + 让Web服务器将之前的请求通信环回给客户端的方法
  + 发送请求时在Max-Forwards首部字段中填入数值，每经过一个服务端就将该数字减1，当数值刚好减到0时，停止继续传输，最后接受到请求的服务端则返回状态码200 OK的响应
  + 用来查询发出去的请求是怎样被加工修改/篡改的
  + 易引发XST(Cross-Site Tracing，跨站追踪)攻击，通常不会用到
* CONNECT：要求用隧道协议连接代理
  + 要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL(Secure Sockets Layer安全套接层)和TLS(Transport Layer Security传输层安全)协议把通信内容加密后经网络隧道传输

### 持久连接
在HTTP初始版本中，没进行一次HTTP通信就要断开一次连接。

随着HTTP的普及，文档中包含大量图片的情况就多了起来，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源。因此每次的请求都会造成TCP连接的建立和断开，增加通信量的开销。

为了解决上述问题，HTTP1.1和部分HTTP1.0想出了持久连接的方法，也称为HTTP keep-alive或HTTP connection reuse。持久连接的特点就是：只要任意一端没有明确提出断开连接，则保持TCP连接状态。

在HTTP1.1中，所有连接默认都是持久连接，但在HTTP1.0内并未标准化。

### 管道化
持久连接使得多数请求以管道化方式发送成为可能。以前发送请求后需等待并收到响应，才能发送下一个请求。管道化技术出现后，不用等待响应就可以直接发送下一个请求。

## Cookie状态管理
由于HTTP协议是无状态协议，无法根据之前的状态进行本次的请求处理。保留无状态这个特性同时又要解决类似的矛盾问题，于是引入的Cookie技术，Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态。

Cookie会根据服务端发送的响应报文中Set-Cookie的首部字段信息通知客户端写Cookie，当下次客户端再往服务端发请求时，客户端会自动在请求报文中加入Cookie值后发送出去。

# HTTP信息
HTTP报文本身是由多行（CR+CF作换行符）数据构成的字符串文本。

HTTP报文大致可以分为报文首部和报文主体两块，两者由最初出现的空行（CR+CF）来划分，通常并不一定要有报文主体。

其中头部信息可以进一步细分
* 请求行（状态行）
  * 请求行：请求的方法，URL和HTTP版本
  * 状态行：状态码，原因短语和HTTP版本
* 请求（响应）首部字段
* 通用首部字段
* 实体首部字段
* 其他

## 编码
HTTP在传输时可以按照数据原样直接传输，但也可以在传输中通过编码提升效率。

报文主体和实体主体差异
* 报文：HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输
* 实体：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成

HTTP报文主体用于传输请求或响应的实体主体

> 通常，报文主体等于实体主体，只有当传输中进行编码时，实体主体的内容发生变化时，才导致它和报文主体产生差异。

常见的内容编码
* gzip（GUN ZIP）
* compress（UNIX 标准压缩）
* deflate（zlib）
* identity（不进行编码）

分块传输：在HTTP通信中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面，在传输大容量数据时，通过把数据分隔成多块，能够让浏览器逐步显示页面。这种把主体分块的功能称为分块传输编码。

分块传输编码将实体主体分成多个部分，每块都会用16进制来表示标记块的大小，实体主体最后一块用"0(CR+CF)"来标记。

### 多部分对象集合
HTTP协议采用了多部分对象集合，发送一份报文主体内可含有多类型实体。通常在图片或文本上传时使用。

多部分对象集合包含的对象如下：
* multipart/form-data：在web表单文件上传时使用
* multipart/byteranges：状态码206响应报文包含了多个范围的内容时使用

在HTTP报文中使用多部分对象集合时，需要在首部字段加上`content-type`。使用boundary字符串来划分多部分对象集合指明的各类实体。

### 获取部分内容
背景：如果下载过程中遇到网络中断的情况，就必须重头开始，为了解决这个问题，需要一种可恢复的机制，所谓恢复是指能从之前中断下载处恢复下载。

要实现该功能，需要知道下载的实体范围，指定范围发送的请求就叫做范围请求。

执行范围请求，会用到首部字段range来指定资源的byte范围
```shell
# 5000·10000字节
range: bytes = 5001-10000
# 5001字节之后全部的
range: bytes = 5001-
# 从一开始到3000，和5000到7000的多重范围
range: bytes = -3000,5000-7000
```

针对范围请求，响应会返回状态码为206 Partial Content的响应报文，宁外对于多重范围的范围请求，响应会在首部字段`content-type`标明为multipart/byteranges后返回响应报文。如果服务端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。

### 内容协商
当浏览器默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英文版和中文版的Web页面，这样的机制称为内容协商。

内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的依据。

包含在请求报文中的某些首部信息就是判断的依据
* accept
* accept-charset
* accept-encoding
* accept-language
* content-language

内容协商技术有一下三种类型
* 服务端驱动协商
* 客户端驱动协商
* 透明协商

# HTTP状态码
响应的状态码可描述请求的处理结果，数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。
* 1XX Informational（信息性状态码） 接收的请求正在处理
* 2XX Success（成功状态码） 请求正常处理完毕
* 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求
* 4XX Client Error（客户端错误状态码） 服务器无法处理请求
* 5XX Server Error（服务器错误状态码） 服务器处理请求出错

只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。

我们就介绍一下这些具有代表性的 14 个状态码。
* 2XX 成功：表明请求被正常处理了
  * 200 OK
  * 204 No Content：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分
  * 206 Partial Content：表示客户端进行了范围请求
* 3XX 重定向：表明浏览器需要执行某些特殊的处理以正确处理请求。
  * 301 Moved Permanently：永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。
  * 302 Found：临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。
  * 303 See Other：表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别
  * 304 Not Modified：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。
  * 307 Temporary Redirect：临时重定向。该状态码与 302 Found 有着相同的含义。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。
* 4XX 客户端错误：表明客户端是发生错误的原因所在。
  * 400 Bad Request：该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。
  * 401 Unauthorized：表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。
  * 403 Forbidden：表明对请求资源的访问被服务器拒绝了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。
  * 404 Not Found：该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。
* 5XX 服务器错误：表明服务器本身发生错误
  * 500 Internal Server Error：在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。
  * 503 Service Unavailable：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。

> 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。

> 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。

> 附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。

# Web服务器

## 多个域名
HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。

在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。

## 代理、网关、隧道
HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序
* 代理是一种有转发功能的应用程序，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。
* 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。
* 隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

### 代理
代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。

> 每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息

在 HTTP 通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加 Via 首部字段以标记出经过的主机信息。

使用代理服务器的理由有
* 利用缓存技术减少网络带宽的流量
* 组织内部针对特定网站的访问控制
* 获取访问日志为主要目的
* ……等等。

代理有多种使用方法，按两种基准分类。
* 一种是是否使用缓存
* 另一种是是否会修改报文。

### 网关
网关与代理的区别就是，客户端通过HTTP协议与网关进行通信，但网关通过非HTTP通信协议与非HTTP服务器进行通信。

> 利用网关可以由 HTTP 请求转化为其他协议通信

网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。

利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。

### 隧道
隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

### 缓存
缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。

缓存的有效期限：即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。

客户端的缓存：缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。

# HTTP首部
使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。

HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔。另外，字段值对应单个 HTTP 首部字段可以有多个值，中间使用“,”进行分割。

> 若 HTTP 首部字段重复了会如何
> 当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段而有些则会优先处理最后出现的首部字段。

4 种 HTTP 首部字段类型
* 通用首部字段（General Header Fields）：请求报文和响应报文两方都会使用的首部。
* 请求首部字段（Request Header Fields）：从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。
* 响应首部字段（Response Header Fields）：从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。
* 实体首部字段（Entity Header Fields）：针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

首部字段一览

HTTP/1.1 规范定义了如下 47 种首部字段。

通用首部字段

![1.png](./img/1.png)

请求首部字段

![2.png](./img/2.png)

响应首部字段

![3.png](./img/3.png)

实体首部字段

![4.png](./img/4.png)

> 在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition等在其他 RFC 中定义的首部字段，它们的使用频率也很高。这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。

HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。
* 端到端首部（End-to-end Header）：分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。
* 逐跳首部（Hop-by-hop Header）：分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。

下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外，其他所有字段都属于端到端首部。
* Connection
* Keep-Alive
* Proxy-Authenticate
* Proxy-Authorization
* Trailer
* TE
* Transfer-Encoding
* Upgrade

## 通用首部字段
请求报文和响应报文双方都会使用的首部。

### Cache-Control
用来操作缓存的工作机制。可用于请求及响应，下面是对应指令一览

缓存请求指令
![5.png](./img/5.png)

缓存响应指令
![6.png](./img/6.png)

详解
* public 指令：当指定使用 public 指令时，则明确表明其他用户也可利用缓存
* private 指令：缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。
* no-cache 指令
  * 使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源
  * 请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。
  * 响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。
  * Cache-Control: no-cache=Location，响应专有，客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。
* no-store
  * 暗示请求（和对应的响应）或响应中包含机密信息。
  * no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，no-store 才是真正地不进行缓存
  * 规定缓存不能在本地存储请求或响应的任一部分。
* s-maxage
  * s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器
  * 对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。
  * 当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。
* max-age
  * 当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。
  * 当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。
  * 当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。
* min-fresh
  * 要求缓存服务器返回至少还未过指定时间的缓存资源。
  * 比如当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响应返回了。
* max-stale
  * 如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；
  * 如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收。
* only-if-cached
  * 表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。
  * 该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。
* must-revalidate
  * 代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。
  * 若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条 504（Gateway Timeout）状态码
  * 使用 must-revalidate 指令会忽略请求的 max-stale 指令
* proxy-revalidate：要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。
* no-transform：规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。可防止缓存或代理压缩图片等类似操作。

> 应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略

### Connection
两个作用
* 控制不再转发给代理的首部字段
* 管理持久连接

> HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。 

> HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。

### Pragma
Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。

规范定义的形式唯一：Pragma: no-cache，属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。

### Trailer
事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。

### Transfer-Encoding
规定了传输报文主体时采用的编码方式。HTTP/1.1 的传输编码方式仅对分块传输编码有效。

### Upgrade
用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。

### Via
为了追踪客户端与服务器之间的请求和响应报文的传输路径。

报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。

首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。

### Warning
HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。

Warning 首部的格式如下。最后的日期时间部分可省略。
```
Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])
```

## 请求首部字段
请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。

### Accept
Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。

常见媒体类型例子
* 文本文件
  * text/html, text/plain, text/css ...
  * application/xhtml+xml, application/xml ...
* 图片文件：image/jpeg, image/gif, image/png ...
* 视频文件：video/mpeg, video/quicktime ...
* 应用程序使用二进制文件：application/octet-stream, application/zip ...

若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值1 ，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。

### Accept-Charset
Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。

### Accept-Encoding
Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。

常见内容编码
* gzip
* compress
* deflate
* identify：不执行压缩或不会变化的默认编码格式

采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。

### Accept-Language
首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。

和 Accept 首部字段一样，按权重值 q 来表示相对优先级。

### Authorization
首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。

### From
首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。

### Host
虚拟主机运行在同一个 IP 上，因此使用首部字段 Host 加以区分。

首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。

首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。

请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段Host 来明确指出请求的主机名。若服务器未设定主机名，那直接发送一个空值即可。

### If-Match
形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。

服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。

还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。

### If-None-Match
只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反

### If-Modified-Since
首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。

### If-Unmodified-Since
首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。

### If-Range
首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。

如果不使用首部字段If-Range进行范围请求，则需要进行两次处理。为啥呢？

思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。

### Max-Forwards
通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。

使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。

可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。

### Proxy-Authorization
接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。

客户端与服务器之间的认证，使用首部字段 Authorization 可起到相同作用。

### Range
对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。

接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源

### Referer
首部字段 Referer 会告知服务器请求的原始资源的 URI。

客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。

### TE
首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding （内容编码）的功能很相像，但是用于传输编码。

首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。

### User-Agent
首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。

由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。

## 响应首部字段
响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。

### Accept-Ranges
当不能处理范围请求时，Accept-Ranges: none

可以处理范围请求时，Accept-Ranges: bytes

### Age
首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。

### ETag
首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。

ETag 中有强 ETag 值和弱 ETag 值之分。
* 强 ETag 值，不论实体发生多么细微的变化都会改变其值。
* 弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。

### Location
使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。

基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。

几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。

### Proxy-Authenticate
首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。

它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段 WWW-Authorization 有着相同的作用。

### Retry-After
首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。

字段值可以指定为具体的日期时间，也可以是创建响应后的秒数。

### Server
首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。

### Vary
当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回。

首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。

### WWW-Authenticate
首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。

## 实体首部字段

# HTTPS

# 身份认证

# 功能追加协议

# 构建Web内容的技术

# 攻击技术