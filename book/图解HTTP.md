图解HTTP

读《HTTP图解》笔记。

# Web及网络基础
Web使用HTTP(HyperText Transfer Protocol，超文本传输协议)协议作为规范，Web是建立在HTTP协议上通信的。

## HTTP诞生
* 为知识共享而规划Web，借助多文档之间相互关联形成的超文本，连成可相互参阅的WWW(World Wide Web万维网)
  + 页面文本标记语言HTML
  + 文档传递协议HTTP
  * 指定文档所在地址的URL
* Web成长时代
  + Web服务器：CGI、Apache
  + HTML：in-line
  + 浏览器：Netscape、IE、Firefox、Chrome、Opera、Safari
  + 浏览器竞争，不遵循Web标准化导致棘手的兼容性
* 驻足不前的HTTP
  + 1990：HTTP/0.9
  + 1996：HTTP/1.0 正式版
  + 1997：HTTP/1.1 目前主流的HTTP协议版本

## 网络基础TCP/IP
通常使用的网络是在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集。

### TCP/IP协议族
计算机和网络设备要相互通信，双方就必须基于相同的方案，不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则，我们把这种规则称为协议。

### TCP/IP分层管理
层次化之后，设计变得相对简单了，协议族按层次分别为
* 应用层
  + 决定了向用户提供应用服务时通信的活动
  + FTP、DNS、HTTP
* 传输层
  + 对上层应用层，提供处于网络连接中的两台计算机之间的数据传输
  + TCP、UDP
* 网络层
  + 处理在网络上流动的数据包，数据包是网络传输的最小数据单元，规定了通过怎样的路径到达对方计算机，并把数据包传送给对方
  + 与对方计算机之间通过多台计算机或网络设备进行传输是，网络层所起的作用就是在众多的选项内选择一条传输路线
  + IP
* 数据链路层
  + 处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、网络适配器、光纤等物理可见部分

### TCP/IP通信传输流
利用TCP/IP协议族进行网络通信时，会通过分成顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。
1. 应用层发送HTTP请求
2. 传输层TCP把应用层接收到的数据进行分割，并在各个报文上打上标记序号及端口号后发给网络层
3. 网络层增加作为通信目的地的MAC地址后转发给链路层
4. 接受端在链路层收到数据，按序往上层发送，一直到应用层，当传输到应用层，才能算真正接受到客户端发送过来的HTTP请求

> 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息，接收端在层与层传输数据时，每经过一层时会把对应的首部消去，这种把数据信息包装起来的做法称为封装。

## IP、TCP、DNS
这三个协议是与HTTP密不可分的。

### 负责传输的IP协议
作用把各种数据包传送给对方，而要保证确实传送到对方地址，则需要满足各类条件，其中两个最重要的条件是IP地址和MAC地址。

IP地址指名了节点分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。

在网络上，通信的双方在同一局域网内的情况是很少见的，通常需要经过多台计算机和网络设备中转才能连接到对方，而在中转时，会利用下一站设备的MAC地址来搜索下一个中转目标，这时就需要ARP协议了，ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。

### 确保可靠的TCP协议
可供可靠的字节流服务。所谓的字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。

为了准确无误的把数据送达目标处，TCP协议采用了三次握手策略。TCP不会对传送后的情况置之不理，他一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和ACK。

大致过程：发送端先发送带有SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后发送端再回传一个带ACK标志的数据包，表示握手结束。

### 负责域名解析的DNS服务
DNS服务是和HTTP协议一样位于应用层的协议，提供域名到IP地址的解析服务。

DNS提供域名查找IP地址，或逆向IP地址反查域名的服务。

## URL和URL
与URL（统一资源标识符）相比，我们更熟悉URL（统一资源定位符）。

URI全称Uniform Resource Identifier。
* Uniform：规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式
* Resource：可标识的任何东西
* Identifier：表示可标识的对象

> URL就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型的名称。

URI是用字符串标识某一互联网资源，而URL表示资源的地点。URL是URI的子集。

URI格式
* 登录信息（可选）
* 服务器地址
* 端口号
* 带层次的文件路径
* 查询字符串
* 片段标识符

# HTTP协议
请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。

响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

HTTP是一种不保存状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。设计成这样是为了更快的处理大量事务，确保协议的可伸缩性，而特意把协议设计的如此简单。

Cookie状态管理：保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入Cookie技术。
* 服务端发送响应报文内Set-Cookie的首部字段信息，通知客户端保存Cookie
* 下次往服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去
* 服务器发送客户端发送过来的Cookie后，会检查究竟是哪一个客户端发来的连接请求，然后对比服务器记录，最后得到之前的状态信息

## HTTP方法
* GET：获取资源
  + 请求资源是文本，则保持原样返回
  + 如果是像CGI(通用网关接口)那样的程序，则返回经过执行后的输出结果
* POST：传输实体主体
  + 虽然GET也可以传输实体的主体，但是一般不用GET
  + POST的功能和GET类似，但主要目的不是获取响应的主体内容
* PUT：传输文件
  + 要求在请求报文主体中包含文件内容，然后保存到URI指定的位置
  + 自身不带验证机制，任何人都可以上传文件，存在安全性问题
* HEAD：获得报文首部
  + 不返回主体部分
  + 用于确定URI的有效性及资源更新的日期时间等
* DELETE：删除文件
  + 与PUT相反，按请求URI删除指定的资源
  + 自身同样不带验证机制
* OPTIONS：询问支持的方法
  + 查询针对请求URI指定的资源支持的方法
* TRACE：追踪路径
  + 让Web服务器将之前的请求通信环回给客户端的方法
  + 发送请求时在Max-Forwards首部字段中填入数值，每经过一个服务端就将该数字减1，当数值刚好减到0时，停止继续传输，最后接受到请求的服务端则返回状态码200 OK的响应
  + 用来查询发出去的请求是怎样被加工修改/篡改的
  + 易引发XST(Cross-Site Tracing，跨站追踪)攻击，通常不会用到
* CONNECT：要求用隧道协议连接代理
  + 要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL(Secure Sockets Layer安全套接层)和TLS(Transport Layer Security传输层安全)协议把通信内容加密后经网络隧道传输

### 持久连接
在HTTP初始版本中，没进行一次HTTP通信就要断开一次连接。

随着HTTP的普及，文档中包含大量图片的情况就多了起来，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源。因此每次的请求都会造成TCP连接的建立和断开，增加通信量的开销。

为了解决上述问题，HTTP1.1和部分HTTP1.0想出了持久连接的方法，也称为HTTP keep-alive或HTTP connection reuse。持久连接的特点就是：只要任意一端没有明确提出断开连接，则保持TCP连接状态。

在HTTP1.1中，所有连接默认都是持久连接，但在HTTP1.0内并未标准化。

### 管道化
持久连接使得多数请求以管道化方式发送成为可能。以前发送请求后需等待并收到响应，才能发送下一个请求。管道化技术出现后，不用等待响应就可以直接发送下一个请求。

## Cookie状态管理
由于HTTP协议是无状态协议，无法根据之前的状态进行本次的请求处理。保留无状态这个特性同时又要解决类似的矛盾问题，于是引入的Cookie技术，Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态。

Cookie会根据服务端发送的响应报文中Set-Cookie的首部字段信息通知客户端写Cookie，当下次客户端再往服务端发请求时，客户端会自动在请求报文中加入Cookie值后发送出去。

# HTTP信息
HTTP报文本身是由多行（CR+CF作换行符）数据构成的字符串文本。

HTTP报文大致可以分为报文首部和报文主体两块，两者由最初出现的空行（CR+CF）来划分，通常并不一定要有报文主体。

其中头部信息可以进一步细分
* 请求行（状态行）
  * 请求行：请求的方法，URL和HTTP版本
  * 状态行：状态码，原因短语和HTTP版本
* 请求（响应）首部字段
* 通用首部字段
* 实体首部字段
* 其他

## 编码
HTTP在传输时可以按照数据原样直接传输，但也可以在传输中通过编码提升效率。

报文主体和实体主体差异
* 报文：HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输
* 实体：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成

HTTP报文主体用于传输请求或响应的实体主体

> 通常，报文主体等于实体主体，只有当传输中进行编码时，实体主体的内容发生变化时，才导致它和报文主体产生差异。

常见的内容编码
* gzip（GUN ZIP）
* compress（UNIX 标准压缩）
* deflate（zlib）
* identity（不进行编码）

分块传输：在HTTP通信中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面，在传输大容量数据时，通过把数据分隔成多块，能够让浏览器逐步显示页面。这种把主体分块的功能称为分块传输编码。

分块传输编码将实体主体分成多个部分，每块都会用16进制来表示标记块的大小，实体主体最后一块用"0(CR+CF)"来标记。

### 多部分对象集合
HTTP协议采用了多部分对象集合，发送一份报文主体内可含有多类型实体。通常在图片或文本上传时使用。

多部分对象集合包含的对象如下：
* multipart/form-data：在web表单文件上传时使用
* multipart/byteranges：状态码206响应报文包含了多个范围的内容时使用

在HTTP报文中使用多部分对象集合时，需要在首部字段加上`content-type`。使用boundary字符串来划分多部分对象集合指明的各类实体。

### 获取部分内容
背景：如果下载过程中遇到网络中断的情况，就必须重头开始，为了解决这个问题，需要一种可恢复的机制，所谓恢复是指能从之前中断下载处恢复下载。

要实现该功能，需要知道下载的实体范围，指定范围发送的请求就叫做范围请求。

执行范围请求，会用到首部字段range来指定资源的byte范围
```shell
# 5000·10000字节
range: bytes = 5001-10000
# 5001字节之后全部的
range: bytes = 5001-
# 从一开始到3000，和5000到7000的多重范围
range: bytes = -3000,5000-7000
```

针对范围请求，响应会返回状态码为206 Partial Content的响应报文，宁外对于多重范围的范围请求，响应会在首部字段`content-type`标明为multipart/byteranges后返回响应报文。如果服务端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。

### 内容协商
当浏览器默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英文版和中文版的Web页面，这样的机制称为内容协商。

内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的依据。

包含在请求报文中的某些首部信息就是判断的依据
* accept
* accept-charset
* accept-encoding
* accept-language
* content-language

内容协商技术有一下三种类型
* 服务端驱动协商
* 客户端驱动协商
* 透明协商

# HTTP状态码

# Web服务器

# HTTP首部

# HTTPS

# 身份认证

# 功能追加协议

# 构建Web内容的技术

# 攻击技术