图解HTTP

读《HTTP图解》笔记。

# Web及网络基础
Web使用HTTP(HyperText Transfer Protocol，超文本传输协议)协议作为规范，Web是建立在HTTP协议上通信的。

## HTTP诞生
* 为知识共享而规划Web，借助多文档之间相互关联形成的超文本，连成可相互参阅的WWW(World Wide Web万维网)
  + 页面文本标记语言HTML
  + 文档传递协议HTTP
  * 指定文档所在地址的URL
* Web成长时代
  + Web服务器：CGI、Apache
  + HTML：in-line
  + 浏览器：Netscape、IE、Firefox、Chrome、Opera、Safari
  + 浏览器竞争，不遵循Web标准化导致棘手的兼容性
* 驻足不前的HTTP
  + 1990：HTTP/0.9
  + 1996：HTTP/1.0 正式版
  + 1997：HTTP/1.1 目前主流的HTTP协议版本

## 网络基础TCP/IP
通常使用的网络是在TCP/IP协议族的基础上运作的，而HTTP属于它内部的一个子集。

### TCP/IP协议族
计算机和网络设备要相互通信，双方就必须基于相同的方案，不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则，我们把这种规则称为协议。

### TCP/IP分层管理
层次化之后，设计变得相对简单了，协议族按层次分别为
* 应用层
  + 决定了向用户提供应用服务时通信的活动
  + FTP、DNS、HTTP
* 传输层
  + 对上层应用层，提供处于网络连接中的两台计算机之间的数据传输
  + TCP、UDP
* 网络层
  + 处理在网络上流动的数据包，数据包是网络传输的最小数据单元，规定了通过怎样的路径到达对方计算机，并把数据包传送给对方
  + 与对方计算机之间通过多台计算机或网络设备进行传输是，网络层所起的作用就是在众多的选项内选择一条传输路线
  + IP
* 数据链路层
  + 处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、网络适配器、光纤等物理可见部分

### TCP/IP通信传输流
利用TCP/IP协议族进行网络通信时，会通过分成顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。
1. 应用层发送HTTP请求
2. 传输层TCP把应用层接收到的数据进行分割，并在各个报文上打上标记序号及端口号后发给网络层
3. 网络层增加作为通信目的地的MAC地址后转发给链路层
4. 接受端在链路层收到数据，按序往上层发送，一直到应用层，当传输到应用层，才能算真正接受到客户端发送过来的HTTP请求

> 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息，接收端在层与层传输数据时，每经过一层时会把对应的首部消去，这种把数据信息包装起来的做法称为封装。

## IP、TCP、DNS
这三个协议是与HTTP密不可分的。

### 负责传输的IP协议
作用把各种数据包传送给对方，而要保证确实传送到对方地址，则需要满足各类条件，其中两个最重要的条件是IP地址和MAC地址。

IP地址指名了节点分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对。IP地址可变换，但MAC地址基本上不会更改。

在网络上，通信的双方在同一局域网内的情况是很少见的，通常需要经过多台计算机和网络设备中转才能连接到对方，而在中转时，会利用下一站设备的MAC地址来搜索下一个中转目标，这时就需要ARP协议了，ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出对应的MAC地址。

### 确保可靠的TCP协议
可供可靠的字节流服务。所谓的字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠的传给对方。

为了准确无误的把数据送达目标处，TCP协议采用了三次握手策略。TCP不会对传送后的情况置之不理，他一定会向对方确认是否成功送达。握手过程中使用了TCP的标志——SYN和ACK。

大致过程：发送端先发送带有SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息，最后发送端再回传一个带ACK标志的数据包，表示握手结束。

### 负责域名解析的DNS服务
DNS服务是和HTTP协议一样位于应用层的协议，提供域名到IP地址的解析服务。

DNS提供域名查找IP地址，或逆向IP地址反查域名的服务。

## URL和URL
与URL（统一资源标识符）相比，我们更熟悉URL（统一资源定位符）。

URI全称Uniform Resource Identifier。
* Uniform：规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式
* Resource：可标识的任何东西
* Identifier：表示可标识的对象

> URL就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型的名称。

URI是用字符串标识某一互联网资源，而URL表示资源的地点。URL是URI的子集。

URI格式
* 登录信息（可选）
* 服务器地址
* 端口号
* 带层次的文件路径
* 查询字符串
* 片段标识符

# HTTP协议
请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。

响应报文基本上由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

HTTP是一种不保存状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。设计成这样是为了更快的处理大量事务，确保协议的可伸缩性，而特意把协议设计的如此简单。

Cookie状态管理：保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入Cookie技术。
* 服务端发送响应报文内Set-Cookie的首部字段信息，通知客户端保存Cookie
* 下次往服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去
* 服务器发送客户端发送过来的Cookie后，会检查究竟是哪一个客户端发来的连接请求，然后对比服务器记录，最后得到之前的状态信息

## HTTP方法
* GET：获取资源
  + 请求资源是文本，则保持原样返回
  + 如果是像CGI(通用网关接口)那样的程序，则返回经过执行后的输出结果
* POST：传输实体主体
  + 虽然GET也可以传输实体的主体，但是一般不用GET
  + POST的功能和GET类似，但主要目的不是获取响应的主体内容
* PUT：传输文件
  + 要求在请求报文主体中包含文件内容，然后保存到URI指定的位置
  + 自身不带验证机制，任何人都可以上传文件，存在安全性问题
* HEAD：获得报文首部
  + 不返回主体部分
  + 用于确定URI的有效性及资源更新的日期时间等
* DELETE：删除文件
  + 与PUT相反，按请求URI删除指定的资源
  + 自身同样不带验证机制
* OPTIONS：询问支持的方法
  + 查询针对请求URI指定的资源支持的方法
* TRACE：追踪路径
  + 让Web服务器将之前的请求通信环回给客户端的方法
  + 发送请求时在Max-Forwards首部字段中填入数值，每经过一个服务端就将该数字减1，当数值刚好减到0时，停止继续传输，最后接受到请求的服务端则返回状态码200 OK的响应
  + 用来查询发出去的请求是怎样被加工修改/篡改的
  + 易引发XST(Cross-Site Tracing，跨站追踪)攻击，通常不会用到
* CONNECT：要求用隧道协议连接代理
  + 要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL(Secure Sockets Layer安全套接层)和TLS(Transport Layer Security传输层安全)协议把通信内容加密后经网络隧道传输

### 持久连接
在HTTP初始版本中，没进行一次HTTP通信就要断开一次连接。

随着HTTP的普及，文档中包含大量图片的情况就多了起来，在发送请求访问HTML页面资源的同时，也会请求该HTML页面包含的其他资源。因此每次的请求都会造成TCP连接的建立和断开，增加通信量的开销。

为了解决上述问题，HTTP1.1和部分HTTP1.0想出了持久连接的方法，也称为HTTP keep-alive或HTTP connection reuse。持久连接的特点就是：只要任意一端没有明确提出断开连接，则保持TCP连接状态。

在HTTP1.1中，所有连接默认都是持久连接，但在HTTP1.0内并未标准化。

### 管道化
持久连接使得多数请求以管道化方式发送成为可能。以前发送请求后需等待并收到响应，才能发送下一个请求。管道化技术出现后，不用等待响应就可以直接发送下一个请求。

## Cookie状态管理
由于HTTP协议是无状态协议，无法根据之前的状态进行本次的请求处理。保留无状态这个特性同时又要解决类似的矛盾问题，于是引入的Cookie技术，Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态。

Cookie会根据服务端发送的响应报文中Set-Cookie的首部字段信息通知客户端写Cookie，当下次客户端再往服务端发请求时，客户端会自动在请求报文中加入Cookie值后发送出去。

# HTTP信息
HTTP报文本身是由多行（CR+CF作换行符）数据构成的字符串文本。

HTTP报文大致可以分为报文首部和报文主体两块，两者由最初出现的空行（CR+CF）来划分，通常并不一定要有报文主体。

其中头部信息可以进一步细分
* 请求行（状态行）
  * 请求行：请求的方法，URL和HTTP版本
  * 状态行：状态码，原因短语和HTTP版本
* 请求（响应）首部字段
* 通用首部字段
* 实体首部字段
* 其他

## 编码
HTTP在传输时可以按照数据原样直接传输，但也可以在传输中通过编码提升效率。

报文主体和实体主体差异
* 报文：HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输
* 实体：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成

HTTP报文主体用于传输请求或响应的实体主体

> 通常，报文主体等于实体主体，只有当传输中进行编码时，实体主体的内容发生变化时，才导致它和报文主体产生差异。

常见的内容编码
* gzip（GUN ZIP）
* compress（UNIX 标准压缩）
* deflate（zlib）
* identity（不进行编码）

分块传输：在HTTP通信中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面，在传输大容量数据时，通过把数据分隔成多块，能够让浏览器逐步显示页面。这种把主体分块的功能称为分块传输编码。

分块传输编码将实体主体分成多个部分，每块都会用16进制来表示标记块的大小，实体主体最后一块用"0(CR+CF)"来标记。

### 多部分对象集合
HTTP协议采用了多部分对象集合，发送一份报文主体内可含有多类型实体。通常在图片或文本上传时使用。

多部分对象集合包含的对象如下：
* multipart/form-data：在web表单文件上传时使用
* multipart/byteranges：状态码206响应报文包含了多个范围的内容时使用

在HTTP报文中使用多部分对象集合时，需要在首部字段加上`content-type`。使用boundary字符串来划分多部分对象集合指明的各类实体。

### 获取部分内容
背景：如果下载过程中遇到网络中断的情况，就必须重头开始，为了解决这个问题，需要一种可恢复的机制，所谓恢复是指能从之前中断下载处恢复下载。

要实现该功能，需要知道下载的实体范围，指定范围发送的请求就叫做范围请求。

执行范围请求，会用到首部字段range来指定资源的byte范围
```shell
# 5000·10000字节
range: bytes = 5001-10000
# 5001字节之后全部的
range: bytes = 5001-
# 从一开始到3000，和5000到7000的多重范围
range: bytes = -3000,5000-7000
```

针对范围请求，响应会返回状态码为206 Partial Content的响应报文，宁外对于多重范围的范围请求，响应会在首部字段`content-type`标明为multipart/byteranges后返回响应报文。如果服务端无法响应范围请求，则会返回状态码200 OK和完整的实体内容。

### 内容协商
当浏览器默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英文版和中文版的Web页面，这样的机制称为内容协商。

内容协商机制是指客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的依据。

包含在请求报文中的某些首部信息就是判断的依据
* accept
* accept-charset
* accept-encoding
* accept-language
* content-language

内容协商技术有一下三种类型
* 服务端驱动协商
* 客户端驱动协商
* 透明协商

# HTTP状态码
响应的状态码可描述请求的处理结果，数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。
* 1XX Informational（信息性状态码） 接收的请求正在处理
* 2XX Success（成功状态码） 请求正常处理完毕
* 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求
* 4XX Client Error（客户端错误状态码） 服务器无法处理请求
* 5XX Server Error（服务器错误状态码） 服务器处理请求出错

只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。

我们就介绍一下这些具有代表性的 14 个状态码。
* 2XX 成功：表明请求被正常处理了
  * 200 OK
  * 204 No Content：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分
  * 206 Partial Content：表示客户端进行了范围请求
* 3XX 重定向：表明浏览器需要执行某些特殊的处理以正确处理请求。
  * 301 Moved Permanently：永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。
  * 302 Found：临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。
  * 303 See Other：表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别
  * 304 Not Modified：表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。
  * 307 Temporary Redirect：临时重定向。该状态码与 302 Found 有着相同的含义。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。
* 4XX 客户端错误：表明客户端是发生错误的原因所在。
  * 400 Bad Request：该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。
  * 401 Unauthorized：表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。
  * 403 Forbidden：表明对请求资源的访问被服务器拒绝了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。
  * 404 Not Found：该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。
* 5XX 服务器错误：表明服务器本身发生错误
  * 500 Internal Server Error：在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。
  * 503 Service Unavailable：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。

> 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。

> 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。

> 附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。

# Web服务器

## 多个域名
HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。

在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。

## 代理、网关、隧道
HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序
* 代理是一种有转发功能的应用程序，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。
* 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。
* 隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

### 代理
代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。

> 每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息

在 HTTP 通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加 Via 首部字段以标记出经过的主机信息。

使用代理服务器的理由有
* 利用缓存技术减少网络带宽的流量
* 组织内部针对特定网站的访问控制
* 获取访问日志为主要目的
* ……等等。

代理有多种使用方法，按两种基准分类。
* 一种是是否使用缓存
* 另一种是是否会修改报文。

### 网关
网关与代理的区别就是，客户端通过HTTP协议与网关进行通信，但网关通过非HTTP通信协议与非HTTP服务器进行通信。

> 利用网关可以由 HTTP 请求转化为其他协议通信

网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。

利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。

### 隧道
隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

### 缓存
缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。

缓存的有效期限：即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。

客户端的缓存：缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。

# HTTP首部

# HTTPS 

# 身份认证

# 功能追加协议

# 构建Web内容的技术

# 攻击技术