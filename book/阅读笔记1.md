## 微前端
改造思路
* 只有一个不包含子项目资源的主项目，子项目通过主项目来按需加载，子系统间切换不再刷新
* 菜单栏、登录、退出等功能都从子项目剥离，写在主项目里，包括错误监控、埋点等行为
* 子项目原本需要加载的公共部分（第三方依赖），全部由主项目调度，配合 webpack 的 externals 功能通过外链的方式按需加载，这样一来每个子项目的dist文件里就只有子项目自己的业务代码

微前端强大之处：不同单页项目可随意组合成一个项目，反过来说，可以拆分一个大的主项目。

达到的目的：hash 路由的第一级决定了要加载哪个子项目（work、sms、tms），不同子项目间的切换也完全没有刷新

总得用户流程
1. 用户访问 index.html 后，浏览器运行加载器的 js 文件
2. 加载器去读取配置文件 apps.config.js，然后注册配置文件中配置的各个项目
3. 加载主项目(菜单等)，再通过路由判定，动态远程加载子项目

细节
* System.js：实现远程加载子项目
* Webpack Externals

## 前端发展史
前端历史发展过程中，我们所能沉淀下来什么
* 早期 Web1.0 时期的形态，纯静态展现，前端工作非常简单，职责偏向于 MVC 中的 View，页面交互需要整体刷新，体验很差
* 动态 Web 2.0 时代，面向过程时代码大量增加，难以维护
* 前端 MVC 时代，backbone.js 前端 MVC 分层尝试的先驱者
* 性能问题：雅虎 35 条军规
* 自动化工具：代码合并，压缩，CSS 预处理，雪碧图等（Grunt 为代表）
* MVC/MVP 只是提供了职责的划分，并没有简化代码量，需要同时关注 Modal(data) 和 DOM 操作(view)
* 如今工程化初具规模
  * webpack + babel
  * vue/ng/react
  * npm
  * eslint
  * Node + Express/Koa
  * git flow
* 更多 SSR、GraphQL
* Hybrid App（JS 和 Native 通信）
  * Cordova
  * React Native
  * NativeScript
  * Weex
  * Flutter

## 代码质量
今天看到一篇很清奇的文章，主要讲述代码质量相关，但作者是从反话入手，对于作者的观点和痛点，只能说深有感悟！

建议总结
* 不要过于追求让代码尽可能的短一点，比如要保证易读性的前提，比如三元表达式不要盲目使用
* 变量的命名，不要使用一个字母的变量，当然循环索引可以除外
* 不要使用单词缩写，比如 `browser -> brsr`，那样只有你自己看得懂
* 避免抽象的、通用的命名方式，比如
  * obj/data/value/item/elem
  * 根据变量类型命名：str/num，本质提供不了有价值的含义
  * 如果找不到更多的名字呢？追加一个数字，比如 item1、item2
* 避免智能同义词，比如函数前缀 display、show、render、paint
* 避免重用名字
  * 覆盖形参变量的值，会导致后来人不自己检查代码，根本不知道变量被修改过
  * 本地变量覆盖外部同名变量
* 避免使用下划线
  * 代码变得更长降低了可读性
  * 其他伙伴可能会花费很长事件来弄清楚下划线是什么意思
* 避免副作用和非标准结果
  * isXXX/checkXXX/findXXX 等函数看起来不会改变任何东西，也就是无副作用函数，因此一定不要产生去改变某些东西
  * 比如 isXXX/checkXXX 表意应该是返回 boolean，因此不要返回其他等不标准结果
* 避免强大的函数，函数功能要单一
  * 如果你觉得函数名称不好取了，就该思考是不是他做的事情太多
  * 多个动作加到一个会导致代码难以宠用

## 黑话
一些利用语言的特征使用的一些不常见的奇淫技巧，JavaScript 的语法是十分简单灵活的，在项目中建议大家遵从 ESLint 规范编写可维护性的代码

### 算数
算术中的位运算已被作者列为禁术，因此希望你在工程中使用位运算时，请确保你有充足的理由使用，并在需要时写好 Hack 注释。

#### ! 与 !!
`!` 为逻辑非操作符，`!` 强制转化为一个布尔值变量，在对其取反

`!!` 只是单纯的将操作数执行两次逻辑非，`!!` 任意类型的值转化为相应的布尔值

以下写法推荐你使用最后一种方式来进行转化：
```js
const enable1 = !!id;
const enable2 = id ? true : false;
const enable3 = Boolean(id)
```

#### ~ 与 ~~
`~` 表示按位非运算符，`~5` 步骤为
* 转为一个字节的二进制表示：00000101
* 按位取反：11111010
* 取其反码：10000101（符号位为 1 表示负数，将除符号位之外的其他数字取反）
* 末尾加 1 取其补码：10000110
* 转化为十进制：-6

针对负数的操作是为了统一加法和减法，在计算机中，减法会变成加一个负数，而负数会以补码的形式存储。`取反加一` 得到补码形式

如果只想按位取反，而不是附带补码的按位取反，让全 1 的数据和当前数据做按位抑或即可，比如：`0xFFFF ^ a`

简单理解，对任意数字按位非操作的结果为 `-(x + 1)`。

`~~` 就表示按位双非运算符了，那么 `~~x` 就为 `-(-(x + 1) + 1)`

`~value` 的使用，判断数组中是否有某元素
```js
if(arr.indexOf(ele) > -1) {} // 已读
if(~arr.indexOf(ele)) {} // 简洁
```

`~~value` 常用来代替 `Math.floor` 或 `parseInt`，且效率更高

#### +
变量前使用 `+` 的本意是将变量转换为数字。

使用 `+` 也可以作为立即执行函数：`+function() {}()`，等效于 `(function(){})()`。

#### & 与 &&
& 表示按位与，对应位均为 1 才为 1，其他情况为 0。需要两个数组并返回一个数字。如果不是数字，则会转换为数字。具体步骤
1. 转换为 2 进制
2. 比较结果
3. 转回十进制

&& 表示逻辑与，但需要注意的是，&& 并不是单纯的返回 true 或者 false
* 若第一个表达式为 false，则返回第一个表达式；
* 若第一个表达式为 true，返回第二个表达式。

除此以外，它还经常被作为短路逻辑使用：若前面表达式不是 truthy，则不会继续执行之后的表达式。如在取一个对象的属性，我们需要先判断是否为空才能进行取值，否则会抛出 Uncaught TypeError，这种情况下一般我们也会通过逻辑或，给与表达式一个默认值：
```js
const value = obj && obj.value || false
```

#### | 与 ||
它们与 `&` 和 `&&` 使用方法很相似，不同的是它们表示的是逻辑或，因此使用 `|` 会进行按位或运算（对应位有 1 则为 1，否则为 0），而 `||` 会返回第一个 Truthy 值。

使用 `||` 进行默认值赋值在 JavaScript 中十分常见，这样可以省略很多不必要的 `if` 语句

#### == 与 ===
这个想必是比较熟悉的，就不多啰嗦了。简单来说，`==` 用于判断值是否相等， `===` 判断值与类型是否都相等。

针对于 `undefined` 与 `null`：`undefined` 与 `null` 互等，与其余任意对象都不相等
```js
if (a == undefined) {}
if (a == null) {}
// 等效于
if(a === undefined || a === null) {}
```

对于 `''`, `false`, `0` 而言，他们都属于 Falsy 类型，通过 Boolean 对象都会转换为假值，而通过 `==` 判断三者的关系，他们总是相等的，因为在比较值时它们会因为类型不同而都被转换为 `false` 值

#### ^
按位异或运算符，对比每一个比特位，当比特位不相同时则返回 1，否则返回 0。很少人在 Web 开发中使用此运算符吧，除了传说中的一种场景：交换值。

若要交换 a 与 b 的值，如果可以的话推荐你使用：
```js
[a, b] = [b, a]
```

如果有人这样写
```js
a = a ^ b
b = a ^ b
a = a ^ b
```

但请忘记这种写法，简洁易读的函数才是最佳实践。

### 数值表示
数字几种你可能不知道的数值表达

#### 科学计数法
科学计数法是一种数学术语，将一个数表示为 a 乘以 10 的 n 次方，例子如下
```js
1e5; // 100000
2e-4; // 0.0002
-3e3; // -3000
```

Number 对象有 `toExponential(fractionDigits)` 方法以科学计数法返回该数值的字符串表示形式，参数 `fractionDigits` 可选，用于用来指定小数点后有几位数字

以下情况JavaScript会自动将数值转为科学计数法表示：
* 小数点前的数字多于21位。
* 小数点后的零多于5个。

#### 0.x 小数
通常某些人习惯省略 `0.` 开头的数字，常见于数值计算、css 属性中，比如 `0.5px` 可直接写为 `.5px` ，`0.2 * 0.3` 可写为：`.2 * .3`

#### 0x、0o 和 0b
JavaScript 提供了以下进制的表示方法：
* 二进制：只用 0 和 1 两个数字，前缀为 0b，十进制 13 可表示为 0b1101
* 八进制：只用 0 到7 八个数字，前缀为 0o，十进制 13 可表示为 0o15、015
* 十六进制：只用 0 到 9 的十个数字，和 a 到 f 六个字母，前缀为 0x，十进制 13 可表示为 0xd

默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制再进行运算。从十进制转其他进制请查阅 toString 方法，从其他进制转十进制请查阅 parseInt 方法，从其他进制转其他进制请先转为十进制再转为其他方法。

### 话术
你可能你知道函数技巧

#### Array.prototype.sort
默认根据字符串的 Unicode 编码进行排序，具体算法取决于实现的浏览器，在 v8 引擎中，若数组长度小于 10 则使用从插入排序，大于 10 使用的是快排。

sort 支持传入一个 compareFunction(a, b) 的参数，其中 a、b 为数组中进行比较的两个非空对象(所有空对象将会排在数组的最后)，具体比较规则为：
* 返回值小于0，a排在b的左边
* 返回值等于0，a和b的位置不变
* 返回值大于0，a排在b的右边

打乱数组的方法
```js
[1, 2, 3, 4].sort(() => .5 - Math.random())
```

这里你需要知道的是，以上实现并不是完全随机，究其原因，还是因为排序算法的不稳定性，导致一些元素没有机会进行比较，在抽奖程序中若要实现完全随机，请使用 Fisher–Yates shuffle 算法，以下是简单实现：
```js
function shuffle(arrs) {
  for(let i = arrs.length - 1; i > 0; i-= 1) {
    const random = Math.floor(Math.random() * (i + 1))
    [arrs[random], arrs[i]] = [arrs[i], arrs[random]]
  }
}
```

#### Array.prototype.concat.apply
apply 接收数组类型的参数来调用函数，值得注意的是，concat 可接收原始型或数组的多个参数，利用这个特性，可用来打平一个数组
```js
Array.prototype.concat.apply([, [1, [2, 3], [4]]])
```

通过此方法也可以写一个深层次遍历的方法
```js
function flattenDeep(arrs) {
  let result = Array.prototype.concat.apply([], arrs)
  while(result.some(item => item instanceof Array)) {
    result = Array.prototype.concat.apply([], result)
  }
  return result;
}
```

#### Array.prototype.push.apply
如果要对数组进行拼接操作，习惯于使用 concat 函数，比如
```js
let arrs = [1, 2, 3]
arrs = arrs.concat([4, 5, 6])
```

利用 apply 方法的数组传参特性，可以更简洁
```js
const arrs = [1, 2, 3]
arrs.push.apply(arrs, [4, 5, 6])
// 在 ES6 中，可以更简单
arrs.push(...arrs)
```

#### Array.prototype.length
它通常用于返回数组的长度，但是也是一个包含有复杂行为的属性，首先需要说明的是，它并不是用于统计数组中元素的数量，而是代表数组中最高索引的值。
```js
const arrs = []
arrs[5] = 1
console.log(arrs.length) // 6
```

length 长度随着数组的变化而变化，但是这种变化仅限于：子元素最高索引值的变化，假如使用 delete 方法删除最高元素，length 是不会变化的，因为最高索引值也没变
```js
const arrs = [1, 2, 3]
delete arrs[2] // 长度依然为 3
```

length 还有一个重要的特性，那就是允许你修改它的值，若修改值小于数组本身的最大索引，则会对数组进行部分截取，若赋予的值大于当前最大索引，则会得到一个稀疏数组。

在对length进行修改的时候，还需要注意：
* 值需要为正整数
* 传递字符串会被尝试转为数字类型

#### Object.prototype.toString.call
每个对象都有一个 `toString()`，用于将对象以字符串方式引用时自动调用，如果此方法未被覆盖，`toString` 则会返回 `[object type]`，因此 `Object.prototype.toString.call` 只是为了调用原生对象上未被覆盖的方法，`call` 将作用域指向需要判断的对象，这样一来就可以通过原生的 `toString`方法打印对象的类型字符串，利用这个特性，可以较为精确的实现类型判断。

#### Object.create(null)
用于创建无“副作用”的对象，也就是说，它创建的是一个空对象，不包含原型链与其他属性。

使用 `const map = {}` 创建出来的对象相当于 `Object.create(Object.prototype)`，它继承了对象的原型链。

#### JSON.parse(JSON.stringify(Obj))
很常用的一种深拷贝对象的方式，将对象进行JSON字符串格式化再进行解析，即可获得一个新的对象，要注意它的性能不是特别好，而且无法处理闭环的引用

这样通过 JSON 解析的方式其实性能并不高，若对象可通过浅拷贝复制请一定使用浅拷贝的方式，不管你使用 `{...obj}` 还是 `Object.assign({}, obj)` 的方式，而如果对性能有要求的情况下，请不要再造轮子了，直接使用 `npm:clone` 这个包或是别的吧。

### 理论
#### Truthy 与 Falsy
对每一个类型的值来讲，它每一个对象都有一个布尔型的值，Falsy 表示在 Boolean 对象中表现为 false 的值，在条件判断与循环中，JavaScript 会将任意类型强制转化为 Boolean 对象。以下这些对象在遇到 if 语句时都表现为 Falsy：
```js
false
null
undefined
0
NaN
''
""
document.all
```

其中 `document.all` 属于历史遗留原因，所以为 false，它违背了 JavaScript 的规范，可以不管它。

#### 原码, 反码, 补码
基本规律
* 正数的原码、反码、补码都是它本身
* 负数的反码：在其原码的基础上, 符号位不变，其余各个位取反
* 负数的补码：负数的反码 + 1

位运算就是用计算机底层电路所有运算的基础，为了让计算机的运算更加简单，而不用去辨别符号位，所有值都采用加法运算，因此，人们设计了原码，通过符号位来标识数字的正负
```js
1 = 0000 0001
-1 = 1000 0001
```

假如计算机要对两个数相加：1 + (-1)，使用原码相加的运算结果为：10000010，很明显-2并不是我们想要的结果，因此出现了反码，若使用反码进行运算会有什么结果呢，让我们来看一下：
```js
1[反码] + (-1)[反码] = 0000 0001 + 1111 1110 = 1111 1111[反码] = 1000 0000[原码]
```

此时运算结果是正确的，可是这样还存在一个问题，有两个值可以表示0：1000 0000、0000 0000，对于计算机来说，0 带符号是没有任何意义的，人们为了优化 0 的存在，设计出了补码：
```js
1[补码] + (-1)[补码] = 0000 0001 + 1111 1111 = 0000 0000[原码]
```

## 设计模式
设计模式分类
* 创建型：解决对象创建什么、有谁创建、何时创建问题
* 结构型：如何将类和对象组合在一起，形成更大的数据结构
* 行为型：对不同的对象划分责任和算法的抽象，关注类和对象之间的相互作用

### 创建型
创建型进一步分类
* 工厂模式
  * 命名建议：xxxFactory
  * 简单而言，就是对 new 操作符的进一步封装，因此有时候创建实例时，需要大量的准备工作
  * 选择工厂模式的原因是因为构造函数足够复杂或者对象的创建面临巨大的不确定性
* 建造者模式
  * 命名建议：xxxBuilder
* 原型
* 单例
  * 命名建议：xxxSingle，xxxSingleton
  * 限制一个类只能被实例化一次，防止多次实例化

### 结构型
结构型模式一共有7种
* 适配器
  * 命名建议：xxxAdapter，xxxWrapper
  * 被适配对象（adaptee）上套上一层封装，将其接口与目标对象（target）相匹配
* 桥接
  * 命名建议：xxxBridge
  * 桥接模式的主要目的，是将抽象与实现解耦，使得二者可以独立地进行变化
* 组合
* 装饰
* 外观
* 享元
* 代理

### 行为型
行为型模式一共有 5 种
* 命令
* 中介者
* 观察者
* 状态
* 策略

## Element-UI
设计一套组件库的时候，首先要考虑**颜色、字体、边框、图标**这些基础元素的设计，它们是构建各个组件的基石，如果没有做好这些基础设计，那么做出来的组件库看上去一定很山寨。

关于色彩的定义
* 定义主色，也叫品牌色，同时定义了一系列与主题相关的渐变色，通过 sass 提供的 mix 函数进行颜色混合
* 辅助色：success/waring/danger/info
* 中性色：文本、背景、边框颜色
  * 文字：主要文字，常规文字，次要文字，占位文字
  * 边框：一级、二级、三级、四级边框
  * 基础黑色、基础白色、透明

关于字体：对字体进行统一，力求在各个操作系统下都有最佳展示效果，比如 mac 用户比较熟悉的 PingFang SC，还有一些 win 用户熟悉的 MicroSoft YaHei。

关于字号：在 Element-UI 中定义了 6  种大小的字体，分别是 12/13/14/16/18/20

关于行高：一般设置至少为 1.5。这将有助于改善低可视条件下的体验。在 Element-UI 中只定义了两种行高，分别是 24 和 16

关于边框：element-ui 对边框进行统一规范，可用于按钮、卡片、弹窗等组件里。
* 边框和圆角：边框的粗细、颜色、样式，圆角大小等变量，还包括了 hover 的颜色
* 投影

关于图标：利用 IconFont 技术实现的

## 工程化探索
这部分内容和 umi.js 的设计非常像，我们可以这样思考，比如接入新的运营后台，怎么做到快速响应呢
* 保证业务开发尽量不被构建环节干扰，只须关注业务逻辑本身。
* 降低新页面接入的成本
  * 页面绑定对应的路由
  * 在左侧菜单栏添加菜单项并指向对应的路由
* 规范项目目录结构

要用这一套模式赋能更多不断冒出的新业务，首先要做的是统一。在社区上做开源软件和做公司内部的软件不同，前者通常需要考虑兼容性。处理兼容性的代价是越来越复杂的配置项。但做内部软件，则可以通过「统一」简化配置（甚至无需配置）。

首先是技术栈的统一：
* React
* 组件库：Ant.Design：Ant.Design 的组建覆盖了 90% 的需求
* 构建工具：Webpack
* 语言：TypeScript
* css 预编译：Less

技术栈的统一带来的是构建配置可以全部收敛，当然除了技术相关的工具，还有业务层面的工具可以统一收敛：
* 构建产物发布到 cdn
* 打点、错误监控的封装
* 网络请求库统一
* i18n 方案统一

## 面向对象
面向对象 vs 面向过程
```js
// oop 风格代码
Stack s = new Stack();
s.push(100);
s.push(200);
s.pop();
// 数据结构和函数分开
push(stack, 100);
push(stack, 200);
pop(stack);
```

面向对象三大特点：封装、继承和多态。

不管是用接口，还是传递函数，都是`延迟绑定`， 关键点都是要找到那个稳定的东西，就是抽象。你找不到这个稳定的东西，做不出抽象，你的系统就没法划分成可以独立开发，独立变化的组件了。

面向对象中：优先使用组合而不是继承

## TypeScript 研发体系建设
如何避免 TypeScript 问题，发挥 TypeScript 的优势，这里还是有需要学习的

工程篇
* 提交时类型检查：git commit 时触发类型检查
  * 整个项目的类型检查是非常耗时间的，TypeScript 3.4 中增加了 incremental 缓存功能
  * 在 tsconfig.json 中开启 skipLibCheck 检查，跳过第三方包类型报错
* eslint rule
  * 不要奇怪为什么是 eslint，因为 tslint 已经整合到 eslint 中
  * pri 不仅能在脚手架中生成这些配置沉淀，还能让项目在维护中，实时禁止这些配置的修改

工具篇：pont
* TypeScript 最大槽点：类型定义成本高，如果前端可以与后端，共享接口定义，返回数据类型的定义，那么类型定义成本将大大降低
* pont 通过 swagger 等接口文档工具，获取后端的接口、实体类的数据结构，然后转换为类型完美的前端接口层代码和业务要模型实体类代码
* 接口变更通知

框架篇：在 redux 中，要达到完美匹配是非常困难的，好在 TypeScript 有强大的类型推导能力，强大到 TypeScript 本身也是可以编程的，制定了 `iron-redux` 规范

规范篇：FF 与 OOP
* 纯函数的概念，让模块更可靠、架构逻辑更清晰，极大的降低了项目的复杂度
* OOP 的方法是天然的 mutable

OOP 的优势
* 业务模型复杂时，OOP 把数据结构和处理数据结构的方法组织在一起，比起 FP 的散乱陈列的方法更为清晰
* OOP 有丰富的、成熟的、好用的设计模式
* OOP 相比 FP，更容易发挥 TypeScript 的优势

思想篇
* 如果一个数据、方法、模块，类型定义成本高却不被调用，那么类型定义就是毫无意义的，这时候果断加上 any，不要有心里负担
* 类型代码在编译后会消失，如果仅仅调整代码类型，对代码运行逻辑不会有任何变更

## 参考
* [忍者代码](https://mp.weixin.qq.com/s/yYJYUJwiaqkkwGjDT4OvAA)
* [JavaScript中的“黑话”](https://mp.weixin.qq.com/s/104zIj_qhh9TQP1f02XPhg)
* [single-spa.js](https://single-spa.js.org/)
* [为什么面向对象糟透了？](https://mp.weixin.qq.com/s/nycmJowTtkjKAiQgfQHwhQ)