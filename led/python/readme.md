Python 入门学习

## Learn X in Y minutes
记录下自己觉得新鲜的玩意
* 语法
  * 当你想写大括号时，那就写 `:` 冒号吧，同时注意缩进
  * def 定义函数
  * 可变参数 `*args` 与关键字可变参数 `**kwargs`
  * 有趣的列表推导式，看着有点懵，项目中锻炼吧
* 整数地板除法，结果向下取整：`//`
* 超多的表达式：not/and/or/is/del/in/global/lambda/yield
  * is 用于比较两个变量是否指向同一个对象
  * global 因为它定义变量，不需要任何关键字，所以通过该关键字访问全局作用域
  * lambda 定义匿名函数
  * yield 生成器语法
* 超多内置方法：len/list/iter/map/filter/dir/range/abs/int/float/str/bool
  * list 将可迭代对象快捷转 array
  * dir 列出一个模块所有的值
  * range 生成整数序列
* 关于类
  * class 关键字，继承有点类似函数调用
  * 没有 new 关键字，直接函数调用
  * 有区别的类方法和静态方法，@classmethod、@staticmethod
* 关于模块
  * 和 js 的区别是调用 import 和 from
* 装饰器

列表推导式 demo
```py
# 用列表推导式可以简化映射和过滤。列表推导式的返回值是另一个列表。
[add_10(i) for i in [1, 2, 3]]  # => [11, 12, 13]
[x for x in [3, 4, 5, 6, 7] if x > 5]   # => [6, 7]
```

## 入门学习
stage
* ~~安装 Python~~
* ~~第一个 Python 程序~~
* ~~Python 基础~~
* ~~函数~~
* ~~高级特性~~
* ~~函数式编程~~
* ~~模块~~
* ~~面向对象编程~~
* ~~面向对象高级编程~~
* ~~错误、调试、测试~~
* ~~IO 编程~~
* ~~进程和线程~~
* ~~正则表达式~~
* 常用内建模块

字符编码
* ASCII：仅包括大小写英文字母、数字和一些符号，使用一个字节
* Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了，Unicode 标准也在不断发展，但最常用的是 UCS-16 编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。
* 可变长编码 UTF-8 编码把一个 Unicode 字符根据不同的数字大小编码成 1-6 个字节，常用的英文字母被编码成 1 个字节，汉字通常是 3 个字节，只有很生僻的字符才会被编码成 4-6 个字节。如果你要传输的文本包含大量英文字符，用 UTF-8 编码就能节省空间

现在计算机系统通用的字符编码工作方式：在计算机内存中，统一使用 Unicode 编码，当需要保存到硬盘或者需要传输的时候，就转换为 UTF-8 编码。

Python 字符串
* ord() 函数获取字符的整数表示
* chr() 函数把编码转换为对应的字符
* len() 获取长度
* 字符的 encode() 方法可以编码为指定的 bytes，把 bytes 变为 str，就需要用 decode() 方法
* 格式化
  * 元素符 %
  * format()
  * f-string 类似于模板字符串

list 和 tuple
* list: append/inset/pop
* tuple 通过小括号定义

dict 和 set
* dict
  * 获取元素通过中括号方式，如果没有该 key 会程序报错，但通过 get 方法，可以返回 None
  * pop 删除 key
* set
  * 通过内置类 set 进行创建，可通过 list 进行初始化
  * add/remove
  * 交集 &，并集 |

函数
* 空函数关键字：pass
* 类型检查 isinstance 函数
* 返回多个字，逗号隔开即可，本质上是返回 tuple，返回一个 tuple 可以省略括号
* 参数
  * 必选参数
  * 默认参数：默认参数必须指向不可变对象，否则不可变对象会被反复使用
  * 可变参数 *，类似于 js 的 `...
  * 关键字参数 **，自动组装为 dict
  * 命名关键字参数，特殊分隔符 `*`，`*` 号后面的参数被视为命名关键字参数
  * 可组合使用，顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数
* 递归函数
  * 所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
  * 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。
  * 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的
  * 遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化

高级特性
* 切片：针对 list 或 tuple，通过 [start:end] 的方式进行元素获取，start 和 end 均不写，原样复制一个 list
* 迭代：for-in 循环，对象的 items 和 values 获取对象的子项集合和值集合，判断对象是否是可迭代对象，isinstance(obj, Iterable)，如果你还是需要下标循环，则通过 enumerate 函数将 list 转换成索引-元素对
* 列表生成式：表达式 + for 循环 + [if 判断/for 循环]
* 生成器：一边循环一边计算的机制，称为生成器，在循环的过程中不断推算后续的元素，从而节省空间
  * 第一种方式：把列表生成式的 [] 改成 ()，就创建了一个 generator，通过 next 函数不断从 generator 中取值，或者使用 for-in 循环，因为 generator 本身是可迭代对象
  * 第二种方式：使用 yield 关键字，函数内包含 yield，则函数就不在时普通函数，而是一个 generator 函数，每次调用 next 函数的时候执行，遇到 yield 就返回，再次执行时从上次返回的 yield 语句处继续执行
* 迭代器：可以 next() 函数调用并不断返回下一个值的对象称为迭代器：Iterator，注意区分：Iterable 对象，可以通过 iter 函数获得一个 Iterator 对象

函数式编程
* 高阶函数：内建函数 map、reduce、filter、sorted
* 返回函数：使用闭包时，对外层变量赋值前，需要先使用 `nonlocal` 声明该变量不是当前函数的局部变量。
* 匿名函数：lamda 关键字，冒号前面表示函数参数，后面表示函数体
* 装饰器：运行期间动态增加功能，本质上是一个返回函数的高阶函数（wrapper），通过 __name__ 属性可以访问到函数的名字，由于 wrapper 后 __name__ 属性会发生变化，会导致依赖韩束签名的代码执行就会出错，因为还需要修改 __name__ 值，内置的 functools.wraps 就是干这事的
* 偏函数：把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。

模块
* 模块的好处：提高的代码的可维护性和可复用性
* 为了避免模块名冲突，Python 又引入了按目录来组织模块的方法，称为包（Package）
* 每一个包目录下面都会有一个 `__init__.py` 的文件，这个文件是必须存在的，否则，Python 就把这个目录当成普通目录，而不是一个包。
* 作用域
  * 正常的函数和变量名是公开的（public），可以被直接引用
  * 类似 `__xxx__` 这样的变量是特殊变量，可以被直接引用，但是有特殊用途
  * 类似 `_xxx` 和 `__xxx` 这样的函数或变量就是非公开的（private），不应该被直接引用
* 安装三方模块
  * 使用 pip 包管理器

面向对象编程
* 所有的类最终都会继承 object 类
* 私有方法或属性，使用 `__` 开头，坊间约定俗成的写法，使用一个下划线 `-` 也表示私有
* 获取对象信息
  * 基本类型使用 type()
  * 继承关系使用 isinstance()
  * 能用 type() 判断的基本类型也可以使用 isinstance()，isinstance() 还可以判断是不是某些类型中的一种
  * 总是优先使用 isinstance() 判断类型，可以将指定类型及其子类“一网打尽”
  * 使用 dir() 获得一个对象的所有属性和方法
  * 配合 getattr()、setattr() 以及 hasattr()，我们可以直接操作一个对象的状态

面向对象高级编程
* 实例支持动态添加方法或实例，可以通过 `__slots__` 限制实例的属性，仅对当前类实例其作用，对继承的子类不起作用
* @property 和 @property.setter 实现类似 javascript set/get 功能
* 多重继承，本质上是 Mixin
* 定制类
  * __len__() len 函数内部调用该函数
  * __str__() 类似于与 javascript toString()
  * __repr__() 返回程序开发者看到的字符串
  * __iter__() 返回可迭代对象
  * __getitem__() 按照下标取出元素，需要实现该方法
  * __setitem__()方法，把对象视作 list 或 dict 来对集合赋值
  * __delitem__()方法，用于删除某个元素
  * __getattr__()方法，当调用不存在的属性时，视图通过调用该方法返回一个属性，默认返回就是 None
  * __call__() 直接对实例进行调用
* 枚举类：Enum 函数，@unique 辅助装饰器，帮助我们检查保证没有重复值
* 元类
  * type() 函数既可以返回一个对象的类型，又可以创建出新的类型
  * metaclass 允许你创建类或者修改类

错误、调试、测试
* 错误处理
  * 用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须用大量的代码来判断是否出错
  * 错误处理机制 `try...except...finally...`
  * 如果没有错误发生，可以在 except 语句块后面加一个 else，当没有错误发生时，会自动执行 else 语句
  * 所有的错误类型都继承自 BaseException
  * 使用 try...except 捕获错误还有一个巨大的好处，就是可以跨越多层调用，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。
  * 如果错误没有被捕获，它就会一直往上抛，最后被 Python 解释器捕获，打印一个错误信息，然后程序退出
  * 如果不捕获错误，自然可以让 Python 解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。Python 内置的 logging 模块可以非常容易地记录错误信息
  * 如果要抛出错误，首先根据需要，可以定义一个错误的 class，选择好继承关系，然后，用 raise 语句抛出一个错误的实例，只有在必要的时候才定义我们自己的错误类型。如果可以选择 Python 已有的内置的错误类型，尽量使用 Python 内置的错误类型。
  * 捕获并抛出：捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。
* 调试
  * print/assert
  * logging：放心输出不同级别的信息，可以控制输出哪个级别的信息，而且可以输出到不同的地方，比如 console 和文件
  * pdb：set_trace() 设置一个断点
  * ide
* 单元测试
  * 自带 unittest 模块，测试方法以 test 开头
  * setUp 每调用一个测试方法前
  * tearDown 每调用一个测试方法后
  * 文档测试：doctest 直接提取注释中的代码并执行测试

IO 编程
* Input Stream 就是数据从外面（磁盘、网络）流进内存，Output Stream 就是数据从内存流到外面去。
* 同步 IO 与异步 IO
  * CPU 等着，也就是程序暂停执行后续代码，等写入磁盘后，再接着往下执行，这种模式称为同步 IO
  * CPU 不等待，只是告诉磁盘，你完成后通知我一下，于是，后续代码可以立刻接着执行，这种模式称为异步 IO。通知你的方法也各不相同。回调模式和轮询模式两种模式。
  * 使用异步 IO 来编写程序性能会远远高于同步 IO，但是异步IO的缺点是编程模型复杂。
* 读写文件
  * open：传入文件路径和模式，模式比如 `r`、`rb`、`w`、`wb`、`wba`，拿到文件对象
  * f.read/readline/readlines
  * f.close 关闭文件：Python 引入了 with 语句来自动帮我们调用 close() 方法
* StringIO 和 ByteIO：内存中读写 string 和 bytes
* os 模块可以直接调用操作系统提供的接口函数
  * os 模块：name/uname()/environ/mkdir()/rmdir()/rename()/remove()/listdir()/isdir()/isfile()
  * os.path 模块：path.join()/path.abspath()/path.split()/splittext()
  * shutil 模块，os 模块的补充：shutil.copyfile()
* 序列化
  * 把变量从内存中变成可存储或传输的过程称之为序列化，序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。把变量内容从序列化的对象重新读到内存里称之为反序列化。
  * pickle 模块：dumps/dump/loads/load
  * json 模块提供了非常完善的 Python 对象到 JSON 格式的转换

进程
* 单核 CPU 也可以执行多任务，操作系统轮流让各个任务交替执行，表面上都是交替执行的，由于 CPU 速度太快，感觉是同时执行一样
* 真正的并行执行多任务只能在多核 CPU 上实现，但由于任务数量远远多于 CPU 核心数量，同样需要调度执行
* 通俗而言，一个任务是一个进程，子任务称为线程
* 由于每个进程至少要干一件事，所以一个进程至少有一个线程，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行
* 多任务的实现有3种方式：
  * 多进程模式
  * 多线程模式
  * 多进程+多线程模式
* 同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，所以复杂度要远远高于我们前面写的单进程单线程的程序
* 线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定
* 多进程
  * multiprocessing 模块是跨平台版本的多进程模块，提供了Queue、Pipes等多种方式来交换数据。
  * Process 类来代表一个进程对象，start 启动、join 等待进程结束后再继续往下运行，通常用于进程间同步
  * Pool 进程池，close 关闭，join 方法等待所有子进程执行完毕
  * subprocess 模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出
* 多线程
  * threading 模块，Thread 类创建线程，start 方法开始执行
  * 主线程实例的名字叫 MainThread，子线程的名字在创建时指定
  * current_thread() 函数，它永远返回当前线程的实例
  * 多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了
  * 高级语言的一条语句在 CPU 执行时是若干条语句，而执行这几条语句时，线程可能中断，从而导致多个线程把同一个对象的内容改乱了
  * 通过 threading.Lock() 的方式创建锁，lock.acquire 获取，lock.release 释放
  * Python 的线程虽然是真正的线程，但解释器执行代码时，有一个 GIL 锁：Global Interpreter Lock，任何 Python 线程执行前，必须先获得 GIL 锁，然后，每执行 100 条字节码，解释器就自动释放 GIL 锁，让别的线程有机会执行。这个 GIL 全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在 Python 中只能交替执行，即使 100 个线程跑在 100 核 CPU 上，也只能用到 1 个核。Python 虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个 Python 进程有各自独立的 GIL 锁，互不影响。
  * 由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。
  * local 方法创建 ThreadLocal 实例用于方便线程中局部变量数据访问
  * ThreadLocal 最常用的地方就是为每个线程绑定一个数据库连接，HTTP 请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源
*  进程 vs 线程
  * 实现多任务，通常我们会设计 Master-Worker 模式，Master 负责分配任务，Worker 负责执行任务，因此，多任务环境下，通常是一个 Master，多个 Worker。
  * 多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。多进程模式的缺点是创建进程的代价大，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。
  * 多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。
  * 线程切换：先保存当前执行的现场环境（CPU寄存器状态、内存页等）、把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等）。因此，**多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。**
* 计算密集型 vs IO密集型
  * 计算密集型任务的特点是要进行大量的计算，消耗 CPU 资源。最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。
  * IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成，对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。
  * 异步IO：如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。对应到 Python 语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。
* 分布式进程
  * multiprocessing 模块不但支持多进程，其中 managers 子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于 managers 模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。

正则表达式
* 内置 re 模块
* 推荐使用 `r` 前缀书写正则表达式，不用考虑 Python 字符串本身也用 `\` 转义
* re.match 方法判断是否匹配，匹配成功返回 Match 对象，否则返回 None
* 提取子串，`()` 表示要提取的分组，match 对象的 group 方法访问分组，0 号位置永远是整个正则表达式相匹配的字符串，1、2…… 才表示第 1、2……个子串
* 正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符，加个 `?` 就可以让 `\d+` 采用非贪婪匹配
* 如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，通过 `re.compile` 完成