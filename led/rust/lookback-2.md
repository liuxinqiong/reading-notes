相关特性
* 借用和所有权
* 模式匹配
* 生命周期
* 并发编程：支持线程，同时还支持并发，允许在单线程中实现并发

& 符号有两个主要用途，它可以表示引用（reference）和借用（borrowing），* 符号用主要用解引用
* 当用 & 符号创建一个引用时，它创建了对某个值的引用，而不会转移该值的所有权。引用允许你在不拥有值的情况下访问它。引用通常用于函数参数、数据结构中的字段、以及在借用（borrowing）中。
* & 符号还可以用于创建借用，包括可变和不可变的借用。不可变借用允许对值进行只读访问，而可变借用则允许修改值。借用通常用于函数参数，以便在函数中引用数据而不获取所有权。
* 当 * 用于引用类型之前，它表示解引用操作，即访问引用所指向的值。因为在 Rust 中，使用引用时，我们通常使用 & 符号创建引用，而在需要使用引用指向的实际值时，我们使用 * 进行解引用。

在 Rust 中，生命周期通常以撇号（'）加上标识符的方式表示，例如 'a、'b 等。生命周期注解是 Rust 的一部分，用于指定引用之间的关系，使编译器能够验证引用的有效性。

关于生命周期的示例
```rs
struct Foo {
    x: &i32,
}

fn main() {
    let y = &5;
    let f = Foo { x: y };

    println!("{}", f.x);
}
// 上述代码会报错：y的借用被传递到了结构体 y 中，因此必须确保 y 的生命周期比 f 要长，此时我们添加生命周期标记
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5;
    let f = Foo { x: y };

    println!("{}", f.x);
}

// 如下的粒子 i 中，要求 x,y 具备相同的生命周期，但使用的时候由于 b 的生命周期较短，因此会报错提示 b 生命周期不够长
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
fn main() {
    let a = "hello";
    let result;
    {
        let b = String::from("world");
        result = longest(a, b.as_str());
    }
    println!("The longest string is {}", result);
}
```