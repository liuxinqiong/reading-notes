## JS 运行机制

### 为什么 Promise 里代码比 setTimeout 先执行？
当拿到一段 JS 代码时，浏览器或者 Node 环境首先要做的就是：传递给 JS 引擎，并且要求他去执行。

我们首先应该形成一个感性的认知：一个 JS 引擎会常驻于内存中，它等待我们（宿主）把 JS 代码或者函数传递给它执行。

在 ES3 和更早的版本中，JS 本身还没有异步执行代码的能力，这也就意味着宿主环境传递给 JS 引擎一段代码。引擎就把代码直接顺序执行。但在 ES5 之后，JS 引入了 Promise，这样不需要浏览器安排，JS 引擎本身也可以发起任务了。

> 我们把宿主发起的任务成为宏观任务，把 JS 引擎发起的任务成为微观任务。

JS 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。

在底层 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，用伪代码表示如下
```js
while(true) {
    r = wait()
    execute(r)
}
```

当然实际代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑。

在宏观任务中，JS 的 Promise 还会产生异步代码，JS 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务队列中又包含了一个微观任务队列。

如何分析异步执行的顺序
* 首先分析有多少个宏观任务
* 每个宏观任务中，分析有多少个微观任务
* 根据调用次序，确定宏观任务中的微任务执行次序
* 根据宏观任务的触发规则和调用次序，确定宏任务的执行次序

Promise 是 JS 中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是用 ES6 开始，有了 async/await，这个语法改进跟 Promise 配合，能够有效地改善代码结构。

async/await 是 ES2016 新加入的特性，它的运行时基础是 Promise。

async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。

async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。

async 的强大之处在于，它是可以嵌套的，我们在定义了一批原子操作的情况下，可以利用 async 函数组合出新的 async 函数。

### 闭包和执行上下文
可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，闭包和普通函数的区别是，它携带了执行的环境。

这个古典的闭包定义中，闭包包含两个部分
* 环境部分
  * 环境：函数的词法环境
  * 标识符列表：函数中用到的未声明的变量
* 表达式部分：函数体

> 这里有个常见的概念误区，有些人会把 JS 执行上下文，或者作用域这个概念当作闭包。实际上 JS 中跟闭包对应的概念就是“函数”，可能这个概念太过于普通，跟闭包看起来又没什么联系，所以才会形成这个误区吧。

执行上下文在 ES3 中包含三个部分
* scope：作用域，也叫做作用域链
* variable object：变量对象，用于存储变量的对象
* this value 值

在 ES5 中，改进了命名方式
* lexical environment：词法环境，当获取变量时使用
* variable environment：变量环境，当生命变量时使用
* this value：this 值

> 在 ES2018 中，执行上下文中增加了不少内容，为避免复杂度，这里不讨论

### 函数种类
函数种类
* 普通函数：用 function 关键字定义的函数
* 箭头函数：用 => 运算符定义的函数
* 方法：在 class 中定义的函数
* 生成器函数：用 function * 定义的函数
* 类：用 class 定义的类，实际上也是函数

普通函数的 this 值由 `调用它所使用的引用` 决定，其实奥秘就在于：我们获取函数的表达式，实际上返回的并非函数本身，而是一个 Reference 类型。Reference 由两部分组成：一个对象和一个属性值。当做一些算数运算（或者其他运算时），Reference 类型会被解引用，即获取真正的值（被引用的内容）来参与运算，而类似函数调用、delete 等操作，都需要用到 Reference 类型中的对象。

> 调用函数时使用的引用，决定了函数执行时刻的 this 值

在 JS 标准中，为函数规定了用来保存定义时上下文的私有属性 [[Environment]]。当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的 [[Environment]]。

this 则是一个更为复杂的机制，JS 标准定义了 [[thisMode]] 私有属性，私有属性有三个取值
* lexical：表示从上下文中找 this，这对应了箭头函数
* global：表示当 this 为 undefined 时，取全局对象，对应了普通函数
* strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined

> 非常有意思的是，方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行。

call/apply/bind 用于不接受 this 的函数类型如箭头、class 都不会报错，这时候，它们无法改变 this 的能力，但是可以实现传参。

### try-finally
思考下面的代码
```js
function foo() {
    try {
        return 0
    } catch(err) {

    } finally {
        console.log('a')
    }
}
console.log(foo())
// 结果：先打印 a，在打印 0
```

行为表现：虽然 return 执行了，但是函数并没有立即返回，又执行了 finally 里面的内容。在看一个例子
```js
function foo() {
    try {
        return 0
    } catch(err) {

    } finally {
        return 1
    }
}
console.log(foo()) // 1
```

行为表现：finally 中的 return 覆盖了 try 中的 return。

因为 finally 中的内容必须保证执行，所以 try/catch 执行完毕，即使得到的结果是非 normal 型的完成记录，也必须要执行 finally，而当 finally 执行也得到了非 normal 记录，则会使 finally 中的记录作为整个 try 结构的结果

这些奇怪的行为表现背后有一套机制在运作，这一机制的基础正是 JavaScript 语句执行的完成状态，用一个标准类型表示：Completion Record，用于描述异常跳出等语句执行过程，表示一个语句执行完之后的结果，它有三个字段
* [[type]] 表示完成的类型，有 break，continue，return，throw 和 normal 几种类型
* [[value]] 表示语句的返回值，如果语句没有，则是 empty
* [[target]] 表示语句的目标，通常是一个 JavaScript 标签

> JavaScript 正是依靠语句的 Completion Record 类型，方才可以在语句的复杂嵌套结构中，实现各种控制。

语句的分类
* 普通语句：这些语句在执行时，从前向后顺次执行，没有任何分支或者重复执行逻辑，普通语句执行后会得到 type 为 normal 的 Completion Record，JS 引擎遇到这样的 Completion Record，会继续执行下一条语句。这些语句中只有表达式语句会产生 value，使用浏览器调试可以知道，输入一个表达式，在控制台可以得到结果，但是前面加一个 var，就变成了 undefined，控制台显示的正是语句的 Completion Record 的 value
  * 声明类语句（var，const，let，函数声明，类声明）
  * 表达式语句
  * 空语句
  * debugger 语句
* 语句块：拿大括号括起来的一组语句，我们需要注意的是语句块内部的语句的 Completion Record 的 type 不为 normal 会打断语句块后续的语句执行
* 控制型语句
  * 内部产生影响：if、switch、while/for、try
  * 外部产生影响：continue、return、throw
* 带标签语句

在任何 JS 语句是可以加标签的，在语句前加冒号即可，比如
```js
firstStatement: var i = 1
```

大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与完成记录类型中的 target 相配合，用于跳出多层循环
```js
outer: while(true) {
    inner: while(true) {
        break outer;
    }
}
console.log('finished')
```

break/continue 语句如果后跟了关键字，会产生带 target 的完成记录，一旦完成记录带了 target，那么只有拥有对应 label 的循环语句会消费它

因为 JS 语句存在着嵌套关系，所以执行过程实际上主要在一个树形结构上进行，树形结构的每一个节点执行后产生 Completion Record，根据语句结构和 Completion Record，JS 实现了各种分支和跳出逻辑。

## CSS 选择器

### 选择器分类
基本分类如下
* 简单选择器：针对某一特征判断是否选中元素
  * 类型选择器：元素标签名
  * 全体选择器
  * id 选择器
  * class 选择器
  * 属性选择器
  * 伪类选择器
* 复合选择器：连续写在一起的简单选择器，根据元素自身特征选择单个元素
* 复杂选择器：由空格、>、~、+、|| 等符号连接的复合选择器，根据父元素或者前序元素检查单个元素
* 选择器列表：由逗号分隔的复杂选择器，表示或关系

如果 svg 和 html 都有 a 元素，要想区分选择 svg 中的 a 和 html 中的 a，就必须用带命名空间的类型选择器
```css
@namespace svg url(http://www.w3.org/2000/svg)
@namespace html url(http://www.w3.org/1999/xhtml)
svg|a {
    stroke: blue;
    stroke-width: 1;
}
html|a {
    font-size: 40px;
}
```

属性选择器有四种形态
* 第一种：[attr] 检查是否具有这个属性
* 第二种：[attr=val] 检查属性的值是否是 val
* 第三种：[attr~=val] 检查一个值是否是若干值之一，这里的 val 不是一个单一的值了，可以是用空格分隔的一个序列
* 第四种：[attr|=val] 开头匹配

> 有些 HTML 属性含有特殊字符，这时候可以把 val 用引号括起来，形成一个 CSS 字符串。

伪类选择器是一些列由 CSS 规定好的选择器，以冒号开头，有普通型和函数型两种

树结构关系伪类选择器
* :root：表示树的根元素，在选择器是针对完成 html 的文档情况，一般用 html 标签即可选中根元素，但随着 scoped css 和 shadow root 等场景的出现，选择器可以针对某一个子树来选择，这时候就很需要 root 伪类了
* :empty：表示没有子节点的元素
* :nth-child 和 nth-last-child 函数型伪类：处理 An + B 型，语法为 :nth-child(An+B)、:nth-child(An+B of S)、:nth-child(even|odd)
* :first-child 和 :last-child： 表示第一个和最后一个
* :only-child 选中唯一一个子元素
* of-type 系列是一个变形的语法糖，S:nth-of-type(An+B)是:nth-child(An+B of S) 的另一种写法，依次类推还有：nth-last-of-type、first-of-type、last-of-type、only-of-type

链接与行为伪类选择器
* :any-link 表示任意的链接
* :link 表示未访问过的链接，:visited 表示访问过的链接
* :hover 表示鼠标悬停在上的元素
* :active 表示用户正在激活的这个元素，按下按钮，鼠标还未抬起时，这个按钮就处于激活状态
* :focus 表示焦点落在这个元素之上
* :target 用于选中浏览器 URL 的 hash 部分所指示的元素

逻辑伪类选择器
* :not 函数型伪类，选中内部简单选择器命中的元素，用于取反操作
```css
:not(p)
{
    color:#ff0000;
}
```

> 伪类是很大的一类简单选择器，它是选择器能力的一种补充，在实际应用中，建议尽量通过合适的 id 和 class 来标识元素，约束伪类的使用，最好只在不得不使用伪类的场景使用伪类，这对于 CSS 代码的性能和可读性都有好处。

### 选择器组合、优先级和伪元素

#### 选择器的组合
根据选择器列表的语法，选择器的连接方式可以理解为像四则运算一样有优先级
* 第一优先级：无连接符号
* 第二优先级
  * "空格"：后代
  * "~"：后继
  * "+"：直接后继
  * ">"：子代
  * "||"：列选择器
* 第三优先级
  * ","

> 我们在实际使用时，比较常用的连接方式是 "空格" 和 ">"

工程实践中一般会采用设置比较合理的 class 方式，来避免过于复杂的选择器结构，这更有利于维护和性能

空格和子代选择器通常用于组件化场景，当组件是独立开发时，很难完全避免 class 重名的情况，如果为组件的最外层容器元素设置一个特别的 class 名，生成 css 规则时，则全部使用后代或者子代选择器，这样可以有效避免 CSS 规则的命名污染问题。

#### 选择器的优先级
CSS 选择器是基于规则生效的，同一个元素命中多条规则是非常常见的事情。不同规则指定同一个属性为不同值时，就需要一个机制来解决冲突。

CSS 标准用一个三元组(a,b,c)来构成一个复杂选择器的优先级
* id 选择器的数目记为 a
* 伪类选择器和 class 选择器的数目记为 b
* 伪元素选择器和标签选择器数目记为 c
* "*" 不影响优先级

CSS 标准建议用一个足够大的进制，获取"a-b-c"来表示选择器优先级，即
```js
ty = base * base * a + base * b + c
```

另外行内属性的优先级永远高于 CSS 规则，浏览器提供了一个口子，就是选择器前加上 "!important"，这个用法非常危险，因为它相当于一个新的选择器，而此优先级会高于行内元素。

同一优先级的选择器遵循"后面的覆盖前面的"原则。

> 虽然我们学习了详细的计算方式，但是在选择器的使用上，如果产生复杂的优先级计算，代码的可读性一定是有问题的

这里有个简单规则来使用选择器，不要搞出过于复杂的选择器
* 根据 id 选单个元素
* class 和 class 的组合选成组元素
* tag 选择器确定页面风格

#### 伪元素
伪元素的语法和伪类相似，但是实际产生的效果却是把不存在的元素硬选出来。目前兼容性达到可用的伪元素有一下几种
* ::first-line：表示元素的第一行，CSS 标准规定了 first-line 必须出现在最内层的块级元素之内
* ::first-letter：表示元素的第一个字母，位置出现在所有标签之内
* ::before
* ::after

> CSS 标准只要求 ::first-line 和 ::first-letter 实现有限的几个 CSS 属性，都是文本相关。

::before 和 ::after 和前面两个不同的是，它不是把已有的内容套上一个元素，而是真正的无中生有，造出一个元素。这两个伪元素所在的 CSS 规则必须执行 content 属性才会生效。同时还支持 content 为 counter，这对于实现一些列表样式是非常有用的。

::before 和 ::after 支持所有的 CSS 属性，在实际开发中中，这两个元素非常有用，有了这两个伪元素，一些修饰性元素，可以使用纯粹的 CSS 代码添加进去，这能够很好的保持 HTML 代码中的语义，既完成了显示效果，又不会让 DOM 中出现很多无语义的空元素。