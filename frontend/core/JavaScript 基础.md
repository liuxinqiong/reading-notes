JavaScript 基础

巩固一下 JavaScript 语法方面的基础

## 相关内容
基础内容大致分为如下几个方面
* 作用域
* 原型、原型链、继承
* 事件循环、消息队列、任务队列
* 类型隐式转换

## 作用域
关于作用域涉及到的方面非常多
* 编译原理与预处理
* 词法作用域、动态作用域
* 执行上下文、执行上下文栈
* 作用域链
* 闭包、this

编译原理，程序中一段源代码在执行之前会经历三个步骤，统称为编译
* 分词/词法分析：将字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元（Token）
* 解析/语法分析：将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树称为抽象语法数（AST）
* 将 AST 转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关

理解作用域我们需要了解三个角色
* 引擎：负责整个 JS 程序的编译及执行过程
* 编译器：负责语法分析及代码生成
* 作用域：负责收集并维护由所有声明的标志符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标志符的访问权限

我们通过一个场景，理解上面三个角色的工作，比如处理 `var a = 2` 代码时
1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域中，如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域中声明一个新的变量，命名为 a
2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理赋值操作。引擎首先询问作用域，当前作用域中是否存在一个叫做 a 的变量，如果是，引擎使用这个变量，如果否，引擎会继续查找
3. 如果找到了 a 变量，就会将 2 赋值给它，否则引擎会举手示意并抛出一个异常

总结：引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤
* 首先，var a 在其作用域中声明新变量，这会在最开始的阶段，也就是代码执行前进行。就是我们常说的**预处理阶段**
* 接下来，a = 2 会查询变量 a 并对其进行赋值

### 预处理
JavaScript 语法的全局机制：预处理和指令序言
* 不理解预处理就无法理解 var 等声明类语句的行为
* 不理解指令序言，就无法理解严格模式

JavaScript 在执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。

预处理的典型现象是**声明提升**：指声明会被视为存在于其所出现的作用域的整个范围内，这个过程好像变量和函数声明从它们在代码中出现的位置被移动到了最上面，因此就叫做提升。

为了解释这些特殊问题，就要拿出编译器的内容了。引擎会在解释 JS 代码之前首先对其进行编译。编译阶段的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。

正确的思考是：包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。对于 `var a = 2`，JS 会看成两个声明，var a 和 a = 2，第一个**定义声明在编译阶段进行**，第二个**赋值声明会被留在原地等待执行阶段**。

注意：其中 class 声明在全局的行为跟 function 和 var 都不一样，声明前使用 class 名，会抛错。难道是 class 没有被预处理。那下面的代码就解释不通了
```js
var c = 1
function foo() {
    console.log(c)
    class c {}
}
foo()
```

此时代码仍然会抛出错误，但如果去掉 class 声明，就会正常工作。说明后面 class 声明影响了前面语句的结果。

因此 class 声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误（暂时性死区）。同时 class 声明作用不会穿透 if 等语句结构。这样的 class 设计比 function 和 var 更符合直觉，而且在遇到一些比较奇怪的用法时，倾向于抛出错误。

脚本和模块都支持一种特别的语法，叫做指令序言。最早是为了 use strict 设计的，规定了一种给 JS 代码添加元信息的方式。

"use strict" 是 JS 标准中规定的唯一一种指令序言，但是设计指令序言的目的是，留给 JS 的引擎和实现者一些统一的表达方式，在静态扫描时指定 JS 代码的一些特性。

JS 指令语言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体最前面。

### 作用域
作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。

作用域共有两种主要的工作模型
* 词法作用域：也叫做静态作用域，最为普遍的，被大多数编程语言所采用，函数的作用域在函数定义的时候就决定了。
* 动态作用域：小众，但仍有一些编程语言在使用（bash 脚本、Perl），函数的作用域是在函数调用的时候才决定的。

词法阶段：大部分标准语言编译器的第一个工作阶段叫做词法化（也叫单词化），词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。这是理解词法作用域及其名词来历的基础。

词法作用域就是定义在词法阶段的作用域，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况是这样的，因为有一些欺骗词法作用域的方法，这些方法在词法分析器处理过后依旧可以修改作用域，但这种机制可能有点难以理解，事实上，让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践）

> 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定，编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

在 JS 中有两种机制实现运行时来修改（欺骗）词法作用域呢。但需要注意的是：欺骗词法作用域会导致性能下降。
* eval
* with

> 引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的位置，才能在执行过程中快速找到标识符。因此如果出现了 eval 和 with，所有的优化可能都是无意义的，因此最简单的做法就是不做任何优化。

JavaScript 中产生作用域的两种方式
* 函数作用域
* 块作用域

函数作用域都比较熟悉了，重点说说块作用域，一下方式会创建块作用域
* with：从对象中创建出来的作用域仅在 with 生命中而非外部作用域中有效
* try-catch：catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效
* let/const

**注意**：let 循环的特别之处，for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上他将其重新绑定到了 for 循环的每一个迭代中。

### 执行上下文、执行上下文栈
深入理解闭包和 this 的关键，是理解执行上下文和执行上下文栈。

当一个函数被调用时，会创建一个活动记录（也被称作**上下文**），这个记录会包含函数在哪里被调用（调用栈），函数的调用方式，传入的参数等信息。this 就是这个记录的一个属性，会在函数执行过程中用到。

执行上下文在 ES3 中包含三个部分
* scope：作用域，也叫做作用域链
* variable object：变量对象，用于存储变量的对象
* this value 值

在 ES5 中改进了命名方式（之后新的版本中，添加的更多的东西，这里不考虑）。
* lexical environment：词法环境，当获取变量时使用
* variable environment：变量环境，当声明变量时使用，存储了在上下文中定义的变量和函数声明。
* this value：this 值

为了管理创建的多个执行上下文，需要用到执行上下文栈。程序结束之前，ECStack 最底部永远有个 globalContext。

变量对象包括
* 函数的所有形参 (如果是函数上下文)
* 函数声明
* 变量声明

上面提到的**预处理**，具体结果的完全可以通过进入执行上下文时，变量对象（AO）表达出来。预处理（分析）结束后，在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值。我们这里重点观察分析阶段的结果，从而加深对预处理的理解。
```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}

foo(1);
```

此时的 AO 为
```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```


### 作用域链
当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。
* 函数创建：函数有一个内部属性 `[[scope]]`，当函数创建的时候，就会保存所有父变量对象到其中
* 函数激活：当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。

直接看有点抽象，直接看下伪代码
```js
// 例子代码
var scope = "global scope";
function checkscope(){
    var scope2 = 'local scope';
    return scope2;
}
checkscope();

// 1. 函数被创建，保存作用域链到内部属性[[scope]]
checkscope.[[scope]] = [
    globalContext.VO
];
// 2. 执行函数，创建执行上下文，并压栈
ECStack = [
    checkscopeContext,
    globalContext
];
// 3. 开始执行前准备工作准，第一步：复制函数[[scope]]属性创建作用域链
checkscopeContext = {
    Scope: checkscope.[[scope]],
}
// 4. 第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    }，
    Scope: checkscope.[[scope]],
}
// 5. 第三步：将活动对象压入 checkscope 作用域链顶端
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: [AO, [[Scope]]]
}
// 6. 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值
checkscopeContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: 'local scope'
    },
    Scope: [AO, [[Scope]]]
}
// 7. 查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出
ECStack = [
    globalContext
];
```

### this
动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用，换句话说，作用域是基于调用栈的，而不是代码中的作用域嵌套。

主要区别
* 词法作用域实在写代码和定义时确定的，而动态作用域是在运行时确定的（this 也是）
* 词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用

this 既不指向函数自身也不指向函数的词法作用域。this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时用的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。因此 this 机制某种程度上很像动态作用域，算是表亲关系了。

为什么要有 this
* this 提供了一种更优雅的方式来隐式传递一个对象引用，因此可以将 API 设计的更加简洁并且易于复用。
* 随着你的使用模式越来越复杂，显示传递上下文对象会让代码变得越来越混乱，使用 this 则不会这样。尤其是面对对象和原型时，你就会明白函数可以自动引用合适的上下文有多重要。

要想知道 this 指向哪里，首先需要寻找函数的调用位置。但是做起来并不简单，因为某些编程模式可能会隐藏真正的调用位置。

最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数），我们关心的调用位置就在当前正在执行的函数前一个调用中。也就是**调用栈的第二个元素就是真正的调用位置**。

用应用场景角度理解 this 指向：调用位置如何决定 this 的绑定对象。
* 默认绑定：独立函数调用，可以看做无法应用其他规则时的默认规则。this 在非严格模式下指向全局对象，严格模式为 undefined
* 隐式绑定：是否被某对象拥有或包含。当函数拥有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。**注意一个隐式丢失问题**。
* 显式绑定：call/apply/bind
* new 绑定

ES6 提供了一种无法使用这些规则的特殊函数类型：箭头函数。简单函数并不是使用 function 关键字定义的，而是使用被称为胖箭头的操作符定义的，**箭头函数不使用 this 的四种标准准则，而是根据外层作用域来决定 this**。

从规范角度理解 this 就显得复杂一些
* Reference：只存在于规范里的抽象类型。它们是为了更好地描述语言的底层行为逻辑才存在的，但并不存在于实际的 js 代码中。由三个组成部分
  * base value
  * referenced name
  * strict reference
* 普通函数的 this 值由 `调用它所使用的引用` 决定，其实奥秘就在于：我们获取函数的表达式，实际上返回的并非函数本身，而是一个 Reference 类型。Reference 由两部分组成：一个对象和一个属性值。当做一些算数运算（或者其他运算时），Reference 类型会被解引用，即获取真正的值（被引用的内容）来参与运算，而类似函数调用、delete 等操作，都需要用到 Reference 类型中的对象。
* 如何根据 Reference 确定 this
  1. ref = MemberExpression。简单理解 MemberExpression 就是 `()` 左侧部分
  2. 判断 ref 是不是 Reference，如果不是，则 this 为 undefined
  3. 如果是，如果 base value 是对象，则 this 为 base value
  4. 如果是，如果 base value 是 Environment Recode，则 this 为 ImplicitThisValue(ref)，该函数始终返回 false

this 则是一个更为复杂的机制，JS 标准定义了 [[thisMode]] 私有属性，私有属性有三个取值
* lexical：表示从上下文中找 this，这对应了箭头函数
* global：表示当 this 为 undefined 时，取全局对象，对应了普通函数
* strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined

> 非常有意思的是，方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行。

### 闭包
对于那些有一点 JS 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生！

闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用他们而有意识的创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境

闭包的定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

古典的闭包定义中，闭包包含两个部分
* 环境部分
  * 环境：函数的词法环境
  * 标识符列表：函数中用
* 表达式部分：函数体

闭包的作用：函数在定义时的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域。

本质上无论何时何地，如果将函数当做第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。比如异步任务中，使用了回调函数，实际上就是使用闭包。

> 关于闭包的讨论可能不太一致，宽松而言，通过普通的词法作用域查找就可以理解为闭包。但从纯学术的角度，还需满足函数是在当前词法作用域之外执行。

闭包的原理就是作用域链。看一段代码
```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
```

函数维护了一个作用域链，就是因为这个作用域链，函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。