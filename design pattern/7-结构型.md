## 代理模式
代理模式：在不改变原始类（或者叫做被代理类）代码的情况下，通过引入代理类来给原始类来给原始类附加功能。

为了将框架代码和业务代码解耦，代理模式就排上用场了。

原始的 Proxy 实现方式（静态代理）
* 代理类和原始类实现相同的接口，原始类只负责业务功能，代理类负责在业务逻辑执行的前后附加其他逻辑代码，并通过委托的方式调用原始类来执行代码
* 如果原始类没有定义接口，或者原始类并不是我们开发的，这时候我们可以采用继承的方式实现，通过 super 的方式来调用业务代码

但上述方式肯定是有问题的
1. 需要在代理类中，将原始类的所有的方法都要重新实现一遍，并且每个方法都附加相似的代码逻辑
2. 如果要添加附加功能的类不知有一个，需要针对每个类都要创建一个代理类，会导致类的个数成倍的增加，增加代码维护成本

这时候我们可以使用**动态代理**：我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类

> 在 Java 语言中，本身提供了动态代理的语法，依赖的就是 Java 的反射语法

代理类应用场景
1. 业务系统中的非功能性需求开发（监控、统计、鉴权、限流、事务、日志等）
2. RPC、缓存中的应用
  * RPC 也是一种代理模式，有一种说法叫做**远程代理**，通过远程代理，把网络通信、数据编解码等细节隐藏起来
  * 缓存应用：比如某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理：从配置文件中加载需要支持缓存的接口，以及响应的缓存策略，比如过期时间等，当请求到来的时候，在 AOP 切面中拦截请求，如果请求中带有支持缓存字段，便从缓存（内存缓存或者 redis 缓存等）中获取数据直接返回