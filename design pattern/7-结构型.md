## 代理模式
代理模式：在不改变原始类（或者叫做被代理类）代码的情况下，通过引入代理类来给原始类来给原始类附加功能。

为了将框架代码和业务代码解耦，代理模式就排上用场了。

原始的 Proxy 实现方式（静态代理）
* 代理类和原始类实现相同的接口，原始类只负责业务功能，代理类负责在业务逻辑执行的前后附加其他逻辑代码，并通过委托的方式调用原始类来执行代码
* 如果原始类没有定义接口，或者原始类并不是我们开发的，这时候我们可以采用继承的方式实现，通过 super 的方式来调用业务代码

但上述方式肯定是有问题的
1. 需要在代理类中，将原始类的所有的方法都要重新实现一遍，并且每个方法都附加相似的代码逻辑
2. 如果要添加附加功能的类不知有一个，需要针对每个类都要创建一个代理类，会导致类的个数成倍的增加，增加代码维护成本

这时候我们可以使用**动态代理**：我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类

> 在 Java 语言中，本身提供了动态代理的语法，依赖的就是 Java 的反射语法

代理类应用场景
1. 业务系统中的非功能性需求开发（监控、统计、鉴权、限流、事务、日志等）
2. RPC、缓存中的应用
  * RPC 也是一种代理模式，有一种说法叫做**远程代理**，通过远程代理，把网络通信、数据编解码等细节隐藏起来
  * 缓存应用：比如某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理：从配置文件中加载需要支持缓存的接口，以及响应的缓存策略，比如过期时间等，当请求到来的时候，在 AOP 切面中拦截请求，如果请求中带有支持缓存字段，便从缓存（内存缓存或者 redis 缓存等）中获取数据直接返回

## 桥接模式
桥接模式，也叫桥梁模式，Bridge Design Pattern。

目的：**将抽象和实现解耦，让它们可以独立变化**

另一个理解方式：**一个类存在两个（或多个）独立变化的维度，通过组合的方式，让这两个（或多个）维度可以独立进行扩展**。通过组合关系来替代继承关系，避免继承层次的指数级爆炸。非常类似与**组合由于继承**的设计原则

> 很多设计模式都是试图将庞大的类拆分成更细小的类，然后在通过某种更合理的结构组装在一起

弄懂定义中抽象和实现两个概念，是理解它的关键。

## 装饰器模式
装饰器也有组合的设计思想，用于避免继承爆炸的问题。Java IO 中就有装饰器的设计思想。

一段简单的 IO 代码
```java
InputStream in = new FileInputStream('path');
InputStream bin = new BufferedInputStream(in);
byte[] data = new byte[128];
while(bin.read(data) != -1) {}
```

你有没有思考过，为什么需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 来使用。为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedInputStream 呢。这样就可以这样使用，不是更简单吗
```java
InputStream in = new BufferedInputStream('path');
byte[] data = new byte[128];
while(bin.read(data) != -1) {}
```

如果只考虑到增强缓存读取的能力，那通过继承确实可以应付。但如果还需要对其他方面的增强，比如 DataInputStream 类，支持按照基本数据类型来读取数据。这时候又需要增加一个继承类，这还可以理解，但如果同时需要，就会导致更多的继承类。如果需要附加更多的功能，就会导致继承爆炸。

装饰器相对于简单的组合关系，还有两个比较特殊的地方
* 装饰类和原始类继承同样的父类，这样就可以对原始类嵌套多个装饰器类，比如如下的几支持缓存读取，有支持按照基本类型读取
  ```java
  InputStream in = new FileInputStream('path');
  InputStream bin = new BufferedInputStream(in);
  DataInputStream din = new DataInputStream(bin);
  int data = din.readInt()
  ```
* 装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点

> 代理类附加的是更原始类无关的功能，而在装饰器模式中，附加的是跟原始类相关的增强功能

## 适配器模式
Adapter Design Pattern：将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作

实现的两种主要方式
* 类适配器：通过继承关系来实现
* 对象适配器：通过组合关系来实现

具体例子：ITarget 表示要转换成的接口定义，Adaptee 是一组不兼容的 ITarget 接口定义的接口。Adaptor 将 Adaptee 转换成符合 ITarget 接口定义的接口
```java
public interface ITarget {
  void f1();
  void f2();
  void fc();
}

public class Adaptee {
  public void fa() {}
  public void fb() {}
  public void fc() {}
}

// 类适配器
public class Adaptor extends Adaptee implements ITarget {
  public void f1() {
    super.fa();
  }
  public void f2() {
    super.fb();
  }
}

// 对象适配器
public class Adaptor implements ITarget {
  private Adaptee adaptee;

  public Adaptor(Adaptee adaptee) {
    this.adaptee = adaptee;
  }

  public void f1() {
    this.adaptee.fa();
  }
  public void f2() {
    this.adaptee.f2();
  }
  public void fc() {
    this.adaptee.fc();
  }
}
```

实际开发该选择哪种方式呢
* 如果 Adaptee 接口并不多，那两种实现方式都可以
* 如果 Adaptee 接口很多，并且 Adaptee 和 ITarget 大致相同，则使用类适配器，因为可以复用父类的接口，代码量少一些
* 如果 Adaptee 接口很多，并且 Adaptee 和 ITarget 大部分不同，则使用对象适配器，因为组合更加灵活

常见的应用场景：**补偿模式，用来补救设计上的缺陷，应用这种模式算是无奈之举**
* 封装有缺陷的接口设计
* 统一多个类的接口：某个功能的实现依赖多个外部系统，通过适配器模式，将它们的接口适配为统一的接口定义
* 替换依赖的外部系统：将项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动
* 兼容老版本接口：将老接口标注为 deprecated，并将内部实现逻辑委托为新的接口实现
* 适配不同格式的数据

代理、桥接、装饰器和适配器的区别
* 笼统的来说，都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类
* 代理模式：在不改变原始类接口的条件下，为原始类定义个一个代理类，主要目的是访问控制，而非加强功能
* 桥接模式：将接口部分和实现部分分离，从而让他们可以较为容易、也相对独立的加以改变
* 装饰器模式：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用
* 适配器模式：一种事后补救策略，提供跟原始类不同的接口