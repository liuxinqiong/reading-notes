创建型设计模式主要解决对象的创建问题，结构型设计模式主要解决类或对象的组合问题。行为型设计模式主要解决的就是类或对象之间的交互问题。

## 创建型设计模式
包括：单例模式、工厂模式、建造者模式、原型模式。主要解决对象创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码

单例模式用来创建全局唯一的对象。

工厂模式包括简单工厂、工厂方法和抽象工厂这 3 中细分模式。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定参数来决定创建那种类型的对象。当创建逻辑比较复杂，是一个大工程的时候，就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用分离。

工厂模式的主要作用有下面 4 个
* 封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者更透明
* 代码复用：创建代码抽离到独立的工厂类之后可以复用
* 隔离复杂性：封装复杂的创建逻辑，调用者无须了解如何创建对象
* 控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁

建造者模式用来创建复杂对象，可以通过设置不同的可选参数，定制化的创建不同的对象

原型模式：如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，可以用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。

## 结构型设计模式
主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定的应用场景的问题，主要包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式以及享元模式

代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而且加强功能，这是它跟装饰器模式最大的不同。一般情况下，让代理类和原始类实现同样的接口。

代理模式主要有静态代理和动态代理两种方式。静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码有点像模板式的重复代码，增加了维护成本和开发成本。可以通过动态代理来解决，不事先为每个类编写代理类，而是在运行的时候动态的创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在 RPC、缓存等应用场景中。

桥接模式有两种理解方式
* 将抽象和实现解耦，让它们能独立开发
* 组合优于继承的设计原则

装饰器模式主要解决继承关系过于复杂的问题，通过组合来替代继承，给原始类添加增强功能。这也是判断是否该用设计模式的一个重要的依据。还有一个特点，那就是可以对原始类嵌套使用多个装饰器。为了满足这样的需求，在设计的时候，装饰器类需要跟原始类继承相同的抽象类或者接口

适配器模式主要用来做适配，将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。
* 类适配器：通过继承关系实现
* 对象适配器：通过组合关系实现

门面模式：通过封装细粒度的接口，提供组合各个细粒度的高层次接口，来提高接口的易用性，或者解决性能、分布式事务等问题。

组合模式：首先和面向对象设计中的组合关系完全是两码事。主要是用来处理树形结构数据。

享元模式：被共享的单元，意图是复用对象，节省内存，前提是相远对象是不可变对象

## 行为型设计模式
主要有观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式

观察者模式将观察者和被观察者代码解耦，应用场景非常广泛

模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤

模板方法有两大作用
* 复用：子类可以复用父类提供的模板方法的代码
* 扩展：通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能

策略模式：定义一族算法类，将每个算法分别封装起来，让他们可以互相替换。策略模式用于解耦策略的定义、创建、使用
* 定义：包含一个策略接口和一组实现这个接口的策略类
* 创建：由工厂类来完成，封装策略创建的细节
* 客户端自行选择使用那个策略

策略模式常见的应用场景
* 避免冗长的 if-else 或 switch 判断
* 提供框架的扩展点
* 主要作用：解耦策略的定义、创建和使用，控制代码的复杂度，让每个部分都不止与过于复杂、代码量过多
* 满足开闭原则，添加新策略的时候，最小化、集中化代码改动，减少引入 bug 的风险

职责链模式，多个处理器依次处理同一个请求，比如先经过 A，再经过 B，再经过 C，依次类推，形成一个链条，链条上每个处理器各自承担各自的处理职责。通常有两种形式
* 一旦某个处理器能够处理这个请求，就不会继续将请求传递给后续的处理器
* 实际开发中，也存在这个模式的变体，那就是请求不会中途终止传递，而是会被所有的处理器都处理一遍

职责链模式常用来实现过滤器、拦截器功能，让框架的使用者在不需要修改框架源码的情况下，添加新的过滤、拦截功能。也提现了之前提到的开闭原则

迭代器模式：用于遍历集合对象，作用就是解耦容器代码和遍历代码，带来三个优势
* 封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可
* 将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一
* 添加新的遍历算法更加容易，更符合开闭原则

状态模式一般用来实现状态机，常用在游戏、工作流引擎等系统开发中。状态机由 3 个部分组成：状态、事件、动作

访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。

备忘录模式：再不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。

命令模式：最核心的实现手段，就是将函数封装成对象，用来控制命令的执行，比如异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等

解释器模式：用来实现根据语法规则解读句子的解释器

中介模式：设计思想跟中间层很像，通过引入中介这个中间层，将一堆对象之间的交互关系从多对多转换为一对多

## 如何避免过度设计或设计不足
设计模式的初衷是提高代码质量

> 在做代码设计的时候，一定要先问自己，为什么要这样设计，为什么要应用这个设计模式，这样做是否能真正地提高代码质量，能提高代码质量的那些方面，如果自己很难讲请求，或者给出的理由都比较牵强，没有压倒性的优势，基本上就可以断定这是一种过度设计，是为了设计而设计

设计原则和思想是心法，设计模式只是招式。

设计的过程是先有问题后有方案：我们要先去分析代码存在的痛点，比如可读性不好，可扩展性不好等，然后再针对性的利用设计模式去改善。

设计的应用场景是复杂代码：设计模式要干的事情就是解耦，也就是利用更好的代码结构将一大坨代码拆分成职责更单一的小类，让其满足高内聚低耦合等特性。创建型设计模式是将创建和使用代码解耦，结构型设计模式是将不同的功能代码解耦，行为型设计模式是将不同的行为代码解耦。

持续重构能有效避免过度设计。当真正有痛点的时候，我们再去考虑用设计模式来解决，而不是一开始就为不一定实现的未来需求而应用设计模式

避免设计不足的 3 个必要条件
* 一定要有理论知识的储备
* 一定的刻意训练
* 一定要有代码质量意识、设计意识：写代码之前，要多想想未来会有哪些扩展的需求，哪部分是会变的，哪部分是不变的，这样写会不会导致之后添加新的功能比较困难，代码的可读性好不好等代码质量问题

不要脱离具体的场景去谈设计
* 偏底层、框架类的、通用的代码，代码质量就比较重要，因为一旦出现问题或者代码改动，影响面比较大
* 业务系统或者不需要长期维护的项目，那稍微放低点代码质量的要求，也是没问题的。而且自己的代码跟其他项目没有太多耦合，即便处理问题，影响也不大