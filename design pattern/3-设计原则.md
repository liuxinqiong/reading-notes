## 单一职责原则
英文名：Single Responsibility Principle，缩写为 SRP。描述：一个类或者模块只负责完成一个职责或者功能。

目的：**为了实现代码高内聚、低耦合**
* 避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性
* 类职责单一，类依赖和被依赖的其他类也会变少，减少了代码的耦合性

简单表述：不要设计大而全的类，要设计粒度小，功能单一的类。一个类包含了两个或者两个以上业务不相干的功能，就说它职责不够单一，应该拆分成多个功能更加单一、粒度更细的类。

问题就是：大部分情况下，类里的方法是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的。

> 不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。

在判断类的职责是否足够单一，并没有一个非常明确的、可以量化的标准，这其实是一个主观题。实际上。在真正的软件开发中，没必要过于未雨绸缪，过渡设计。**我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构**

判断是否单一的小技巧
* 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，就需要对类进行拆分
* 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，就需要考虑对类进行拆分
* 私有方法过多，考虑能够将私有方法独立到新的类中，设置为 public 方法供更多类使用，从而提高代码的复用性
* 比较难给类起一个合适名字，很难用一个业务名词概括，只能用一些笼统的 Manager、Context 之类的词语来命名，由此说明类职责定义得可能不够清晰
* 类中大量的方法都是集中操作类中的某几个属性，那就可以考虑将这几个属性和对应的方法拆出来

从另一个角度看，一下情况说明类的行数、函数、属性过多了
* 当类的代码读起来头大了
* 实现某个功能时不知道该用哪个函数了
* 想用哪个函数翻半天都找不到了
* 只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）

类的职责是否设计的越单一越好：答案是否定的，拆得过细可能降低代码的内聚性

原则：应用设计模式或原则，最终目的是提高代码的可读性、可扩展性、复用性、可维护性等，考虑应用某一个设计原则是否合理的时候，还是要依次作为考虑标准

## 对扩展开放、修改关闭
开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则。

为什么难以理解：怎么样的代码改动才被定义为扩展，怎么样的代码改动才被定义为修改

为什么难以掌握：如何在项目中灵活应用开闭原则，以避免在项目中灵活地应用开闭原则，以避免在追求扩展性的同时影响到代码的可读性

为什么最有用：扩展性是代码质量最重要的衡量标准之一。在 23 中经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。

英文全称：Open Closed Principle，简写 OCP。软件实体（模块、类、方法等）应该对扩展开放、对修改关闭。简单描述那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）

告警通知例子，重构前
```java
interface Alert {
    AlertRule alertRule;
    Notification: notification;
    void check(...params)
}
```

重构思路
* check 函数多个入参封装成 ApiStatInfo
* 引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中

重构后
```java
interface Alert {
    List<AlertHandler> alertHandlers = new ArrayList<>();
    void addAlertHandler();
    void check(ApiStatInfo apiStatInfo)
}
interface AlertHandler {
    AlertRule alertRule;
    Notification: notification;
    void check(ApiStatInfo apiStatInfo)
}
```

合格的代码改动：**只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试**

顶层指导思想
* 为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些潜意识比任何开发技巧都重要。
* 多花时间往前多思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事前留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构，做到最小代码改动的情况下，新的代码能够很灵活的插入到扩展点上，做到对扩展开放，对修改关闭。
* 识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

具体方法论
* 多态、依赖注入、基于接口而非实现编程
* 大部分设计模式：装饰、策略、模板、职责链、状态等

如何才能识别出可能的扩展点
* 如果是业务导向系统，需要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求
* 业务无关的、通用的、偏底层系统
  * 它们会被如何使用
  * 今后打算添加哪些功能
  * 使用者未来会有哪些更多的功能需求

没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计，合理的做法是
* 对一些比较确定的，短期内可能就会扩展的
* 需求改动对代码结构影响比较大的情况
* 实现成本不高的扩展点

> 开闭原则不是免费的，有些情况下，代码的扩展性会跟可读性相冲突。因此很多时候，我们都需要在扩展性和可读性之间做权衡

## 里氏替换
英文全称：Liskov Substitution Principle，缩写：LSP。

中文描述：子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。

多态 vs 里氏替换
* 多变是面向对象编程的一大特性，是一种代码实现的思路
* 里氏替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性

子类设计的时候，要遵循父类的行为约定，父类定义的函数的行为约定，子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。行为约定包括
* 函数声明要实现的功能
* 对输入、输出、异常的约定
* 甚至包括注释中所罗列的任何特殊情况说明

判断子类的设计实现是否违背里氏替换原则：那就是那父类的单元测试去验证子类的代码，如果某些单元测试运行失败，则有可能说明，子类的设计实现没有完全地遵循父类的约定，子类有可能违背了里氏替换原则。

## 接口隔离原则
英文全称：Interface Segregation Principle，简称：ISP。

中文表示：客户端不应该强迫依赖它不需要的接口。其中客户端可以理解为接口的调用者或者使用者。

软件开发中，接口的概念很宽泛
* 一组抽象的约定
* 系统与系统之间的 API 接口
* 面向对象编程语言中的接口

把接口理解为一组 API 接口集合：在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口

把接口理解为单个接口或函数：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现

把接口理解为 OOP 中的接口概念：接口职责尽可能单一，单一就意味着通用、复用性好

## 依赖反转原则
控制反转：Inversion Of Control，简称 IOC，**框架提供了一个可扩展的代码骨架，用来组装对象，管理整个执行流程。程序员利用框架进行开发的时候只需要往预留的扩展点上，添加根自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行**。这里的控制指的是对程序执行流程的控制，而反转指的是没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员反转到了框架。

> 控制反正并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来知道框架层面的设计。

依赖注入：一种具体的编码技巧，缩写为 DI，不通过 new 方式在类内部创建依赖类对象，而是将依赖类对象在外部创建好之后，通过构造函数、函数参数等方式传递给类使用。

依赖注入框架：通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象，管理对象的声明周期、依赖注入等原本需要程序员来做的事情。

依赖反转原则：Dependency Inversion Principle，缩写为 DIP，也叫做依赖倒置原则。高层模块不要依赖底层模块。高层模块和底层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。

关于高层模块和底层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于底层