## 单一职责原则
英文名：Single Responsibility Principle，缩写为 SRP。描述：一个类或者模块只负责完成一个职责或者功能。

目的：**为了实现代码高内聚、低耦合**
* 避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性
* 类职责单一，类依赖和被依赖的其他类也会变少，减少了代码的耦合性

简单表述：不要设计大而全的类，要设计粒度小，功能单一的类。一个类包含了两个或者两个以上业务不相干的功能，就说它职责不够单一，应该拆分成多个功能更加单一、粒度更细的类。

问题就是：大部分情况下，类里的方法是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的。

> 不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。

在判断类的职责是否足够单一，并没有一个非常明确的、可以量化的标准，这其实是一个主观题。实际上。在真正的软件开发中，没必要过于未雨绸缪，过渡设计。**我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构**

判断是否单一的小技巧
* 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，就需要对类进行拆分
* 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，就需要考虑对类进行拆分
* 私有方法过多，考虑能够将私有方法独立到新的类中，设置为 public 方法供更多类使用，从而提高代码的复用性
* 比较难给类起一个合适名字，很难用一个业务名词概括，只能用一些笼统的 Manager、Context 之类的词语来命名，由此说明类职责定义得可能不够清晰
* 类中大量的方法都是集中操作类中的某几个属性，那就可以考虑将这几个属性和对应的方法拆出来

从另一个角度看，一下情况说明类的行数、函数、属性过多了
* 当类的代码读起来头大了
* 实现某个功能时不知道该用哪个函数了
* 想用哪个函数翻半天都找不到了
* 只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）

类的职责是否设计的越单一越好：答案是否定的，拆得过细可能降低代码的内聚性

原则：应用设计模式或原则，最终目的是提高代码的可读性、可扩展性、复用性、可维护性等，考虑应用某一个设计原则是否合理的时候，还是要依次作为考虑标准

## 对扩展开放、修改关闭
开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则。

为什么难以理解：怎么样的代码改动才被定义为扩展，怎么样的代码改动才被定义为修改

为什么难以掌握：如何在项目中灵活应用开闭原则，以避免在项目中灵活地应用开闭原则，以避免在追求扩展性的同时影响到代码的可读性

为什么最有用：扩展性是代码质量最重要的衡量标准之一。在 23 中经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。

英文全称：Open Closed Principle，简写 OCP。软件实体（模块、类、方法等）应该对扩展开放、对修改关闭。简单描述那就是，添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）

告警通知例子，重构前
```java
interface Alert {
    AlertRule alertRule;
    Notification: notification;
    void check(...params)
}
```

重构思路
* check 函数多个入参封装成 ApiStatInfo
* 引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中

重构后
```java
interface Alert {
    List<AlertHandler> alertHandlers = new ArrayList<>();
    void addAlertHandler();
    void check(ApiStatInfo apiStatInfo)
}
interface AlertHandler {
    AlertRule alertRule;
    Notification: notification;
    void check(ApiStatInfo apiStatInfo)
}
```

合格的代码改动：**只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试**

顶层指导思想
* 为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。这些潜意识比任何开发技巧都重要。
* 多花时间往前多思考一下，这段代码未来可能有哪些需求变更，如何设计代码结构，事前留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构，做到最小代码改动的情况下，新的代码能够很灵活的插入到扩展点上，做到对扩展开放，对修改关闭。
* 识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。

具体方法论
* 多态、依赖注入、基于接口而非实现编程
* 大部分设计模式：装饰、策略、模板、职责链、状态等

如何才能识别出可能的扩展点
* 如果是业务导向系统，需要对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求
* 业务无关的、通用的、偏底层系统
  * 它们会被如何使用
  * 今后打算添加哪些功能
  * 使用者未来会有哪些更多的功能需求

没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计，合理的做法是
* 对一些比较确定的，短期内可能就会扩展的
* 需求改动对代码结构影响比较大的情况
* 实现成本不高的扩展点

> 开闭原则不是免费的，有些情况下，代码的扩展性会跟可读性相冲突。因此很多时候，我们都需要在扩展性和可读性之间做权衡

## 里氏替换
英文全称：Liskov Substitution Principle，缩写：LSP。

中文描述：子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。

多态 vs 里氏替换
* 多变是面向对象编程的一大特性，是一种代码实现的思路
* 里氏替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性

子类设计的时候，要遵循父类的行为约定，父类定义的函数的行为约定，子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。行为约定包括
* 函数声明要实现的功能
* 对输入、输出、异常的约定
* 甚至包括注释中所罗列的任何特殊情况说明

判断子类的设计实现是否违背里氏替换原则：那就是那父类的单元测试去验证子类的代码，如果某些单元测试运行失败，则有可能说明，子类的设计实现没有完全地遵循父类的约定，子类有可能违背了里氏替换原则。

## 接口隔离原则
英文全称：Interface Segregation Principle，简称：ISP。

中文表示：客户端不应该强迫依赖它不需要的接口。其中客户端可以理解为接口的调用者或者使用者。

软件开发中，接口的概念很宽泛
* 一组抽象的约定
* 系统与系统之间的 API 接口
* 面向对象编程语言中的接口

把接口理解为一组 API 接口集合：在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口

把接口理解为单个接口或函数：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现

把接口理解为 OOP 中的接口概念：接口职责尽可能单一，单一就意味着通用、复用性好

## 依赖反转原则
控制反转：Inversion Of Control，简称 IOC，**框架提供了一个可扩展的代码骨架，用来组装对象，管理整个执行流程。程序员利用框架进行开发的时候只需要往预留的扩展点上，添加根自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行**。这里的控制指的是对程序执行流程的控制，而反转指的是没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员反转到了框架。

> 控制反正并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来知道框架层面的设计。

依赖注入：一种具体的编码技巧，缩写为 DI，不通过 new 方式在类内部创建依赖类对象，而是将依赖类对象在外部创建好之后，通过构造函数、函数参数等方式传递给类使用。

依赖注入框架：通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象，管理对象的声明周期、依赖注入等原本需要程序员来做的事情。

依赖反转原则：Dependency Inversion Principle，缩写为 DIP，也叫做依赖倒置原则。高层模块不要依赖底层模块。高层模块和底层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。

关于高层模块和底层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于底层

## KISS & YAGNI 原则
KISS 原则是一个万金油的设计原则，可以应用在很多场景中。不仅经常用来指导软件开发，还经常用来指导更加广泛的系统设计。

KISS 原则是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug 比较难隐藏。即使出现 bug，修复起来也比较简单。

KISS 原则并没有指出什么样的代码才是 Simple and Stupid，更没有给出特别明确的方法论，来指导如何开发代码。因此，看着简单，但不能落地。

你需要弄清的东西
* 代码行数越少越简单吗？并不是，还要考虑逻辑复杂度、实现难度、代码的可读性等
* 代码逻辑复杂就违背 KISS 原则吗？本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则

通常谈到 KISS 原则，你可能会说，你的方法不简单，但是效率更高，那么要如何权衡呢？答案就是避免过度优化，除非对应代码是影响系统性能的瓶颈。否则这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性、性能的提升却并不明显

如何写出满足 KISS 原则的代码
* 不要使用同事可能不懂的技术来实现代码。比如高级语法、正则等
* 不要重复造轮子，要善于使用已有的工具类库
* 不要过度优化，不要过度使用一些奇技淫巧来优化代码，牺牲代码的可读性

YAGNI 原则：全称 You Ain't Gonna Need It. 直译过来就是：你不会需要它。不要去设计当前用不到的功能，不要去编写当前用不到的代码。实际上这条原则的核心思想就是：不要做过度设计。

> 注意：YAGNI 原则并不意味着我们不需要考虑代码的扩展性

KISS 原则讲的是如何做的问题（尽量保持简单），而 YAGNI 原则说的是要不要做的问题（当前不需要的就不要做）

## DRY 原则
DRY 原则：Don't Repeat Yourself. 应用在编程中，可以理解为：不要写重复的代码

只要两段代码长的一样，就违背 DRY 原则吗？实际上，重复的代码不一定违反 DRY 原则，而且有些看似不重复的代码也有可能违反 DRY 原则。

三种典型代码的重复情况，这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了
* 实现逻辑重复：对于实现逻辑重复，但语义不重复的代码是不违背 DRY 原则的。语义不重复指的是从功能上来看，这两个函数干的是完全不重复的两件事。对于包含重复代码的问题，可以通过**抽象成更细粒度函数的方式来解决**
* 功能语义重复：尽管函数命名不同，实现逻辑不同，但功能是相同。这是违背 DRY 原则的，而且危害很大
  * 危害1：给其他同事增加困惑，以为是不是有更高深的考量
  * 危害2：迭代的时候，忘记或根本不知道有多个需要修改
* 代码执行重复：一个执行周期，一段代码会被执行多次，违背 DRY 原则

代码复用、代码复用性和 DRY 原则
* 代码复用：表示一种行为，开发新功能的时候，尽量复用已经存在的代码
* 代码复用性：表示一段代码可被复用的特性或能力，编写代码的时候，让代码尽量可复用
* DRY 原则：不要写重复代码

> 目的是类似，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少

怎么提高代码复用性
* 减少代码耦合
* 满足单一职责原则
* 模块化：模块、类、函数，善于将功能独立的代码，封装成模块
* 业务与非业务逻辑分离
  * 越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难服用
  * 分离出非业务代码，抽取成一些通用的框架。类库、组件
* 通用代码下沉
  * 越底层的代码越通用、会被越多模块调用、越应该设计得足够可复用
  * 代码分层后，为避免交叉调用，只允许上层代码调用下层及同层代码之间的调用，杜绝下层代码调用上层代码
* 继承、多态、抽象、封装
  * 继承复用父类属性和方法
  * 多态可以动态的替换一段代码的部分逻辑，让这段代码更容易复用
  * 越抽象、越不依赖具体的实现，越容易复用
  * 代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用
* 应用模板等设计模式
* 泛型编程
* 复用意识
  * 思考这部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用
  * 在设计每个模块、类、函数的时候，要像设计一个外部 API 那样，去思考它的复用性

Rule Of Three：第一次编写代码的时候，不考虑复用性；第二次遇到复用场景的时候，在进行重构使其复用

## LOD 原则
迪米特法则，利用这个原则，能够帮我们实现代码的『高内聚、松耦合』

何为高内聚、松耦合
* 重要的设计思想，能够有效的提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。很多原则都以实现代码的高内聚、松耦合为目的，比如单一职责原则、基于接口而非实现编程
* 比较通用的设计思想，用来指导不同粒度代码的设计与开发，比如系统、模块、类、甚至是函数
* 高内聚用来指导类本身的设计，松耦合用来直到类与类之间依赖关系的设计。两者并非完全独立不相干。高内聚有助于松耦合、松耦合又需要高内聚

什么是高内聚呢
* 相近的功能应该放在同一个类中，不相近的功能不要放在同一个类中
* 相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护
* 单一职责原则是实现代码高内聚非常有效的设计原则

什么是松耦合呢
* 类与类之间的依赖关系简单清晰
* 即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动
* 依赖注入、接口隔离、基于接口而非实现编程以及迪米特法则，都是为了实现代码的松耦合

类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样的类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作即可。

迪米特法则，英文 Law of Demeter，缩写是 LOD。它还有个更加达意的名字，叫做最小知识原则，英文翻译为：The Least Knowledge Principle。

> 每个模块只应该了解那些与它关系密切的模块的有限知识。或者说，每个模块只和自己的朋友说话，不和陌生人说话。

更加实际的定义可以为：不该有直接依赖关系的类之间，不要有依赖。有依赖关系的类之间，尽量只依赖必要的接口，也就是定义中的有限知识

迪米特法则目的：较少类与类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。

前半部分实战，先看如下例子
```java
public class NetworkTransporter {
  public Byte[] send(HtmlRequest htmlRequest){
    // ...
  }
}

public class HtmlDownload {
  private NetworkTransporter transporter;

  public Html downloadHtml(String utl) {
    Byte[] rawHtml = transporter.send(new HtmlRequest(url));
    return new Html(rawHtml)
  }
}

public class Document {
  private Html html;
  private String url;

  public Document(String url) {
    this.url = url;
    HtmlDownloader downloader = new HtmlDownload();
    this.html = downloader.downloadHtml(url);
  }
}
```

存在的问题如下
* NetworkTransporter 作为底层网络通信类，功能应该尽可能通用，而不只是服务于下载 HTML，所以不应该直接依赖太具体的发送对象。违背迪米特法则，依赖了不该有直接依赖关系的类
  * 比喻：去商店买东西，不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来给收银员。这里的 HtmlRequest 就像是钱包，address 和 content 就相当于钱
* Document 类存在的问题
  * 构造函数中 downloader.downloadHtml 逻辑复杂，耗时长，不应该放在构造函数中，会影响代码的可测试性
  * HtmlDownload 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程
  * 业务含义来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。

针对上述问题，优化后如下，自己细品
```java
public class NetworkTransporter {
  public Byte[] send(String address, Byte[] data){
    // ...
  }
}

public class HtmlDownload {
  private NetworkTransporter transporter;

  public Html downloadHtml(String url) {
    HtmlRequest htmlRequest = new HtmlRequest(url)
    Byte[] rawHtml = transporter.send(htmlRequest.getAddress(), htmlRequest.getContent().getBytes());
    return new Html(rawHtml)
  }
}

public class Document {
  private Html html;
  private String url;

  public Document(String url, Html html) {
    this.url = url;
    this.html = this.html;
  }
}

public class DocumentFactory {
  private HtmlDownloader downloader;

  public DocumentFactory(HtmlDownloader downloader) {
    this.downloader = downloader
  }

  public Document createDocument(String url) {
    Html html = downloader.download(url);
    return new Document(url, html)
  }
}
```

后半部分：有依赖关系的类之间，尽量只依赖必要的接口，看如下例子
```java
public class Serialization {
  public String serialize() {
    // ...
  }
  public String deserialize() {
    // ...
  }
}
```

如果项目中，有些类只用到了序列化操作，另一些类只用到了反序列化操作。这样一看上面这个类就违背了迪米特原则。

根据这个思路，我们应该将 Serialization 拆分为两个更小粒度的类，一个只负责序列化的 Serializer 类，一个只负责 Deserializer 类。尽管**拆分后代码更能满足迪米特原则，但却违背了高内聚原则**，上述例子，如果我们要求序列化方式从 JSON 改成 XML，那序列化的逻辑也需要更改。未拆分时，我们只需要修改一个类即可，拆分后需要修改两个类。

那有没有我都要的方法呢，**这里非常聪明**，通过引入两个接口解决
```java
public interface Serializable {
  String serialize(Object object);
}
public interface Deserializable {
  Object deserialize(String text);
}

public class Serialization implements Serializable, Deserializable {
  public String serialize() {
    // ...
  }
  public String deserialize() {
    // ...
  }
}

public class DemoClass_1 {
  private Serializable serializer;

  public Demo(Serializable serializer) {
    this.serializer = serializer
  }
}
```

这样一来就符合了依赖有限接口的要求