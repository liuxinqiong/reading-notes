## 单例模式
单例设计模式：一个类只允许创建一个对象

为什么要使用单例
* 处理资源访问冲突
  * 场景 1：多线程环境下，如果两个线程同时给同一个共享变量加 1，因为共享变量是竞争资源，所以共享变量最后的结果有可能并不是加了 2，而是只加了 1
  * 场景 2：比如同时给文件进行写入，可能会导致内容被覆盖。你可能会说通过 synchronized 加锁即可。但如果只是加对象级别的锁，如果是多个对象，还是解决不了数据互相覆盖的问题
  * 把对象级别的锁，换成类级别的锁就可以了，让所有的对象都共享同一把锁
  * 扩展：FileWriter 本身就是线程安全的，内部实现中本身就加了对象级别的锁
  * 使用单例模式，就可以不使用类级别锁了，加上 FileWriter 本身是线程安全的，简直完美，同时相比使用类级别锁的好处是
    * 不用创建那么多 Logger 对象，节省内存
    * 节省系统文件句柄
* 表示全局唯一类
  * 配置信息类
  * 唯一递增 ID 号码生成器
  * 连接池类


对象级别锁和类级别锁使用例子
```java
public class Logger {
    private FileWriter write;

    public Logger() {
        File file = new File('/users/log.txt');
        write = new FileWriter(file, true); // true 表示追加写入
    }

    public void log(String message) {
        // 对象级别
        synchronized(this) {
            write.write(message);
        }
        // 类级别
        synchronized(Logger.class) {
            write.write(message);
        }
    }
}
```

要实现一个单例，需要关注的点
* 构造函数需要 private 访问权限，避免外部通过 new 创建实例
* 考虑对象创建时的线程安全问题
* 考虑是否支持延迟加载
* 考虑 getInstance() 性能是否高（是否加锁）

单例创建方式
* 饿汉式：在类加载的时候，instance 静态实例就已经创建并初始化，因此 instance 实例的创建过程是线程安全的，不支持延迟加载
  * 有些观点：占用资源多，初始化时间长，提前初始化实例是一种浪费资源的行为，最好的方法应该在用到的时候再去初始化
  * 反驳方：如果初始化耗时长，那最好不要等到真正用它的时候，才去执行这个耗时长的初始化过程，这回影响系统的性能。饿汉式将耗时的初始化操作，提高到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题
  * 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），也希望在程序启动时就将实例初始化好。如果资源不够，在程序启动的时候触发报错，就可以立即去修复
* 懒汉式：支持延迟加载。缺点也很明显，会有线程安全问题，因此 getInstance() 需要加一个锁，导致这个函数的并发度很低
* 双重检测：饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发，可以优化一下
  * 只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中
  * 上述方式在低版本 JDK 中可能存在问题，因为**指令重排序**，对象被 new 出来之后，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码），就被另一个线程使用了
  * 解决上述问题，需要给 instance 成员变量加上 `volatile` 关键字，禁止指令重排序即可。实际上高版本 Java 已经在 JDK 内部实现中解决了这个问题（把对象 new 操作和初始化操作设计为原子操作，自然就能禁止重排序）
* 静态内部类：类似饿汉式，又能延迟加载

静态内部类
```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    private IdGenerator() {}

    private static class SingletonHolder {
        private static final IdGenerator instance = new IdGenerator();
    }

    public static IdGenerator getInstance() {
        // 只有当首次访问时才会初始化 SingletonHolder
        return SingletonHolder.instance;
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```


单例存在哪些问题
* 对 OOP 特性的支持不友好，对抽象、继承、多态都支持的不好
  * 违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性
* 单例会隐藏类之间的依赖关系
  * 通过构造函数、参数传递等方式声明的类之间的依赖关系，通过查看函数的定义很容易识别处理
  * 单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用即可
* 单例对代码的扩展性不友好
* 单例对代码的可测试性不友好
  * 单例类这种硬编码式的使用方式，导致无法实现 mock 替换
  * 如果单例类只有成员变量，那实际上相当于一种全局变量，被所有的代码共享。如果全局变量是一个可变的全局变量，编写测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题
* 单例不支持有参数的构造函数
  * 办法一：先调用 init 函数传递参数，在获取 instance 实例
  * 办法二：将参数放到 getInstance 中
  * 办法三：将参数放到另外一个全局变量中，比如 Config 中，**推荐做法**

有何替代的解决方案
* 使用静态方法，但并不能解决单例存在的问题，而且更加不灵活，无法延迟加载
* 使用新的使用方式（依赖注入）：将单例生成的对象，作为参数传递给函数，也可以通过构造函数传递给类的成员变量，可以解决单例存在的其他问题
* 工厂模式
* IOC 容器
* 程序员自己保证

> 有人把单例当做反模式，主张杜绝在项目中使用，其实模式没有对错，关键看你怎么用。如果单例类没有后续扩展需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便

如何理解单例模式中的唯一性
* 进程内只允许创建一个对象

如何实现线程唯一的单例
* 通过 HashMap 来存储对象，key 是线程 ID，value 是对象
* Java 语言提供了 ThreadLocal 工具类，可以更加轻松的实现线程唯一单例
* Thread.currentThread().getId()
* instances.putIfAbsent(id, new IdGenerator())

如何实现集群环境下的单例
1. 把这个单例对象序列化并存出到外部共享存储区（比如文件）
2. 进程在使用这个单例的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后在使用
3. 使用完后，还需要在存储回外部共享存储区
4. 为保证任何时刻，进程间都只有一份对象存在，一个进程在获取到对象后，需要对对象加锁，避免其他进程再将其获取。进程使用完之后，还需要显示的将对象从内存中删除，并且释放对象的加锁

如何实现一个多例模式
* 一个类可以创建多次，但个数是有限制的，比如只能创建 3 个对象
* 另一种理解：同一类型的只能创建一个对象，不同类型的可以创建多个对象

> 这种多例模式的理解方式有点类似工厂模式，和工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象