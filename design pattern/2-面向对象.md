## 到底什么是面向对象
两个非常重要、非常基础的概念：类和对象

面向对象编程是一个编程范式或者编程风格，以类或对象为组织代码的基本单元，并将封装、抽象、继承、多态四个特点，作为代码设计和实现的基石。

只要某种编程语言支持类或对象的语法概念，并且依此作为组织代码的基本单元，那就可以被粗略的认为它就是面向对象编程语言了。

> 面向对象分析、面向对象设计、面向对象编程

分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类和类之间如何交互等

## 四大特性可以解决哪些问题
封装
* 信息隐藏或者数据访问保护
* 类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息
* 语法机制支持：private、public、protected
* 如果不限制，虽然更加灵活，但过度灵活意味着不可控，属性可以被随意以各种奇葩的方式修改，修改逻辑散落在代码的各个角落，势必影响代码的可读性、可维护性
* 通过有限的方法暴露必要的操作，也能提高类的易用性，只暴露少许的几个必要方法给调用者，调用者就不需要了解太多背后的细节，出错的概率就减少很多

抽象
* 如何隐藏方法的具体实现，让调用者喜欢只需要关心提供了哪些功能，并不需要知道这些功能是如何实现的
* 语法机制支持：接口类、抽象类
* 解决的问题：人类能承受的信息复杂程度是有限的，所以必须忽略屌一些非关键性的实现细节，抽象就是帮助我们大脑过滤掉许多非必要的信息
* 提高代码的可扩展性、维护性，修改实现不需要改变定义
* 设计原则都提现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则、代码解耦
* 命名类的方法的时候，也要有抽象思维，不要在方法中保留太多实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候不用去修改其定义

继承
* 表示类之间的 is-a 关系
* 最大的好处就是代码复用，同时非常符合人类的认知
* 过度使用继承，会导致层次过深过于复杂，就会导致代码可读性、可维护性变差
* 多用组合少用继承

多态
* 子类可以替换父类，在实际的运行代码过程中，调用子类的实现
* 语法机制支持
  * 父类对象可以引用子类对象
  * 支持继承
  * 子类可以重写父类中的方法
* 其他方式
  * 接口类语法
  * duck-typing 动态语言：只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系
* 提高代码的可扩展性和复用性
  * 只需要实现对应接口或继承类就可以实现扩展
  * 同一个函数，可以满足多重不同的实现，显然提高的代码的可复用性
* 相关设计模式的基础：策略模式、基于接口而非实现、依赖倒置原则、里氏替换原则，利用多态去掉冗长的 if-else

> duck-typing 是动态语言独有的，对于 Java 静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口

## 面向对象 vs 面向过程
面向过程编程也是一种编程范式，它以过程（方法、函数）作为组织代码的基本单元，以数据（成员变量、属性）与方法相分离为主要特点，面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。最大的特点是不支持类和对象两个渔业法概念，不支持丰富的面向对象编程特性（继承、多态、封装）

最基本的区别就是代码的组织方式不同
* 面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的
* 面向对象的代码被组织成一个类，方法和数据结构被绑定在一起，定义在类中

面向对象编程有哪些优势
* OOP 更加能应对大规模复杂程序的开发
  * 面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系
  * 提供了一种更加清晰、更加模块化的代码组织方式
* OOP 风格的代码更易复用、易扩展、易维护
  * 四大特性能方便我们写出更易复用、易扩展、易维护的代码
  * OOP 通过类这种组织代码方式，将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会将面向过程哪些可以被任意方法随意修改，因此更利于提高维护性
  * OOP 提供基于接口实现的抽象，可以让我们不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性
  * 继承提高了代码的复用性
  * 多态：修改功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改，遵循了对修改关闭，对扩展开放的设计原则，提高了代码的扩展性。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性
* OOP 更加人性化、更加高级、更加智能
  * 二进制指令、汇编、面向过程编程的语言相比，面向对象编程语言的编程套路，思考问题的方式，是完全不一样的，前三者是计算机的思维方式，面向对象是一种人的思维方式
  * 前三者的思考：如何设计一组指令，告诉机器去执行，操作某些数据，完成某个任务
  * 面向对象思考：如何给业务建模，如何将真实的世界映射为类或者对象，更能聚焦到业务本身，而不是考虑如何与机器打交道

哪些设计看似面向对象，实际面向过程的
* 滥用 getter、setter 方法
  * 暴露不应该暴露的 setter 方法，违背了面向对象编程的封装特性
  * 需要注意对于引用类型，即使没有提供 setter 方法，通过 getter 拿到值后，也是可以修改值，这对于不同的语言有不同的解决方案了，比如 Java 中的 Collections.unmodifiableList() 方法
  * 定义好属性的访问权限，可以反向的帮助你更好的抽象方法，因为外部拿不到属性，也就不会写出太多不合适的过程式代码了
  * 总结：设计类的时候，除非真的需要，否则尽量不要给属性定义 setter 方法。尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防范集合内部数据被修改的危险
* 滥用全局变量和全局方法
  * 常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法，一般用来操作静态变量或外部数据，比如各种 Utils 类和 Constants 类
  * 静态方法将方法和数据分离，破坏了封装特性，是典型的面向过程风格
  * 过大的 Constants 类存在的问题：影响可维护性（查找变量费时，提交代码易冲突）、增加代码编译时间、影响可复用性（场景：只需要 Constants 的一小部分）
  * 拆分Constants 类：功能更加单一的多个类。或者并不单独设计 Constants 常量类，那个类用到某个常量，就把常量定义到这个类中，提高类内聚性和可维护性
  * Utils 出现的背景：两个类 A 和 B，需要吊用到一块相同的功能逻辑，为了避免代码重复。当然继承可以实现代码，但有时候从业务含义上，其不存在继承关系（非父子，非兄弟），这时候就可以定义 Utils 类了
  * 只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格，但从 Utils 类存在的目的来看，他在软件开发中还是很有用的，能解决代码复用的问题，因此并不是完全不用，而是尽量避免滥用，不加思考的随意去定义 Utils 类
  * 在定义 Utils 类之前，你要为自己，真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类的某些方法定义在其他类中？如果回答完这些问题后，还是觉得有必要去定义，那就大胆定义它吧
  * 类比 Constants 类，设计 Utils 时，最好也能细化一下，比如 FileUtils、IOUtils、StringUtils、UrlUtils 等。切记不要大而全
* 定义数据和方法分离的类
  * MVC 开发中很常见，通常 MVC 分为 Model 层、Controller 层、View 层。前端后分析后有所调整，被分为 Controller 层（暴露接口）、Service 层（核心业务逻辑）和 Repository 层（数据是写）。每一层中都会定义相应的 VO(View Object)、BO(Business Object)、Entity，一般而言，这三者只会定义数据，不会定义方法，所有的操作都定义在 Controller、Service、Repository 中，典型的面向对象风格。这种开发模式叫做基于贫血模型的开发模式，也是非常常用的 Web 开发模式

为什么面向对象编程中，容易写出面向过程风格的代码
* 面向过程编程风格符合人的流程化思维方式，而面向对象编程风格是一种自底向上的思考方式，不是按照流程来分解任务，而是将任务翻译成一个一个小的模块（类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务，比较适合复杂程序的开发，但并不是特别符合人类的思考方式
* 面向对象比面向过程要难一些，需要思考如何封装何时的数据和方法到一个类中，如何设计类之间的关系，如何设计类之间的交互等诸多设计问题

面向过程无用武之地？
* 微小程序，或者数据处理相关的代码，算法为主，数据为辅，那么面向过程更合适一些
* 面向对象和面向过程两种编程风格，不是非黑即白，完全对立的

> 不管使用哪种风格，最终目的还是写出易维护、易读、易复用、易扩展的高质量代码，只要控制好面向过程的一些弊端和副作用，在掌控范围内为我们所用

## 接口 VS 抽象类
在面向对象编程中，抽象类和接口是两个经常被用到的语法，是面向对象的四大特性，以及很多设计模式、设计思想、设计原则编程实现的基础。

比如可以使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则，使用抽象类来实现面向对象的继承特性和模板设计模式等。

什么是抽象类和接口，区别在哪里？
* 抽象类 demo，可以理解 Logger 与 FileLogger 和 MessageQueueLogger 关系
* 抽象类特点：
  * 不允许被实例化，是能被继承
  * 可以包含属性和方法，方法即可以包含代码实现，也可以不包含代码实现
  * 子类必须继承抽象类，必须实现抽象类中的所有抽象方法
* 接口 demo：Filter 与 AuthenticationFilter 和 RateLimitFilter 关系
* 接口特点：
  * 不能包含属性
  * 只能声明方法，方法不能包含代码实现
  * 类实现接口的时候，必须实现接口中声明的所有方法

> 抽象类 is-a 关系，接口 has-a 关系，表示具有哪些功能，对于接口，有一个更加形象的叫法，就是协议

抽象类和接口存在的意义
* 抽象类也是为了代码复用而生，避免在子类中，重复编写相同的代码，那和类有啥区别呢？
  * 场景：抽象类场景更特殊，其本身不具备某个能力，因此只能声明抽象方法，交给子类去实现，如果不实用抽象类，比如 Logger 类，由于自身没法书写逻辑，因此没有 log 函数声明，则无法使用多态的特性了
  * 你可能会说，可以在父类中定一个一个空个 log 函数，方法可行，但没有抽象类优雅，具体原因如下
  * 定义空的方法，会影响代码的可读性
  * 创建新的子类继承父类时，有可能会忘记重新实现 log 方法，而抽象类的设计思路，编译器会要求强制重写
  * Logger 可以被实例化，会增加类被误用的风险，比如 new 一个 Logger 出现，并且调用了空的 log 方法
* 接口的侧重点在于解耦，接口是对行为的一种抽象，相当于一组协议或者契约
  * 实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性
  * 基于接口而非实现编程，能极大提高代码的灵活性、扩展性

如何决定使用抽象类还是接口
* 表示一种 is-a 的关系，并且是为了解决代码复用的问题，就用抽象类
* 如果要表示一种 has-a 关系，并且是为了解决抽象而且代码复用问题，那就可以使用接口
* 抽象类是一种自下而上的设计思路，现有子类的代码重复，然后再抽象成上层的父类
* 接口正好相反，是一种自上而下的设计思路，一般都是先设计接口，再去考虑具体的实现

## 为什么基于接口而非实现
接口是一组协议或者约定，是功能提供者提供给使用者的一个功能列表。

这条原则能非常有效的提高代码质量，因为应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合行，提高扩展性。

> 在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计，就越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

遵循基于接口而非实现编程，比如做到下面 3 点
* 函数命名不能暴露任何实现细节
* 封装具体的实现细节（不能暴露给调用者去实现）
* 为实现类定义抽象的接口，具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议，使用者依赖接口，而不是具体的实现类来编程

很多人在定义接口的时候，希望通过实现类来反推接口的定义。先把实现类写好，然后看实现类中有哪些方法，照抄到接口定义中。如果按照这种思考方式，就有可能导致接口定义不够抽象，依赖具体的实现。这样接口的设计就没有意义了。

> 软件开发的时候，一定要有抽象意识、封装意识、接口意识。定义接口的时候，不要暴露任何实现细节。接口的定义只表明做什么，而不是怎么做。在设计接口的时候，要多思考。这样的设计是否足够通用，是否能够做到在替换具体接口实现的时候，不需要任何接口定义的改变

是否需要为每个类定义接口
* 任何事情都讲求一个度，接口满天飞，也会导致不必要的开发负担
* 理解设计初衷：将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样放发生变化的时候，上游系统的代码基本上不需要做改动，依次来降低代码间耦合性，提高代码扩展性
* 如果业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，就没必要为其设计接口
* 此外，越是不稳定的系统，越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，开发完成后，基本不需要做维护，也就没必要为其扩展性，投入不必要的时间

## 多用组合少用继承
为什么不推荐使用继承
* 继承层次过深、过于复杂，也会影响到代码的可维护性
* 有些场景使用继承并不合适，强行使用会导致层次过多，继承关系复杂

> 最少知识原则：暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率

可以使用组合（composition）、接口、委托（delegation）三个技术手段，一块儿来解决继承存在的问题
* 定义多个接口的方法，解决鸟（会飞、会叫、会下蛋）等行为特性
* 如果直接实现对应的接口，因为接口只声明，不实现，那么每个下蛋的鸟都要实现一遍 layEgg 方法，并且逻辑是一样的，也就没法复用的。这里需要用到组合和委托来消除重复代码
* 每个接口定一个实现类，具有该能力的类直接持有该实现类实例（组合），然后调用实现类方法（委托）

继承有三个作用：表示 is-a 关系，支持多态特性、代码复用，这三个作用都可以通过其他技术手段来达成
* is-a 关系可以用过组合和接口的 has-a 关系来代替
* 多态特性可以利用接口来实现
* 代码复用可以通过组合和委托来实现

> 从理论上讲，通过组合、接口、委托三个技术手段，完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系

组合也并非完美
* 继承改写成组合意味着要做更细粒度的类的拆分，意味着要定义更多的类和接口
* 类和接口的增多也就或多或少地增加代码的复杂程度和维护成本

如果类之间的继承结构稳定，继承层次比较浅（比如最多两层继承），继承关系不复杂，就可以大胆使用继承。反之越不稳定，继承层次很深，继承关系复杂，就尽量使用组合来替代继承

设计模式使用情况
* 装饰者模式、策略模式、组合模式等多使用了组合关系
* 模板模式使用了继承关系

同时，如果 A 类和 B 类并不一定具有继承关系（非父子，非兄弟），为了代码复用，生硬的抽象出一个父类来，会影响代码的可读性，这个时候，使用组合就更加合理、更加灵活

有些特殊场景又只能使用继承：比如你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现

## 贫血模型 vs 充血模型
目前标准的 Web 项目开发模式，是基于贫血模型的 MVC 三层架构开发模式，但它却违反了面向对象编程风格，是彻彻底底的面向过程的编程风格。

领域驱动设计（Domain Driven Design，监测 DDD）盛行后，基于贫血模型的开发模式被人诟病，而基于充血模型的 DDD 开发模式开始越来越被人提倡。

什么是基于贫血模型的传统开发模式
* 统一一下 MVC 的认识：Model -> View -> Controller，前后端分离后，很多发展为 Repository（数据访问） -> Service（业务逻辑） -> Controller（暴露接口）。
* 三层结构的配套分别为：XXXEntity、XXXBo、XXXVo
* 其中贫血模式指的就是 XXXEntity、XXXBo、XXXVo 中只包含数据，不包含业务逻辑的类
* 这种贫血模型将数据和操作分离，破坏了面向对象的封装特性

什么是基于充血模型的 DDD 开发模式
* 贫血模型中，数据和业务逻辑被分割到不同的类中。充血模型正好相反，数据和对应的业务逻辑被封装到同一个类中。因此充血模型满足面向对象封装特性。
* DDD：主要用来知道如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。值得一提的是，微服务加速了领域驱动设计的盛行
* 做好领域驱动设计的关键是，看你对自己所做的业务的熟悉程度，而不是对这个概念本身的掌握程度
* 基于充血模型的开发模式也是按照 MVC 架构封层的，跟基于贫血模型的传统开发模式的区别主要在 Service 层
  * 贫血模型：BO 只包含数据，不包含具体的业务逻辑，业务逻辑在 Service 层
  * 充血模型：Service 包含 Service 类和 Domain 类。Domain 相当于贫血模型中的 BO，区别在于既包含数据，也包含业务逻辑，Service 变得非常单薄

> 贫血模型：重 Service 轻 BO，充血模型：轻 Service 重 Domain

为什么贫血模型会流行呢
* 大部分情况下， 系统业务可能都比较简单
* 充血模型的设计要比贫血模型更加有难度
  * 充血是面向对象风格，一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑
  * 贫血只需要定义好数据，之后开发需求，就在 Service 中定义什么操作，不需要做太多设计
* 思维固化。转型有成本

什么项目应该考虑 DDD 开发模式呢：更适合业务复杂的系统开发，比如金融系统

为什么贫血模型就不能应对复杂业务系统呢，除了代码层面的差别之外，还有一个重要的区别，这两种不同的开发模式会导致不同的开发流程，DDD 开发模式的开发流程应对复杂业务是更有优势
* 平时开发大部分都是 SQL 驱动开发，业务逻辑包裹在一个大的 SQL 中，而 Service 层可以做的事情很好，SQL 都是针对特定的业务功能编写的，复用性差，最终会导致各种长的差不多，区别很小的 SQL 语句满天飞，这个过程中，很少有人会应用领域模型，OOP 的概念，也很少有代码复用意识
* 充血模型中开发流程完全不一样，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层，新功能需求的开发，都基于之前定义好的领域模型来完成

> 越复杂的系统，对代码的复用性、易维护性要求就越高，就越应该花更多的时间和精力在前期设计上。基于充血模型的 DDD 开发模式，正好需要我们前期做大量的业务调研、领域模型设计，所以更适合复杂系统的开发

## 如何面向对象分析、设计与编程
如果对于
* 如何做需求分析
* 如何做职责划分
* 需要定义那些类
* 每个类有哪些熟悉感、方法
* 类与类之间如何交互
* 如何组装成一个可执行程序

以上等问题都没有清晰的思路，更别提利用成熟的设计原则、思想或者设计模式，开发出具有高内聚低耦合、易扩展、易读等优秀的代码了

对于一个笼统的需求，可能会有无从下手的感觉，主要原因如下
1. 需求不明确
  * 细化到足够清晰、可执行
  * 沟通、挖掘、分析、假设、梳理
  * 具体需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的
2. 缺少通用框架开发的锻炼

具体思考路径，鉴权系统案例
* 首先：非业务系统的开发一定要有组件化意识、框架意识、抽象意识，足够通用，而不局限于单一某个业务需求
* 基础分析：最简单的解决方案，通过用户名 + 密码做认证，允许访问的应用派发一个 AppID 和对应的密钥，每次调用都需要传递过来
* 分析优化1：分析存在的问题，在解决问题
  * 问题：明文传输密码，很容易被截获。简单对密码进行加密并不能解决问题，因为重放攻击依旧存在
  * 解决问题：将请求接口的 URL 跟 AppID 密码拼接在一起，然后进行加密作为 token。调用方在进行请求的时候需要传递 token 和 AppID。微服务端接收到数据后，取出对应的密码，并通过同样的 token 生成算法，生成另外一个 token，用这个新生成的 token 跟调用方传递过来的 token 进行比较，一致则通过
* 分析优化2
  * 问题：由于 token 都是固定的，依旧存在重放攻击问题
  * 解决问题：引入一个随机变量，让每次接口请求生成的 token 都不一样，比如使用 URL、AppID、密码、时间戳四者进行加密生成 token，调用方需要将 token、AppID、时间戳随 URL 一并传递给微服务端。服务端接受到数据后，验证房钱时间戳和传递过来的时间戳是否在一定的时间窗口内（比如一分钟），如果超过一分钟，认定为 token 过期。如果没有过期，在通过同样的 token 生成算法，在服务端生成新的 token 与调用方 token 进行比较，看是否一致。
* 分析优化3：
  * 问题：攻击者还是可以在一分钟 token 失效窗口内，通过截获请求、重放请求来调用我们的接口
  * 解决：攻与防之间，本来就没有绝对的安全，能做的是尽量提高攻击的成本
* 分析优化4
  * 如何存储调用方的 AppID 和密码呢，你可能会说存储在数据库中，但非业务系统最好不要与具体的第三方系统有过度的耦合
  * 最好能灵活的支持各种不同的存储方式，比如配置文件、数据库、redis 等。不一定针对每种方式都要做代码实现，但起码要留有扩展点，保证系统有足够的灵活性和扩展性，能够在我们切换存储方式的时候，尽可能地减少代码的改动

> 需求分析的过程实际上是一个不断迭代优化的过程，我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后在慢慢优化

面向对象分析的产出是详细的需求描述，面向对象分析产出就是类
* 划分之策进而识别出有那些类
  * 把需求描述中的名词罗列出来，作为可能的候选类，然后进行筛选
  * 把功能点一个个罗列出来，然后看哪些功能点职责相近，操作同样的属性，可否应该归为一个类。拆解出来的功能点要尽可能小，每个功能点只负责做一件很小的事情（单一职责）
* 定义类与类及其属性和方法
  * 需求描述中的动词作为候选的方法，再进一步过滤筛选
  * 需求描述中的名词作为候选的属性，再进一步过滤筛选
* 定义类与类之间的交互关系
  * UML 统一建模语言定义了六中类之间的关系，分别是`泛化、实现、关联、聚合、组合、依赖`
  * 泛化可以简单理解为继承
  * 实现一般指接口和实现类关系
  * 聚合：包含关系，A 包含 B，但 B 类对象的生命周期不依赖 A 类对象的生命周期
  * 组合：包含关系，A 包含 B，B 类对象的生命周期依赖 A 类对象的生命周期
  * 关联：一种非常弱的关系，包含聚合和组合
  * 依赖：比关联更加弱的关系，包含关联关系，不管 B 是 A 的成员变量，还是 A 类方法使用 B 作为参数或返回值、局部变量
* 将类组装起来并提供执行入口

聚合、组合、依赖可能有点难以理解，直接看代码就知道了
```java
// 聚合
public class A {
  private B b;
  public A(B b) {
    this.b = b
  }
}
// 组合
public class A {
  private B b;
  public A() {
    this.b = new B()
  }
}
// 包含上述，还包括如下
public class A {
  public void func(B b) {}
}
```