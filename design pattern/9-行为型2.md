## 迭代器模式
迭代器模式，也叫做游标模式，用来遍历集合对象，比如数组、链表、树、图、跳表。迭代器模式将集合对象的遍历对象操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一。

一个完整的迭代器模式，一般会涉及容器和容器迭代器两部分内容。

Iterator 接口两种方式示例
```java
public interface Iterator<E> {
    boolean hasNext();
    void next(); // 游标后移一位
    E currentItem(); // 返回当前元素
}

public interface Iterator<E> {
    boolean hasNext();
    E next(); // 返回当前元素与后移移位放在同一个函数中完成
}
```

具体实现举例
```java
public class ArrayIterator<E> implements Iterator<E> {
    private int cursor;
    private ArrayList<E> arrayList;

    public ArrayIterator(ArrayList<E> arrayList) {
        this.cursor = 0;
        this.arrayList = arrayList;
    }

    public boolean hasNext() {
        return cursor != arrayList.size();
    }

    public void next() {
        cursor++;
    }

    public E currentItem() {
        if (cursor >= arrayList.size()) {
            throw new NoSuchElementException();
        }
        return arrayList.get(cursor);
    }
}
```

在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，为了封装迭代器的创建细节，可以在容器中定义一个 iterator 方法，来创建对应的迭代器。
```java
public class ArrayList<E> implements List<E> {
    public Iterator iterator() {
        return new ArrayIterator(this);
    }
}
```

遍历集合数据，通常有三种方式：for 循环、foreach 循环、iterator 迭代器，实际上 foreach 循环只是一个语法糖，底层是基于迭代器来实现的。哪迭代器模式有什么优势呢？
* 对于类似数组和链表这种线性的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就够了。但对于复杂数据结构，比如树、图来说，有各种复杂的遍历方式。如果由客户端代码来实现，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性
* 将游标指向当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响
* 容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。如果需要切换新的遍历算法时，只需要修改迭代器类即可
* 添加新的遍历算法，只需要扩展新的迭代器类，也更符合开闭原则

迭代器模式的主要作用：解耦容器代码和遍历代码。

如果在迭代器遍历集合的同时增加、删除集合中的元素，会发生什么情况？
* 增加或删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。并不是所有情况都会遍历出错，这种行为称为结果不可预期行为或者未决行为。
* 如何避免这种情况呢
  * 遍历的时候不允许增删元素：比较难实现，因为无法确定遍历结束的时间点，因为并不是遍历一定会遍历完全部元素
  * 增删元素之后让遍历报错，java 就是采用的这种方式
    1. List 定义一个成员变量 modCount 记录集合被修改的次数，每次调用增加或删除元素的函数，就给 modCount 加 1
    2. 通过 iterator 创建迭代器的时候，将 modCount 传递给迭代器的 expectedModCount 成员变量，之后每次调用迭代器函数时候，检查两者是否相等
    3. 如果不相同，说明存储的元素已经改变了，之前创建的迭代器已经不能正确运行了，采用 fail-fast 解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的 bug
* 如何安全的删除元素
  * 迭代器提供了一个 remove 方法，注意并没有提供添加元素的方法
  * 该方法也比较鸡肋，只能删除游标指向的前一个元素，而且 next 函数之后，只能跟着最多一个 remove 操作
  * 实现原理：新增一个 lastRet 成员变量，记录游标指向的前一个元素，迭代器删除这个元素的时候，更新迭代的游标和 lastRet 值，来保证不会因为删除元素而导致某个元素变量不到

LinkedList 底层基于链表，如果遍历的时候，增加删除元素，会出现哪些不可预期行为
* 增删元素不需要移动元素的位置
* 不论增加的元素在迭代器前还是后，都能通过指针寻址到下一个元素

如何实现一个支持快照功能的迭代
* 所谓快照，创建迭代器的时候，相当于给容器拍一个快照，之后即便增删元素，快照中的元素并不会做相应的改动
* 方式一：迭代器类中定义一个成员变量 snapshot 来存储快照，后续变量都基于迭代器自己的快照来进行
  * 优点：实现简单
  * 缺点：代价高，增加唉内存小号
* 方式二
  * 容器中为每个元素保存两个时间戳，一个添加时间，一个删除时间，当元素删除时，只能更新删除时间为当前时间，表示已被删除，并不是真的删除
  * 每个迭代器也保存一个迭代器的创建时间戳，遍历的时候只有满足 addTimestamp < snapshotTimestamp < delTimeStamp 元素才属于迭代器的快照
  * 缺点：由于元素没有真的删除，丢失了随机访问特性
* 方式三
  * List 存储两个数组，一个支持标记删除的，用于实现快照遍历，一个不支持标记删除的，用来支持随机访问