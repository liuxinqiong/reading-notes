## 为什么要重构
重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。

> 在保证功能不变的前提下， 利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量

为什么要重构
* 时刻保证代码质量的一个及其有效的手段，不至于让代码腐化到无可救药的地步
* 优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。无法 100% 预见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，随着系统的演进，重构代码也是不可避免的
* 重构是避免过度设计的有效手段，在维护代码的过程中，真正遇到问题的时候，在对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢
* 重构对一个工程师本身技术的成长也有重要的意义

> 初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码

到底重构什么
* 大型重构
  * 对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构
  * 重构手段：分层、模块化、解耦、抽象可复用组件、梳理类之间的交互关系
  * 重构工具：设计思想、原则和模式
* 小型重构
  * 代码系统的重构，针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、修正函数参数多过、提取重复代码等
  * 重构手段：编码规范

什么时候重构
* 不推荐：平时不注重代码质量，堆砌蓝代码，实在维护不了就大刀阔斧地重构、甚至重写的行为，希望在代码烂到一定程度之后，集中重构解决所有问题是不现实的，必须探索一条**可持续、可演进**的方式
* 推荐：持续重构
  * 平时没事的时候多看看项目中有哪些写得不够好的地方，可以优化的地方，主动去重构一下
  * 修改、添加某个功能代码的时候，顺手把不符合编码规范、不好的设计重构一下

重构能力很重要，但持续重构意识更重要
* 正确看待代码质量和重构这件事情，技术更新、需求变化、人员流动，代码质量总会下降，代码总会存在不完美，重构就会持续进行
* 时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降

如何重构
* 大型重构
  * 完善的重构计划，有条不紊的分阶段来进行
  * 每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，在继续进行下一阶段的重构，保证代码仓库一直处于可运行、逻辑正确的状态
  * 控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码
  * 只有这样才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于和新的功能开发相冲突
* 小规模：随时都可以

对于重构这件事情，资深的工程师、项目 leader 要负责起来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则一旦出现破窗效应，就会有更多的人往里堆更烂的代码

> 很多技术问题本身就不是单纯靠技术来解决的，更重要的是要有这种认知和意识

## 保证重构不出错
保证重构不出错，你需要熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。除了个人因素外，最可落地执行、最有效的保证重构不出错的手段就是**单元测试（Unit Testing）**，当重构完成后，如果新的代码仍然能够通过单元测试，就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变。

什么是单元测试
* 单元测试相对于集成测试来说，测试粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块。比如测试用户注册、登录功能是否正常，是一种端到端的测试
* 单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行
* 考验的是程序员思维的缜密程度，看能否，设计出覆盖各种正常和异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确执行

为什么要写单元测试
* 有效地为重构保驾护航，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）
* 能有效地帮你发现代码中的 bug
* 能帮你发现代码设计上的问题：如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠框架很高级的特性才能完成，往往就意味着代码设计得不够合理，比如没有使用**依赖注入、大量使用静态函数、全局变量、代码高度耦合等**
* 单元测试是对集成测试的有力补充：程序的运行往往出现在一些边界条件、异常情况下，单测可以利用 mock 的方式返回我们需要模拟的异常，来测试代码的在异常情况下的表现
* 写单元测试的过程本身就是代码重构的过程：落地持续重构的一个有效途径，编写单元测试就相当于是对代码的一次自我 Code Review，可以发现设计上的不足，以及代码编写方面的问题，比如一些边界条件处理不当等
* 阅读单元测试能帮助你快速熟悉代码
  * **阅读代码最有效的手段，就是先了解业务背景和设计思路，然后再去看代码，这样就会轻松许多**
  * 没有文档和注释的情况下，单元测试就起到了替代性作用，借助单元测试，不需要深入阅读代码，便能知道代码实现了什么功能，哪些情况需要考虑，有哪些边界情况需要处理
* 单元测试是 TDD 可落地执行的改进方案：先写代码、紧接着写单元测试，最后根据单元测试反馈出来的问题，再回过头去重构代码，这个开发流程更加容易被接受，更加容易落地执行，而且兼顾了 TDD 的优点

如何编写单元测试：**针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程**
* 写单元测试并不耗时：虽然代码里可能是被测代码的 1-2 倍，写的过程繁琐，但并不耗时，因为不需要考虑设计，测试代码实现比较简单，而且不同测试用例之间的代码差别可能并不是很大，简单 copy-paste 即可
* 代码质量的要求：质量可以稍微放低一些，比如命名不规范、代码稍微重复
* 只要覆盖率高就够了吗：将覆盖率作为唯一指标是不合理的，更重要的是要看中测试用例是否覆盖了所有可能的情况
* 写单元测试需要了解代码的实现逻辑吗：不要依赖被测试函数的具体实现逻辑，只关心被测函数实现了什么功能。不要针对实现编写单元测试，否则一旦对代码进行重构，在外部行为不变的情况下，对代码的实现进行了修改，那原本的单测都会运行失败，也就起不到为重构保驾护航的目的了

单元测试为何难落地执行
* 觉得繁琐，且没有太多挑战，而不愿意去做，没有感受到它的作用，并且打心底认可
* 刚开始比较认真，开发任务紧了之后，开始放低要求，出现破窗效应，慢慢的就都不写了
* 历史遗留问题：保证新的代码都要有单测，其次，每次在改动到某个类时，如果没有单元测试就顺便补上

## 代码的可测试性
写单元测试并不难，相反写出可测试性的代码反倒是件非常有挑战的事情

单元测试的定义：测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，它不需要测试所依赖的外部系统的逻辑正确性。

如果代码依赖了外部系统或者不可控组件，比如需要依赖数据库、网络通信、文件系统等，就需要将被测代码与外部系统解依赖，这种解依赖的办法就叫做 mock。所谓 **mock 就是用一个假服务替换真正存在的服务**

提高可测试性的手段
* 依赖注入是实现代码可测试性的最有效手段：这样就可以对内部代码随意 mock 然后替换真正的服务了
* 对于内部使用的全局变量，无法 mock 该如何解决呢？重点理解***重新封装，方便隔离**，具体看下面示例
* 更时间有关的未决行为：将这种未决行为逻辑重新封装，用的还是**二次封装**

重新封装，方便隔离
```java
public class TransactionLock {
  public boolean lock(String id) {
    return RedisDistributedLock.getSingletonIntance().lockTransction(id);
  }

  public void unlock() {
    RedisDistributedLock.getSingletonIntance().unlockTransction(id);
  }
}

public class Transaction {
  //...
  private TransactionLock lock;

  public void setTransactionLock(TransactionLock lock) {
    this.lock = lock;
  }

  public boolean execute() {
    //...
    try {
      isLocked = lock.lock();
      //...
    } finally {
      if (isLocked) {
        lock.unlock();
      }
    }
    //...
  }
}

// 这样我们就可以轻松隔离了
public void testExecute() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;

  TransactionLock mockLock = new TransactionLock() {
    public boolean lock(String id) {
      return true;
    }

    public void unlock() {}
  };

  Transaction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
  transaction.setWalletRpcService(new MockWalletRpcServiceOne());
  transaction.setTransactionLock(mockLock);
  boolean executedResult = transaction.execute();
  assertTrue(executedResult);
  assertEquals(STATUS.EXECUTED, transaction.getStatus());
}
```

和时间有关的未决行为
```java
public class Transaction {

  protected boolean isExpired() {
    long executionInvokedTimestamp = System.currentTimestamp();
    return executionInvokedTimestamp - createdTimestamp > 14days;
  }

  public boolean execute() throws InvalidTransactionException {
    //...
      if (isExpired()) {
        this.status = STATUS.EXPIRED;
        return false;
      }
    //...
  }
}

// 隔离了对于时间的使用，我们就可以方便进行函数的局部 mock 了
public void testExecute_with_TransactionIsExpired() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  Transaction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) {
    protected boolean isExpired() {
      return true;
    }
  };
  boolean actualResult = transaction.execute();
  assertFalse(actualResult);
  assertEquals(STATUS.EXPIRED, transaction.getStatus());
}
```

> 不可测试性差的代码，本身代码设计的也不够好，很多地方没有遵守设计原则和思想，比如基于接口而非实现编程、依赖反转原则等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想

其他典型的、常见的测试性不好的代码
* 未决行为：代码的输出是随机的，或者说不确定的
* 全局变量：多个测试用例之间会打架，多线程会打架很难测试
* 静态方法：难测试的原因就是不能使用 mock 技巧了，在依赖外部资源、逻辑复杂、行为未决等情况下，就难以测试，但对于纯函数，并不会影响测试性
* 复杂继承：mock 要命了，如果我们使用组合而非继承来组织类与类之间的关系，类之间的结构层次比较扁平，在编写单测时，只需要 mock 类所组合依赖的对象即可
* 高耦合代码

## 通过封装、抽象、模块化、中间层等解耦代码
解耦为何如此重要
* 人处理复杂性的能力是有限的
* 高内聚、松耦合的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们焦点不至于过于发散，降低了阅读和修改代码的难度
* 因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少很多
* 可测试性更好，容易 mock 或者很少需要 mock 外部依赖的模块或者类
* 高内聚、松耦合意味着代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，代码质量就不会差

代码是否需要解耦
* 看修改代码会不会牵一发而动全身
* 模块与模块之间、类与类之间的依赖关系图

如何给代码解耦
* 封装和抽象：有效的隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口
* 中间层
  * 引入**中间层**能简化模块或类之间的依赖关系
  * 进行重构的时候，引入中间层能够起到过渡的作用，能够让开发和重构同步进行
* 模块化
  * 划分各个独立的模块。不同的人负责不同的模块
  * 代码开发的时候，一定要有模块化意识，每个模块都当做一个独立的 lib 一样来开发，只提供封装了内部实现细节的接口给其他模块用
  * 分而治之
* 其他设计思想和原则
  * 单一职责原则
  * 基于接口而非实现编程
  * 依赖注入
  * 多用组合少用继承
  * 迪米特法则
  * 观察者模式