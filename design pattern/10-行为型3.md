这部分学习命令器模式、解释器模式和中介模式，这三个模式使用频率低、理解难度大，只有在非常特定的场景下才会用到。

## 命令模式
定义：命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能

落实到编码实现：将函数封装成对象。设计一个包含这个函数的类，实例化一个对象传来穿去，这样就可以把函数像对象一样使用。类似于回调

将函数封装成对象之后，对象可以存储下来，方便控制执行。命令模式的主要作用和应用场景，是用来控制命令的执行，比如**异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等**

实例：服务端轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中，然后再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的轮询
```java
public interface Command {
    void execute();
}

public class GotDiamondCommand implements Command {
    // 成员变量
    public GotDiamondCommand() {
        // 数据初始化
    }

    public void execute() {
        // 执行相应的逻辑
    }
}
```

> 每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪些问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现，注意：代码实现并不是模式必须包含。如果你单纯的只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。

设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯的看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式


命令模式、策略模式、工厂模式
* 策略模式包含策略的定义、创建和使用三部分，代码结构上和工厂模式类似。区别在于策略模式侧重策略或者算法这个特定的应用场景，用于解决根据运行时状态从一组策略中选择不同策略的问题
* 工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以时策略，也可以是其他东西
* 策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换
* 命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换

## 解释器模式

## 中介模式