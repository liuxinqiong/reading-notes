# 行为型
设计模式分类
* 创建型设计模式主要解决对象的创建问题
* 结构型设计模式主要解决类或对象的组合或组装
* 行为型设计模式主要的就是类或对象之间的交互问题

## 观察者模式
观察者模式也被称为发布订阅模式

定义：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。

一般情况下，被依赖的对象叫做被观察者（Observable），依赖的对象叫做观察者（Observer）

最经典的实现方式
```java
public interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObserver(Message message);
}

public interface Observer {
    void update(Message message);
}

public class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<Observer>();

    public void registerObserver(Observer observer) {
        this.observers.add(observer);
    }

    public void removeObserver(Observer observer) {
        this.observers.remove(observer);
    }

    public void notifyObserver(Message message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}
```

什么情况下会用到这种设计模式呢
* 有没有明显的 Message 信号。一个信号触发后，我们需要执行一系列操作，此时如果放在一个函数中，由于一系列操作的不断变化，会导致频繁的修改，违反开闭原则，而且如果操作过多，会导致逻辑变得越来越复杂，也就影响到代码的可读性和可维护性

> 设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。

不同的应用场景和需求下， 这个模式也有截然不同的实现方式
* 同步阻塞的实现
* 异步非阻塞实现：如果不是非必要同步，可以改成异步实现，减少响应时间
* 进程内的实现
* 跨进程的实现：RPC 接口、消息队列（解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，观察者也完全不感知被观察者）

> 借助设计模式，我们利用更好的代码结构，将一大坨大妈拆分成职责更单一的小类，让其满足开闭原则、高内聚低耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性

如何设计实现一个异步非阻塞
* 直接在 Observer 消息处理中，使用 Thread 创建新的线程：频繁的创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出
* 在 Observable 中，使用线程池执行每个 Observer 的函数：使用线程池解决了上述问题，但线程池、异步逻辑耦合在了业务中，同时也无法复用

框架的作用：隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发。

这里我们可以 EventBus 框架，支持异步和同步
* 不需要定义 Observer 接口，任意类型的对象都可以注册到 EventBus 中，通过 @Subscribe 注册来标明类中的哪个函数可以接受被观察者发送的消息
* EventBus、AsyncEventBus 同步类和异步类
* register 函数用于注册观察者
* unregister 函数用于删除某个观察者
* post 函数，用来给观察者发送消息，但进一步强化了， 并非把消息发送给所有的观察者，而是发送给可匹配的观察者。
  * 这里的可匹配通过发送消息的类型确定
  * JavaScript 通常通过 type 字符串进行区分
* @Subscribe 注解

EventBus 框架代码实现包括 5 个类
* EventBus
* AsyncEventBus
* Subscribe：注解，用于标明观察者中哪个函数可以接受信息，备注：JavaScript 直接注册函数
* ObserverAction：用于表示 @Subscribe 注解的方法，target 表示观察者类，method 表示方法
* ObserverRegister：Observer 注册表，一个有技巧的地方可以学习
  * CopyOnWriteArraySet 的使用：写入数据的时候，会创建一个新的 set，并将原始数据 clone 到新的 set 中，在新的 set 中写入数据完成之后，在用新的 set 替换老的 set，这样就能保证在写入数据的时候，不影响数据的读取操作，依次来解决读写并发问题。除此之外，还通过加锁的方式，避免了并发写冲突。