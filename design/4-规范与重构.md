## 为什么要重构
重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。

> 在保证功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量

为什么要重构
* 时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步
* 优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。无法 100% 预见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，随着系统的演进，重构代码也是不可避免的
* 重构是避免过度设计的有效手段，在维护代码的过程中，真正遇到问题的时候，在对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢
* 重构对一个工程师本身技术的成长也有重要的意义

> 初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码

到底重构什么
* 大型重构
  * 对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构
  * 重构手段：分层、模块化、解耦、抽象可复用组件、梳理类之间的交互关系
  * 重构工具：设计思想、原则和模式
* 小型重构
  * 代码系统的重构，针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、修正函数参数过多、提取重复代码等
  * 重构手段：编码规范

什么时候重构
* 不推荐：平时不注重代码质量，堆砌烂代码，实在维护不了就大刀阔斧地重构、甚至重写的行为，希望在代码烂到一定程度之后，集中重构解决所有问题是不现实的，必须探索一条**可持续、可演进**的方式
* 推荐：持续重构
  * 平时没事的时候多看看项目中有哪些写得不够好的地方，可以优化的地方，主动去重构一下
  * 修改、添加某个功能代码的时候，顺手把不符合编码规范、不好的设计重构一下

重构能力很重要，但持续重构意识更重要
* 正确看待代码质量和重构这件事情，技术更新、需求变化、人员流动，代码质量总会下降，代码总会存在不完美，重构就会持续进行
* 时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降

如何重构
* 大型重构
  * 完善的重构计划，有条不紊的分阶段来进行
  * 每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，在继续进行下一阶段的重构，保证代码仓库一直处于可运行、逻辑正确的状态
  * 控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码
  * 只有这样才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于和新的功能开发相冲突
* 小规模：随时都可以

**对于重构这件事情，资深的工程师、项目 leader 要负责起来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态**。否则一旦出现破窗效应，就会有更多的人往里堆更烂的代码

> 很多技术问题本身就不是单纯靠技术来解决的，更重要的是要有这种认知和意识

## 保证重构不出错
保证重构不出错，你需要熟练掌握各种设计原则、思想、模式，还需要对所重构的业务和代码有足够的了解。除了个人因素外，最可落地执行、最有效的保证重构不出错的手段就是**单元测试（Unit Testing）**，当重构完成后，如果新的代码仍然能够通过单元测试，就说明代码原有逻辑的正确性未被破坏，原有的外部可见行为未变。

什么是单元测试
* 单元测试相对于集成测试来说，测试粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块。比如测试用户注册、登录功能是否正常，是一种端到端的测试
* 单元测试的测试对象是类或者函数，用来测试一个类和函数是否都按照预期的逻辑执行
* 考验的是程序员思维的缜密程度，看能否设计出覆盖各种正常和异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确执行

为什么要写单元测试
* 有效地为重构保驾护航，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）
* 能有效地帮你发现代码中的 bug
* 能帮你发现代码设计上的问题：如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠框架很高级的特性才能完成，往往就意味着代码设计得不够合理，比如**没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等**
* 单元测试是对集成测试的有力补充：程序的运行往往出现在一些边界条件、异常情况下，单测可以利用 mock 的方式返回我们需要模拟的异常，来测试代码的在异常情况下的表现
* 写单元测试的过程本身就是代码重构的过程：落地持续重构的一个有效途径，编写单元测试就相当于是对代码的一次自我 Code Review，可以发现设计上的不足，以及代码编写方面的问题，比如一些边界条件处理不当等
* 阅读单元测试能帮助你快速熟悉代码
  * **阅读代码最有效的手段，就是先了解业务背景和设计思路，然后再去看代码，这样就会轻松许多**
  * 没有文档和注释的情况下，单元测试就起到了替代性作用，借助单元测试，不需要深入阅读代码，便能知道代码实现了什么功能，哪些情况需要考虑，有哪些边界情况需要处理
* 单元测试是 TDD 可落地执行的改进方案：先写代码、紧接着写单元测试，最后根据单元测试反馈出来的问题，再回过头去重构代码，这个开发流程更加容易被接受，更加容易落地执行，而且兼顾了 TDD 的优点

如何编写单元测试：**针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程**
* 写单元测试并不耗时：虽然代码里可能是被测代码的 1-2 倍，写的过程繁琐，但并不耗时，因为不需要考虑设计，测试代码实现比较简单，而且不同测试用例之间的代码差别可能并不是很大，简单 copy-paste 即可
* 代码质量的要求：质量可以稍微放低一些，比如命名不规范、代码稍微重复
* 只要覆盖率高就够了吗：将覆盖率作为唯一指标是不合理的，更重要的是要看中测试用例是否覆盖了所有可能的情况
* 写单元测试需要了解代码的实现逻辑吗：不要依赖被测试函数的具体实现逻辑，只关心被测函数实现了什么功能。不要针对实现编写单元测试，否则一旦对代码进行重构，在外部行为不变的情况下，对代码的实现进行了修改，那原本的单测都会运行失败，也就起不到为重构保驾护航的目的了

单元测试为何难落地执行
* 觉得繁琐，且没有太多挑战，而不愿意去做，没有感受到它的作用，并且打心底认可
* 刚开始比较认真，开发任务紧了之后，开始放低要求，出现破窗效应，慢慢的就都不写了
* 历史遗留问题：保证新的代码都要有单测，其次，每次在改动到某个类时，如果没有单元测试就顺便补上

## 代码的可测试性
写单元测试并不难，相反写出可测试性的代码反倒是件非常有挑战的事情

单元测试的定义：测试程序员自己编写的代码逻辑的正确性，并非是端到端的集成测试，它不需要测试所依赖的外部系统的逻辑正确性。

如果代码依赖了外部系统或者不可控组件，比如需要依赖数据库、网络通信、文件系统等，就需要将被测代码与外部系统解依赖，这种解依赖的办法就叫做 mock。所谓 **mock 就是用一个假服务替换真正存在的服务**

提高可测试性的手段
* 依赖注入是实现代码可测试性的最有效手段：这样就可以对内部代码随意 mock 然后替换真正的服务了
* 对于内部使用的全局变量，无法 mock 该如何解决呢？重点理解***重新封装，方便隔离**，具体看下面示例
* 跟时间有关的未决行为：将这种未决行为逻辑重新封装，用的还是**二次封装**

重新封装，方便隔离
```java
public class TransactionLock {
  public boolean lock(String id) {
    return RedisDistributedLock.getSingletonInstance().lockTransaction(id);
  }

  public void unlock() {
    RedisDistributedLock.getSingletonInstance().unlockTransaction(id);
  }
}

public class Transaction {
  //...
  private TransactionLock lock;

  public void setTransactionLock(TransactionLock lock) {
    this.lock = lock;
  }

  public boolean execute() {
    //...
    try {
      isLocked = lock.lock();
      //...
    } finally {
      if (isLocked) {
        lock.unlock();
      }
    }
    //...
  }
}

// 这样我们就可以轻松隔离了
public void testExecute() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;

  TransactionLock mockLock = new TransactionLock() {
    public boolean lock(String id) {
      return true;
    }

    public void unlock() {}
  };

  Transaction transaction = new Transaction(null, buyerId, sellerId, productId, orderId);
  transaction.setWalletRpcService(new MockWalletRpcServiceOne());
  transaction.setTransactionLock(mockLock);
  boolean executedResult = transaction.execute();
  assertTrue(executedResult);
  assertEquals(STATUS.EXECUTED, transaction.getStatus());
}
```

和时间有关的未决行为
```java
public class Transaction {

  protected boolean isExpired() {
    long executionInvokedTimestamp = System.currentTimestamp();
    return executionInvokedTimestamp - createdTimestamp > 14days;
  }

  public boolean execute() throws InvalidTransactionException {
    //...
      if (isExpired()) {
        this.status = STATUS.EXPIRED;
        return false;
      }
    //...
  }
}

// 隔离了对于时间的使用，我们就可以方便进行函数的局部 mock 了
public void testExecute_with_TransactionIsExpired() {
  Long buyerId = 123L;
  Long sellerId = 234L;
  Long productId = 345L;
  Long orderId = 456L;
  Transaction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) {
    protected boolean isExpired() {
      return true;
    }
  };
  boolean actualResult = transaction.execute();
  assertFalse(actualResult);
  assertEquals(STATUS.EXPIRED, transaction.getStatus());
}
```

> 不可测试性差的代码，本身代码设计的也不够好，很多地方没有遵守设计原则和思想，比如**基于接口而非实现编程、依赖反转原则**等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想

其他典型的、常见的测试性不好的代码
* 未决行为：代码的输出是随机的，或者说不确定的
* 全局变量：多个测试用例之间会打架，多线程会打架很难测试
* 静态方法：难测试的原因就是不能使用 mock 技巧了，在依赖外部资源、逻辑复杂、行为未决等情况下，就难以测试，但对于纯函数，并不会影响测试性
* 复杂继承：mock 要命了，如果我们使用组合而非继承来组织类与类之间的关系，类之间的结构层次比较扁平，在编写单测时，只需要 mock 类所组合依赖的对象即可
* 高耦合代码

## 通过封装、抽象、模块化、中间层等解耦代码
解耦为何如此重要
* 人处理复杂性的能力是有限的
* 高内聚、松耦合的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类的代码，让我们焦点不至于过于发散，降低了阅读和修改代码的难度
* 因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少很多
* 可测试性更好，容易 mock 或者很少需要 mock 外部依赖的模块或者类
* 高内聚、松耦合意味着代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，代码质量就不会差

代码是否需要解耦
* 看修改代码会不会牵一发而动全身
* 模块与模块之间、类与类之间的依赖关系图

如何给代码解耦
* 封装和抽象：有效的隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口
* 中间层
  * 引入**中间层**能简化模块或类之间的依赖关系
  * 进行重构的时候，引入中间层能够起到过渡的作用，能够让开发和重构同步进行
* 模块化
  * 划分各个独立的模块。不同的人负责不同的模块
  * 代码开发的时候，一定要有模块化意识，每个模块都当做一个独立的 lib 一样来开发，只提供封装了内部实现细节的接口给其他模块用
  * 分而治之
* 其他设计思想和原则
  * 单一职责原则
  * 基于接口而非实现编程
  * 依赖注入
  * 多用组合少用继承
  * 迪米特法则
  * 观察者模式

## 最快速改善代码的编程规范
使用设计原则和设计规范来改善代码，非常依赖个人经验，用不好会适得其反。而编码规范正好相反，大部分都简单明了，在代码细节方面，能立竿见影的改善质量

### 命名与注释
取一个特别合适的名字是一件非常有挑战的事情
* 命名多长合适：在足够表达语义的情况下，命名越短越好
  * 关于缩写：对于一些默认的，大家都熟知的词，推荐使用缩写，比如 sec、str、num、doc
  * 看作用域：作用域比较小的变量可以使用相对短的命名，比如函数内部的临时变量，对于类名这种作用域比较大的，推荐使用长的命名方式
* 利用上下文简化命名
  * 比如 User 类就可以将 userName 简化成 name
  * 函数参数也可以借助函数名词这个上下文来简化
* 命名要可读、可搜索
  * 可读：不要使用一些特别生僻、难发音的英文单词来命名
  * 可搜索：比如大家都用 selectXXX，就不要用 queryXXX，大家都用 insertXXX，就不要用 addXXX
* 如何命名抽象类和接口
  * 接口：常见有两种，IUserService 和 UserServiceImpl
  * 抽象类：也有两种，一种带前缀 Abstract，一种不带前缀

注释
* 目的：让代码更容易看懂，只要符合该要求的内容，都可以写到注释中
* 写什么：做什么、为什么、怎么做，一些复杂的类，还需要写清楚**如何用**，举一些 quick start 例子
  * 注释比代码承载的信息更多
  * 注释起到总结性作用、文档的作用：具体实现思路、总结性说明、特殊情况说明
  * 一些总结性注释能让代码结构更清晰：对于逻辑比较复杂的代码或者比较长的函数，如果不好提炼，不好拆分成小的函数调用，那就借助总结性注释来让代码更清晰
* 注释越多越好？需要平衡
  * 太多：可能意味着代码不够可读、注释太多影响阅读、维护成本高
  * 太少：可能是程序员很懒
* 总结：类和函数一定要写注释，而且尽可能全面、详细，函数内部的注释可以相对少一些，一般都是靠**好的命名、提炼函数、解释性变量、总结性注释**来提高代码可读性

### 代码风格
没有那种代码风格更好，最重要的，也是最需要做到的，是在团队、项目中保持风格统一，让代码像同一个人写出来的，整齐划一。这样能减少阅读干扰，提高代码的可读性。

代码风格你需要关注的
* 类、函数多大才合适
  * 没有一个统一的标准，放盐少许
  * 关于代码函数的最大限制：网上一种说法，不要超过一个显示屏的垂直高度
  * 关于类：间接判断标准，类读起来头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类的时候，就说明类的函数过多了
* 一行代码多长合适：比如 Google 规范中一行代码最长限制为 100 个字符
* 善用空行风格单元块：在比较长的函数中，如果逻辑上可以分为几个独立的代码块，不方便将这些独立代码块抽取成小函数的情况下，为了让逻辑更清晰，可以使用空行来分割各个代码块
* 四个缩进还是两格缩进：推荐使用两个缩进，这样可以节省空间
* 大括号是否要另起一行：推荐将括号放到语句同一行的风格，理由也是节省代码行数
* 类中成员的排列顺序
  * 成员变量在函数的前面
  * 先静态后普通
  * 作用域从大到小排列，public protected private

### 编程技巧
使用编程技巧
* 把代码分隔成更小的单元块
  * 阅读代码都是先整体在看细节。因此，要有**模块化和抽象思维**，善于将大块的复杂代码提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样就能极大的提高代码的可读性
* 避免函数参数过多
  * 函数包含 3、4 个参数的时候还能接受，大于等于 5 的个时候，就会影响到代码的可读性
  * **考虑函数是否职责单一，能否通过拆分成多个函数来减少参数**
  * **将函数的参数封装成标准对象，一方面能减少参数，还能提高接口的兼容性**，添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容行的接口了
* 勿用函数参数来控制逻辑
  * 不要在函数中使用布尔类型的标识参数来控制内部逻辑，违背了单一职责和接口隔离原则，建议拆成两个函数，可读性也要更好
  * 如果函数是私有类型，影响范围有限或者拆分之后的两个函数经常同时被调用，可以酌情考虑保留标识参数
  * 根据参数是否为 null 来控制逻辑的情况，也应该拆分成多个函数，拆分后函数职责更明确
* 函数设计要职责单一
* 移除过深的嵌套层级
  * if-else/switch-case/for
  * 嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套，过深的嵌套理解起来会比较费劲
  * 解决办法1：去掉多于的 if 或 else 语句：无用的 else，合并 if
  * 解决办法2：使用编程语言提供的 continue、break、return 关键字提前退出嵌套
  * 解决办法3：调整执行顺序来减少嵌套，比如先执行判空逻辑，再执行正常逻辑
  * 解决办法4：将部分嵌套封装成函数调用
  * 解决办法4：使用多态来代替条件判断
* 学会使用解释性变量
  * 常用在需要魔法数据时
  * 使用解释性表达式来代替复杂表达式

> 最重要的事：项目、团队一定要制定统一的编码规范，并且通过 Code Review 监督执行， 这对提高代码质量有立竿见影的效果

## 如何发现代码质量问题
通用关注点：可以从以下几个方面来审视代码
* 目录是否合理、模块划分是否清晰、代码结构是否满足高内聚、松耦合
* 是否遵循经典的设计原则和设计思想
* 设计模式是否应用得当，是否有过度设计
* 代码是否容易扩展？如果要添加新功能，是否容易实现
* 代码是否可以复用？是否复用已有的项目代码或类库？是否有重复造轮子
* 代码是否容易测试？单元测试是否覆盖前面覆盖了各种正常和异常的情况
* 代码是否易读？是否符合编码规范（比如命名和注释是否恰当，代码风格是否一致）

具体业务、具体代码去具体分析
* 代码是否实现了预期的业务需求
* 逻辑是否正确？是否处理了各种异常情况
* 日志是否打印得当？是否方便 debug 排查问题
* 接口是否易用？是否支持幂等、事务等
* 代码是否存在并发问题？是否线程安全 -- 重点关注共享变量问题
* 性能是否有优化空间，比如 SQL、算法是否可以优化
* 是否有安全漏洞？比如输入输出是否全面

## 如何针对发现的质量问题进行优化
重构代码的过程应该遵循小步快跑的思路，每次改一点点，改好之后，再进行下一轮优化，保证每次对代码的改动不会过大，能在很短的时间内完成。比如可以分为如下步骤
* 提高代码可读性
  * 重点就是学会抽象出具体逻辑，赋予一个有语意的函数，屏蔽掉细节
  * 删除魔法数字
  * if 逻辑简化
  * 关注命名
* 提高代码可测试性
  * 静态函数会影响使用该函数的代码的可测试性（Mock 静态函数属于高级特性了）
  * 依赖运行环境、时间函数、随机函数的代码本身测试性也不好，解决办法：把复杂逻辑抽出来，原来的代码就会变得十分简单，重点测试复杂代码即可
  * **依赖注入之所以能提高代码可测试性，主要是因为，通过这样的方式我们能轻松的 Mock 对象替换依赖的真实对象。为什么要 Mock 这个对象呢？因为这个对象参与逻辑执行（依赖它输出的数据做后续的计算）但又不可控**
* 编写完善的单元测试
  * 单元测试对象是函数定义的功能，而不是具体的实现逻辑，这样才能做到，函数的实现逻辑改变之后，单元测试用例仍然可以工作
  * 写单测的目的是为了减少 bug，而不是为了写而写，因此对于简单的但反而不好测试的逻辑，可以不用测试
* 所有重构完成之后添加注释
  * 类和函数的逻辑往往比较复杂，单靠命名很难清晰的表明实现了什么功能，这时候就需要通过注释来补充
  * **做什么、为什么、怎么做、怎么用，对一些边界条件、特殊情况进行说明，以及对函数输入、输出、异常进行说明**

## 程序出错应该返回啥
函数出错的情况下可以返回
* 异常对象：C++ 和大部分动态语言，比如 Python 和 JavaScript 都只定义了一种异常类型：运行时异常。而 Java 除此之外还定义了一种异常类型：编译时异常
* 错误码：C 语言用的比较多，有异常机制就不要使用错误码，因为异常有更多优势，比如可以携带更多的错误信息
* null 值
* 特殊值（比如 -1）
* 空对象（空字符串，空集合）：返回 null 值有各种弊端，比如各种判空，应对这个问题比较经典的策略就是空对象设计模式

如何处理程序抛出的异常
* 直接吞掉
* 原封不动 re-throw
* 包装成新的异常 re-throw

理论上讲，参数传递的正确性应该由程序员来保证，我们无需做 NULL 值或空串的判断，但谁也无法保证程序员就一定不会传递非法值
* 如果是私有的，完全在你的掌控之下，自己保证不要传递非法值即可
* 如果是公有的，无法掌控会被谁调用以及如何调用，为了尽可能提高健壮性，最好加上判断