创建型模式主要解决对象的创建问题：封装复杂的创建过程，解耦对象的创建代码和使用代码

## 单例模式
单例设计模式：一个类只允许创建一个对象

为什么要使用单例
* 处理资源访问冲突
  * 场景 1：多线程环境下，如果两个线程同时给同一个共享变量加 1，因为共享变量是竞争资源，所以共享变量最后的结果有可能并不是加了 2，而是只加了 1
  * 场景 2：比如同时给文件进行写入，可能会导致内容被覆盖。你可能会说通过 synchronized 加锁即可。但如果只是加对象级别的锁，如果是多个对象，还是解决不了数据互相覆盖的问题
  * 把对象级别的锁，换成类级别的锁就可以了，让所有的对象都共享同一把锁
  * 扩展：FileWriter 本身就是线程安全的，内部实现中本身就加了对象级别的锁
  * 使用单例模式，就可以不使用类级别锁了，加上 FileWriter 本身是线程安全的，简直完美，同时相比使用类级别锁的好处是
    * 不用创建那么多 Logger 对象，节省内存
    * 节省系统文件句柄
* 表示全局唯一类
  * 配置信息类
  * 唯一递增 ID 号码生成器
  * 连接池类


对象级别锁和类级别锁使用例子
```java
public class Logger {
    private FileWriter write;

    public Logger() {
        File file = new File('/users/log.txt');
        write = new FileWriter(file, true); // true 表示追加写入
    }

    public void log(String message) {
        // 对象级别
        synchronized(this) {
            write.write(message);
        }
        // 类级别
        synchronized(Logger.class) {
            write.write(message);
        }
    }
}
```

要实现一个单例，需要关注的点
* 构造函数需要 private 访问权限，避免外部通过 new 创建实例
* 考虑对象创建时的线程安全问题
* 考虑是否支持延迟加载
* 考虑 getInstance() 性能是否高（是否加锁）

单例创建方式
* 饿汉式：在类加载的时候，instance 静态实例就已经创建并初始化，因此 instance 实例的创建过程是线程安全的，不支持延迟加载
  * 有些观点：占用资源多，初始化时间长，提前初始化实例是一种浪费资源的行为，最好的方法应该在用到的时候再去初始化
  * 反驳方：如果初始化耗时长，那最好不要等到真正用它的时候，才去执行这个耗时长的初始化过程，这会影响系统的性能。饿汉式将耗时的初始化操作，提高到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题
  * 如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），也希望在程序启动时就将实例初始化好。如果资源不够，在程序启动的时候触发报错，就可以立即去修复
* 懒汉式：支持延迟加载。缺点也很明显，会有线程安全问题，因此 getInstance() 需要加一个锁，导致这个函数的并发度很低
* 双重检测：饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发，可以优化一下
  * 只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中
  * 上述方式在低版本 JDK 中可能存在问题，因为**指令重排序**，对象被 new 出来之后，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码），就被另一个线程使用了
  * 解决上述问题，需要给 instance 成员变量加上 `volatile` 关键字，禁止指令重排序即可。实际上高版本 Java 已经在 JDK 内部实现中解决了这个问题（把对象 new 操作和初始化操作设计为原子操作，自然就能禁止重排序）
* 静态内部类：类似饿汉式，又能延迟加载

静态内部类
```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    private IdGenerator() {}

    private static class SingletonHolder {
        private static final IdGenerator instance = new IdGenerator();
    }

    public static IdGenerator getInstance() {
        // 只有当首次访问时才会初始化 SingletonHolder
        return SingletonHolder.instance;
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```


单例存在哪些问题
* 对 OOP 特性的支持不友好，对抽象、继承、多态都支持的不好
  * 违背了基于接口而非实现的设计原则，也就违背了广义上理解的 OOP 的抽象特性
* 单例会隐藏类之间的依赖关系
  * 通过构造函数、参数传递等方式声明的类之间的依赖关系，通过查看函数的定义很容易识别处理
  * 单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用即可
* 单例对代码的扩展性不友好
* 单例对代码的可测试性不友好
  * 单例类这种硬编码式的使用方式，导致无法实现 mock 替换
  * 如果单例类只有成员变量，那实际上相当于一种全局变量，被所有的代码共享。如果全局变量是一个可变的全局变量，编写测试的时候，还需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值，从而导致测试结果互相影响的问题
* 单例不支持有参数的构造函数
  * 办法一：先调用 init 函数传递参数，再获取 instance 实例
  * 办法二：将参数放到 getInstance 中
  * 办法三：将参数放到另外一个全局变量中，比如 Config 中，**推荐做法**

有何替代的解决方案
* 使用静态方法，但并不能解决单例存在的问题，而且更加不灵活，无法延迟加载
* 使用新的使用方式（依赖注入）：将单例生成的对象，作为参数传递给函数，也可以通过构造函数传递给类的成员变量，可以解决单例存在的其他问题
* 工厂模式
* IOC 容器
* 程序员自己保证

> 有人把单例当做反模式，主张杜绝在项目中使用，其实模式没有对错，关键看你怎么用。如果单例类没有后续扩展需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局的类，在其他地方 new 的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便

如何理解单例模式中的唯一性
* 进程内只允许创建一个对象

如何实现线程唯一的单例
* 通过 HashMap 来存储对象，key 是线程 ID，value 是对象
* Java 语言提供了 ThreadLocal 工具类，可以更加轻松的实现线程唯一单例
* Thread.currentThread().getId()
* instances.putIfAbsent(id, new IdGenerator())

如何实现集群环境下的单例
1. 把这个单例对象序列化并存出到外部共享存储区（比如文件）
2. 进程在使用这个单例的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后在使用
3. 使用完后，还需要在存储回外部共享存储区
4. 为保证任何时刻，进程间都只有一份对象存在，一个进程在获取到对象后，需要对对象加锁，避免其他进程再将其获取。进程使用完之后，还需要显示的将对象从内存中删除，并且释放对象的加锁

如何实现一个多例模式
* 一个类可以创建多次，但个数是有限制的，比如只能创建 3 个对象
* 另一种理解：同一类型的只能创建一个对象，不同类型的可以创建多个对象

> 这种多例模式的理解方式有点类似工厂模式，和工厂模式的不同之处是，多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象

## 工厂模式
通常工厂模式细分为 3 种
* 简单工厂
  * if-else 条件判断
  * 通过 Map 对象进行键值映射，直接调用 get
* 工厂方法
  * 利用多态去掉 if 分支逻辑，面向接口编程
    * 你会发现 if 逻辑并没有去掉，只是转移到了其他地方，此时我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象，将这部分逻辑隐藏起来
  * 工厂方法模式比起简单工厂模式更加符合开闭原则
  * 缺点就是工厂模式需要额外添加诸多 Factory 类，也会增加代码的复杂性
  * 原则：**之所以将某个代码剥离出来，独立为函数或者类，原因是这个代码逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护，如果代码块本身并不复杂，就几行代码而已，完全没必要将它拆分成单独的函数或者类**
  * 什么时候使用呢：**当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式。将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂**
* 抽象工厂
  * 使用场景比较特殊，并不常用
  * 解决某些场景下，工厂方法类过多的问题。可以让一个工厂负责创建多个不同类型的对象

什么时候该用工厂模式？相对直接 new 来创建对象，用工厂模式来创建究竟有什么好处
* 什么时候：如果针对不同的情况创造不同的对象，这时候就可以使用工厂模式将这部分代码抽离处理，只负责对象的创建
* 命名：大部分工厂类都以 Factory 结尾，创建对象的方法通常都是以 create 开头

当创建逻辑比较复杂，是一个大工程的时候，就考虑使用工厂模式，封装对象的创建过程，将对象的**创建和使用相分离**，何为创建逻辑复杂呢
* 代码中存在 if-else 分支判断，动态的根据不同的类型创建不同的对象
* 尽管不根据不同的类型创建不同的对象，但是单个对象本身的创建过程比较复杂，比如需要组合其他类对象，做各种初始化操作，也可以考虑使用工厂模式

工厂模式的作用
* 封装变化：创建逻辑可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明
* 代码复用：创建代码抽离到独立的工厂类之后可以复用
* 隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象
* 控制复杂度：将代码抽离出来后，让原本的函数或类职责更单一，代码更简洁

### 依赖注入框架
工厂模式和 DI 容器有何区别
* DI 容器底层最基本的设计就是基于工厂模式的。DI 容器相当于一个大工厂，在程序启动的时候，根据配置事先创建好对象。当应用程序需要使用某个类对象时，直接从容器中获取即可。正是因为它持有一堆对象，所以也被称作容器
* 一个工厂只负责某个类对象或者某一组相关类创建，DI 负责的是整个应用中所有类对象的创建

DI 容器核心功能有哪些
* 配置解析
* 对象创建：BeansFactory，反射机制，动态加载类、创建对象
* 对象生命周期管理
  * 比如 Spring，通过 scope 属性指定每次返回新对象还是单例对象（prototype 与 singleton）
  * 配置对象是否支持懒加载，只有在真正使用到的时候才创建

简单 DI 容器设计

## 建造者模式
Builder 模式，翻译为建造者模式或者构造者模式，也叫生成器模式

思考这几个问题：**直接使用构造函数或者配合 set 方案就能创建对象，为什么还需要建造者模式来创建呢？建造者模式和工厂模式都可以创建对象，那它们两个的区别在那里呢**

为什么需要建造者模式？什么时候使用 new 调用构造函数来创建对象不适用了呢
* 调用构造函数需要的参数太多，会导致代码在可读性和易用性上都会变差。也很容易搞错各参数的顺序，传递进错误的参数值，从而导致 bug
* 解决办法：构造函数只设置必填项，其他非必填项调用 set 函数来给成员变量赋值，以代替冗余的构造函数

但上述办法会碰到如下问题
* 如果必填项本身就很多，全放进构造函数中，依旧会出现参数列表很长的问题。如果必填项也通过 set 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了
* 如果配置项之间有一定的依赖关系，比如设置了 A，就必须显示设置 B 和 C，或者匹配项之间有一定的约束条件，此时依赖关系和条件约束的检验逻辑就无处安放了
* 如果希望该对象为不可变对象，也就是说创建好之后，就不能在修改内部的属性值。这时候就不能暴露 set 方法了

为了解决上述问题，建造者模式就派上用处了
1. 把校验逻辑放置到 Builder 类中，先创建建造者
2. 通过 set 方法设置建造者的变量值
3. 使用 build 方法真正创建对象之前，做集中的校验，通过之后才会创建对象。通过将类构造函数设置为 private，且不暴露任何 set 方法，这样依赖就是不可变对象了

与工厂模式的区别
* 工厂模式用来创建不同但是相关类型的对象，由给定的参数来决定创建那种类型的对象
* 建造者模式用来创建同一种类型复杂的对象，通过设置不同的可选参数，定制化的创建不同的对象

> 顾客走进一家餐馆点餐，利用工厂模式，根据用户的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，通过建造者模式根据用户选择的不同配料来制作披萨

## 原型模式
原型模式：如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的

为何对象的创建成本比较大
* 实际上，创建对象包含的申请内存、给成员变量赋值的过程，本身并不会花费太多时间，对于大部分业务系统来说，这点时间完全是可以忽略的
* 如果对象的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次创建新对象时候，都重复执行这些耗时的操作

我们把正在使用的数据的版本定义为服务版本，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假如是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b。这样既保证了数据一直可用，又避免了中间状态的存在。

通过原型模式更新对象的话：拷贝已有对象的数据，更新少量差值

> Java 的 clone 语法是浅拷贝，只会拷贝对象中的基本数据类型，以及引用对象的内存地址，不会递归拷贝引用对象本身

如何实现深拷贝
* 递归拷贝对象，直到要拷贝的对象只包含基本数据类型数据
* 先将对象序列化，然后再反序列化成新的对象