回顾笔记
## 通用
个人认为评价代码质量高度最重要的指标
* 可读性
* 可维护性
* 可扩展性
* 可测试性

不要过于将类代码量整到最小：一个类应该有一定的体型，不胖不瘦才是最好，胖了就要分拆，瘦了可能就需要合并。

> Design patterns should emerge from your code, not be forced upon it.

**设计模式应该从代码中自然生长出来，而不是你强制添加上去的**。这意味着
* 常见设计模式的应用，一般都是通过持续重构来获得。
* 设计模式是建立在需要它的场景之上的，不要为了用而用。

设计模式分类
* 创建型设计模式主要解决对象的创建问题
* 结构型设计模式主要解决类或对象的组合或组装
* 行为型设计模式主要的就是类或对象之间的交互问题

设计模式要干的事情就是解耦
* 创建型模式是将创建和使用代码解耦
* 结构型模式是将不同功能代码解耦
* 行为型模式是将不同行为代码解耦

你可能需要考虑的问题
* 如何分层、分模块？
* 如何划分类，每个类应该具有哪些属性、方法？
* 如何设计类之间的交互？
* 该用继承还是组合？
* 该用接口还是抽象类？
* 怎样做到解耦、高内聚低耦合？
* 该使用单例模式还是静态方法？
* 用工厂模式创建对象还是直接 new 出来？
* 如何避免引入设计模式提高扩展性的同时带来降低可读性问题？

怎么提高代码复用性
* 减少代码耦合
* 满足单一职责原则
* 模块化：模块、类、函数，善于将功能独立的代码，封装成模块
* 业务与非业务逻辑分离
  * 越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用
  * 分离出非业务代码，抽取成一些通用的框架。类库、组件
* 通用代码下沉
  * 越底层的代码越通用、会被越多模块调用、越应该设计得足够可复用
  * 代码分层后，为避免交叉调用，只允许上层代码调用下层及同层代码之间的调用，杜绝下层代码调用上层代码
* 继承、多态、抽象、封装
  * 继承复用父类属性和方法
  * 多态可以动态的替换一段代码的部分逻辑，让这段代码更容易复用
  * 越抽象、越不依赖具体的实现，越容易复用
  * 代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用
* 应用模板等设计模式
* 泛型编程
* 复用意识
  * 思考这部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用
  * 在设计每个模块、类、函数的时候，要像设计一个外部 API 那样，去思考它的复用性

分层带来的好处
* 分层能起到代码复用的作用
* 分层能起到隔离变化的作用
* 分层能起到隔离关注点的作用
* 分层能提高代码的可测试性
* 分层更能应对系统的复杂性

## 面向对象
面向对象特性
* 封装：private、public、protected
* 抽象：interface、abstract class
* 继承：extends（多用组合少用继承）
* 多态
  * 子类可以替换父类，在实际的运行代码过程中，调用子类的实现
  * 提高代码的可扩展性：只需要实现对应接口或继承类就可以实现扩展

面向对象编程风格是一种自底向上的思考方式，不是按照流程来分解任务，而是将任务翻译成一个一个小的模块（类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。因此养成**自底向上**思考方式很关键。

抽象类 vs 接口
* 抽象类是一种自下而上的设计思路，现有子类的代码重复，然后再抽象成上层的父类
* 接口正好相反，是一种自上而下的设计思路，一般都是先设计接口，再去考虑具体的实现

关于 OOP 重点理解
* 基于接口而非实现
* 多用组合少用继承
* 贫血模型和充血模型差别

从理论上讲，通过**组合、接口、委托**三个技术手段，完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系
```js
interface Singable {
    sing(): void;
}

class Singer implements Singable {
    sing() {
        console.log('cool');
    }
}

class Bird implements Singable {
    constructor() {
        this.singer = new Singer();
    }
    sing() {
        this.singer.sing();
    }
}
```

面向对象需求分析
* 具体需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的
* 非业务系统的开发一定要有组件化意识、框架意识、抽象意识，足够通用，而不局限于单一某个业务需求

面向对象分析得到相关类设计
* 划分职责进而识别出有那些类
* 定义类与类及其属性和方法
* 定义类与类之间的交互关系
* 将类组装起来并提供执行入口

## 设计原则
单一职责原则目的：为了实现代码高内聚、低耦合
* 避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性
* 类职责单一，类依赖和被依赖的其他类也会变少，减少了代码的耦合性

判断是否单一的小技巧
* 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，就需要对类进行拆分
* 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，就需要考虑对类进行拆分
* 私有方法过多，考虑能够将私有方法独立到新的类中，设置为 public 方法供更多类使用，从而提高代码的复用性
* 比较难给类起一个合适名字，很难用一个业务名词概括，只能用一些笼统的 Manager、Context 之类的词语来命名，由此说明类职责定义的可能不够清晰
* 类中大量的方法都是集中操作类中的某几个属性，那就可以考虑将这几个属性和对应的方法拆出来

开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则：扩展性是代码质量最重要的衡量标准之一。在 23 中经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是**开闭原则**。

如何判断是不是合格的代码改动，同样可以判断是否符合开闭原则：**只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试**

开闭原则具体方法论
* 多态、依赖注入、基于接口而非实现编程
* 大部分设计模式：装饰、策略、模板、职责链、状态等

没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计，合理的做法是
* 对一些比较确定的，短期内可能就会扩展的
* 需求改动对代码结构影响比较大的情况
* 实现成本不高的扩展点

如何写出满足 KISS 原则的代码
* 不要使用同事可能不懂的技术来实现代码。比如高级语法、正则等
* 不要重复造轮子，要善于使用已有的工具类库
* 不要过度优化，不要过度使用一些奇技淫巧来优化代码，牺牲代码的可读性

### 最小知识原则
何为高内聚、松耦合
* 重要的设计思想，能够有效的提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。很多原则都以实现代码的高内聚、松耦合为目的，比如单一职责原则、基于接口而非实现编程
* 比较通用的设计思想，用来指导不同粒度代码的设计与开发，比如系统、模块、类、甚至是函数
* **高内聚用来指导类本身的设计，松耦合用来直到类与类之间依赖关系的设计**。两者并非完全独立不相干。高内聚有助于松耦合、松耦合又需要高内聚

什么是高内聚呢
* 相近的功能应该放在同一个类中，不相近的功能不要放在同一个类中
* 相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护
* **单一职责原则是实现代码高内聚非常有效的设计原则**

什么是松耦合呢
* 类与类之间的依赖关系简单清晰
* 即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动
* **依赖注入、接口隔离、基于接口而非实现编程以及迪米特法则，都是为了实现代码的松耦合**

最小知识原则：每个模块只应该了解那些与它关系密切的模块的有限知识。

更实际的定义可以为：**不该有直接依赖关系的类之间，不要有依赖。有依赖关系的类之间，尽量只依赖必要的接口，也就是定义中的有限知识**

常犯错误
* 比如定一个方法，**入参直接定义为某个大对象，但方法内部只用到了1-2个属性，这就违背了最小知识原则，应该改为传递它关心的那两个属性**
* 创建一个对象，引入了本不该关心的依赖，**只是为了计算得到某个属性，这种情况应该通过创建型解决，保证原本类的纯粹性**

比如如下代码，你看出问题了吗
```java
public class Document {
  private Html html;
  private String url;

  public Document(String url) {
    this.url = url;
    HtmlDownloader downloader = new HtmlDownload();
    this.html = downloader.downloadHtml(url);
  }
}
```

咋看好像没问题，但 Document 为什么要依赖 HtmlDownload 呢，这就违背了最小知识原则，优化如下。（同时也是很好的工厂模式案例！！！）
```java
public class Document {
  private Html html;
  private String url;

  public Document(String url, Html html) {
    this.url = url;
    this.html = this.html;
  }
}

public class DocumentFactory {
  private HtmlDownloader downloader;

  public DocumentFactory(HtmlDownloader downloader) {
    this.downloader = downloader
  }

  public Document createDocument(String url) {
    Html html = downloader.download(url);
    return new Document(url, html)
  }
}
```

> 拆分有垂直和水平两个方向。**水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是分层**

## 重构
到底重构什么
* 大型重构
  * 对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构
  * 重构手段：分层、模块化、解耦、抽象可复用组件、梳理类之间的交互关系
  * 重构工具：设计思想、原则和模式
* 小型重构
  * 代码系统的重构，针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、修正函数参数过多、提取重复代码等
  * 重构手段：编码规范

## 编程技巧
编程技巧
* 避免函数参数过多
  * 考虑函数是否职责单一，能否通过拆分成多个函数来减少参数
  * 将函数的参数封装成标准对象，一方面能减少参数，还能提高接口的兼容性
* 学会使用解释性变量
  * 常用在需要魔法数据时
  * 使用解释性表达式来代替复杂表达式

空对象设计模式
* 返回 null 值会导致各种判空
* 推荐返回空串、空集合

避免函数参数过多
* 函数包含 3、4 个参数的时候还能接受，大于等于 5 的个时候，就会影响到代码的可读性
* **考虑函数是否职责单一，能否通过拆分成多个函数来减少参数**
* **将函数的参数封装成标准对象，一方面能减少参数，还能提高接口的兼容性**，添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容行的接口了

## 设计模式
创建型模式主要解决对象的创建问题：封装复杂的创建过程，解耦对象的创建代码和使用代码

单例常用场景
* 配置信息类
* 唯一递增 ID 号码生成器
* 连接池类

实用的工厂模式和建造者模式
* 工厂模式用来创建不同但是相关类型的对象，由给定的参数来决定创建那种类型的对象
* 建造者模式用来创建一种类型复杂的对象，通过设置不同的可选参数，定制化的创建不同的对象

当创建逻辑比较负责，是一个大工程的时候，就考虑使用工厂模式，封装对象的创建过程，将对象的**创建和使用相分离**，何为创建逻辑复杂呢
* 代码中存在 if-else 分支判断，动态的根据不同的类型创建不同的对象
* 尽管不根据不同的类型创建不同的对象，但是单个对象本身的创建过程比较复杂，比如需要组合其他类对象，做各种初始化操作，也可以考虑使用工厂模式

建造者模式解决的问题
* 调用构造函数需要的参数太多，会导致代码在可读性和易用性上都会变差。也很容易搞错各参数的顺序，传递进错误的参数值，从而导致 bug
* 把校验逻辑放置到 Builder 类中，先创建建造者。通过 set 方法设置建造者的变量值，使用 build 方法真正创建对象之前，做集中的校验，通过之后才会创建对象

> 顾客走进一家餐馆点餐，利用工厂模式，根据用户的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，通过建造者模式根据用户选择的不同配料来制作披萨

代理模式，React HOC 就是从这里借鉴来的，方式都是一样的，如果需要附加功能的类不止一个，通常语言都会支持动态代理特性。
* 属性代理：ProxyHOC，利用的是委托机制
* 反向继承：InheritHOC，利用的继承机制

有用的装饰器模式
* 装饰类和原始类继承同样的父类，这样就可以对原始类嵌套多个装饰器类，Wrapper 模式的某一种场景
* 代理类附加的是跟原始类无关的功能，而在装饰器模式中，附加的是跟原始类相关的增强功能

代理、桥接、装饰器和适配器的区别
* 笼统的来说，都可以称为 **Wrapper 模式**，也就是通过 Wrapper 类二次封装原始类
* 代理模式：在不改变原始类接口的条件下，为原始类定义个一个代理类，主要目的是访问控制，而非加强功能
* 桥接模式：将接口部分和实现部分分离，从而让他们可以较为容易、也相对独立的加以改变
* 装饰器模式：在不改变原始类接口的情况下，**对原始类功能进行增强，并且支持多个装饰器的嵌套使用**
* 适配器模式：一种事后补救策略，提供跟原始类不同的接口
* 门面模式：为子系统以供一组统一的接口，定义一组高层接口让子系统更易用

> 设计接口原则：**尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口**

实用的行为模式
* 观察者模式
* 模板模式：abstract class，有点类似回调函数
* 策略模式：组合技能 = 定义策略接口 + 一组实现该接口的策略 + 工厂模式确定使用哪个接口
* 职责链模式：常用于开发过滤器，拦截器
* 备忘录模式
* 命令模式：常用与实现命令排队，撤销重做等

设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯的看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式

命令模式、策略模式、工厂模式
* 策略模式包含策略的定义、创建和使用三部分，代码结构上和工厂模式类似。区别在于策略模式侧重策略或者算法这个特定的应用场景，用于解决根据运行时状态从一组策略中选择不同策略的问题
* 工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，也可以是其他东西
* 策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换
* 命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换

查表法 提升性能神器
* K-V：用过 K 找值
* 数组：通过下标查找

中介模式：实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系**从多对多转换为一对多**。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。

## 重构案例

### 案例一
告警通知例子，重构前
```java
interface Alert {
    AlertRule alertRule;
    Notification: notification;
    void check(...params)
}
```

重构思路
* check 函数多个入参封装成 ApiStatInfo
* 引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中

重构后
```java
interface Alert {
    List<AlertHandler> alertHandlers = new ArrayList<>();
    void addAlertHandler();
    void check(ApiStatInfo apiStatInfo)
}
interface AlertHandler {
    AlertRule alertRule;
    Notification notification;
    void check(ApiStatInfo apiStatInfo)
}
```

### 有趣的设计
针对 A 和 B 类的交互，比如 B 类持有 A，通常我们会将 A 构造好后，通过构造函数传递给 B，这样的话需要比 B 类有一定的认知。我们可以反过来设计一下，A 类提供一个方法，返回一个 B 的实例，类比传递 this 即可，这样感觉内聚性更好了。
```java
public class ArrayIterator<E> implements Iterator<E> {
    private int cursor;
    private ArrayList<E> arrayList;

    public ArrayIterator(ArrayList<E> arrayList) {
        this.cursor = 0;
        this.arrayList = arrayList;
    }

    public boolean hasNext() {
        return cursor != arrayList.size();
    }

    public void next() {
        cursor++;
    }

    public E currentItem() {
        if (cursor >= arrayList.size()) {
            throw new NoSuchElementException();
        }
        return arrayList.get(cursor);
    }
}

// 使用如下方式提供，很酷。
public class ArrayList<E> implements List<E> {
    public Iterator iterator() {
        return new ArrayIterator(this);
    }
}
```

### 案例三-工厂与建造