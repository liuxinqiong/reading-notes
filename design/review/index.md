## 20211125
不要过于将类代码量整到最小：一个类应该有一定的体型，不胖不瘦才是最好，胖了就要分拆，瘦了可能就需要合并。

Design patterns should emerge from your code, not be forced upon it.

**设计模式应该从代码中自然生长出来，而不是你强制添加上去的**。这意味着
* 常见设计模式的应用，一般都是通过持续重构来获得。
* 设计模式是建立在需要它的场景之上的，不要为了用而用。

你可能需要考虑的问题
* 如何分层、分模块？
* 如何划分类，每个类应该具有哪些属性、方法？
* 如何设计类之间的交互？
* 该用继承还是组合？
* 该用接口还是抽象类？
* 怎样做到解耦、高内聚低耦合？
* 该使用单例模式还是静态方法？
* 用工厂模式创建对象还是直接 new 出来？
* 如何避免引入设计模式提高扩展性的同时带来降低可读性问题？

面向对象特性
* 封装：private、public、protected
* 抽象：interface、abstract class
* 继承：extends（多用组合少用继承）
* 多态
  * 子类可以替换父类，在实际的运行代码过程中，调用子类的实现
  * 提高代码的可扩展性：只需要实现对应接口或继承类就可以实现扩展

面向对象编程风格是一种自底向上的思考方式，不是按照流程来分解任务，而是将任务翻译成一个一个小的模块（类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。因此养成**自底向上**思考方式很关键。

抽象类 vs 接口
* 抽象类是一种自下而上的设计思路，现有子类的代码重复，然后再抽象成上层的父类
* 接口正好相反，是一种自上而下的设计思路，一般都是先设计接口，再去考虑具体的实现

从理论上讲，通过组合、接口、委托三个技术手段，完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系
```js
interface Singable {
    sing(): void;
}

class Singer implements Singable {
    sing() {
        console.log('cool');
    }
}

class Bird implements Singable {
    constructor() {
        this.singer = new Singer();
    }
    sing() {
        this.singer.sing();
    }
}
```

单一职责原则目的：为了实现代码高内聚、低耦合
* 避免设计大而全的类，避免将不相关的功能耦合在一起，来提高类的内聚性
* 类职责单一，类依赖和被依赖的其他类也会变少，减少了代码的耦合性

判断是否单一的小技巧
* 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，就需要对类进行拆分
* 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，就需要考虑对类进行拆分
* 私有方法过多，考虑能够将私有方法独立到新的类中，设置为 public 方法供更多类使用，从而提高代码的复用性
* 比较难给类起一个合适名字，很难用一个业务名词概括，只能用一些笼统的 Manager、Context 之类的词语来命名，由此说明类职责定义的可能不够清晰
* 类中大量的方法都是集中操作类中的某几个属性，那就可以考虑将这几个属性和对应的方法拆出来

开闭原则是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则：扩展性是代码质量最重要的衡量标准之一。在 23 中经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是**开闭原则**。

如何判断是不是合格的代码改动，同样可以判断是否符合开闭原则：**只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试**

没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计，合理的做法是
* 对一些比较确定的，短期内可能就会扩展的
* 需求改动对代码结构影响比较大的情况
* 实现成本不高的扩展点

如何写出满足 KISS 原则的代码
* 不要使用同事可能不懂的技术来实现代码。比如高级语法、正则等
* 不要重复造轮子，要善于使用已有的工具类库
* 不要过度优化，不要过度使用一些奇技淫巧来优化代码，牺牲代码的可读性

### 最小知识原则
何为高内聚、松耦合
* 重要的设计思想，能够有效的提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。很多原则都以实现代码的高内聚、松耦合为目的，比如单一职责原则、基于接口而非实现编程
* 比较通用的设计思想，用来指导不同粒度代码的设计与开发，比如系统、模块、类、甚至是函数
* **高内聚用来指导类本身的设计，松耦合用来直到类与类之间依赖关系的设计**。两者并非完全独立不相干。高内聚有助于松耦合、松耦合又需要高内聚

什么是高内聚呢
* 相近的功能应该放在同一个类中，不相近的功能不要放在同一个类中
* 相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护
* **单一职责原则是实现代码高内聚非常有效的设计原则**

什么是松耦合呢
* 类与类之间的依赖关系简单清晰
* 即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动

最小知识原则：每个模块只应该了解那些与它关系密切的模块的有限知识。

更实际的定义可以为：**不该有直接依赖关系的类之间，不要有依赖。有依赖关系的类之间，尽量只依赖必要的接口，也就是定义中的有限知识**

常犯错误
* 比如定一个方法，**入参直接定义为某个大对象，但方法内部只用到了1-2个属性，这就违背了最小知识原则，应该改为传递它关心的那两个属性**
* 创建一个对象，引入了本不该关心的依赖，**只是为了计算得到某个属性，这种情况应该通过创建型解决，保证原本类的纯粹性**

比如如下代码，你看出问题了吗
```java
public class Document {
  private Html html;
  private String url;

  public Document(String url) {
    this.url = url;
    HtmlDownloader downloader = new HtmlDownload();
    this.html = downloader.downloadHtml(url);
  }
}
```

咋看好像没问题，但 Document 为什么要依赖 HtmlDownload 呢，这就违背了最小知识原则，优化如下
```java
public class Document {
  private Html html;
  private String url;

  public Document(String url, Html html) {
    this.url = url;
    this.html = this.html;
  }
}

public class DocumentFactory {
  private HtmlDownloader downloader;

  public DocumentFactory(HtmlDownloader downloader) {
    this.downloader = downloader
  }

  public Document createDocument(String url) {
    Html html = downloader.download(url);
    return new Document(url, html)
  }
}
```

**拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是分层**

### misc
编程技巧
* 避免函数参数过多
  * 考虑函数是否职责单一，能否通过拆分成多个函数来减少参数
  * 将函数的参数封装成标准对象，一方面能减少参数，还能提高接口的兼容性
* 学会使用解释性变量
  * 常用在需要魔法数据时
  * 使用解释性表达式来代替复杂表达式

空对象设计模式
* 返回 null 值会导致各种判空
* 推荐返回空串、空集合

### 模式
创建型模式主要解决对象的创建问题：封装复杂的创建过程，解耦对象的创建代码和使用代码

单例常用场景
* 配置信息类
* 唯一递增 ID 号码生成器
* 连接池类

实用的工厂模式和建造者模式
* 工厂模式用来创建不同但是相关类型的对象，由给定的参数来决定创建那种类型的对象
* 建造者模式用来创建一种类型复杂的对象，通过设置不同的可选参数，定制化的创建不同的对象

代理模式，React HOC 就是从这里借鉴来的，方式都是一样的，哈哈
* 属性代理：proxyHOC，利用的是委托机制
* 反向继承：inheritHOC，利用的继承机制

有用的装饰器模式
* 装饰类和原始类继承同样的父类，这样就可以对原始类嵌套多个装饰器类，Wrapper 模式的某一种场景
* 代理类附加的是更原始类无关的功能，而在装饰器模式中，附加的是跟原始类相关的增强功能

代理、桥接、装饰器和适配器的区别
* 笼统的来说，都可以称为 **Wrapper 模式**，也就是通过 Wrapper 类二次封装原始类
* 代理模式：在不改变原始类接口的条件下，为原始类定义个一个代理类，主要目的是访问控制，而非加强功能
* 桥接模式：将接口部分和实现部分分离，从而让他们可以较为容易、也相对独立的加以改变
* 装饰器模式：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用
* 适配器模式：一种事后补救策略，提供跟原始类不同的接口

实用的行为模式
* 观察者模式
* 模板模式：abstract class
* 策略模式：组合技能 = 定义策略接口 + 一组实现该接口的策略 + 工厂模式确定使用哪个接口
* 职责链模式：常用于开发过滤器，拦截器
* 备忘录模式
* 命令模式：常用与实现命令排队，撤销重做等

设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯的看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式

命令模式、策略模式、工厂模式
* 策略模式包含策略的定义、创建和使用三部分，代码结构上和工厂模式类似。区别在于策略模式侧重策略或者算法这个特定的应用场景，用于解决根据运行时状态从一组策略中选择不同策略的问题
* 工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，也可以是其他东西
* 策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换
* 命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换

查表法 提升性能神器
* K-V：用过 K 找值
* 数组：通过下标查找