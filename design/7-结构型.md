## 代理模式
代理模式：在不改变原始类（或者叫做被代理类）代码的情况下，通过引入代理类来给原始类附加功能。

为了将框架代码和业务代码解耦，代理模式就排上用场了。

原始的 Proxy 实现方式（静态代理）
* 代理类和原始类实现相同的接口，原始类只负责业务功能，代理类负责在业务逻辑执行的前后附加其他逻辑代码，并通过委托的方式调用原始类来执行代码
* 如果原始类没有定义接口，或者原始类并不是我们开发的，这时候我们可以采用继承的方式实现，通过 super 的方式来调用业务代码

但上述方式肯定是有问题的
1. 需要在代理类中，将原始类的所有的方法都要重新实现一遍，并且每个方法都附加相似的代码逻辑
2. 如果要添加附加功能的类不止有一个，需要针对每个类都要创建一个代理类，会导致类的个数成倍的增加，增加代码维护成本

这时候我们可以使用**动态代理**：我们不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类

> 在 Java 语言中，本身提供了动态代理的语法，依赖的就是 Java 的反射语法

代理类应用场景
1. 业务系统中的非功能性需求开发（监控、统计、鉴权、限流、事务、日志等）
2. RPC、缓存中的应用
  * RPC 也是一种代理模式，有一种说法叫做**远程代理**，通过远程代理，把网络通信、数据编解码等细节隐藏起来
  * 缓存应用：比如某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理：从配置文件中加载需要支持缓存的接口，以及响应的缓存策略，比如过期时间等，当请求到来的时候，在 AOP 切面中拦截请求，如果请求中带有支持缓存字段，便从缓存（内存缓存或者 redis 缓存等）中获取数据直接返回

## 桥接模式
桥接模式，也叫桥梁模式，Bridge Design Pattern。

目的：**将抽象和实现解耦，让它们可以独立变化**

另一个理解方式：**一个类存在两个（或多个）独立变化的维度，通过组合的方式，让这两个（或多个）维度可以独立进行扩展**。通过组合关系来替代继承关系，避免继承层次的指数级爆炸。非常类似与**组合优于继承**的设计原则

> 很多设计模式都是试图将庞大的类拆分成更细小的类，然后在通过某种更合理的结构组装在一起

弄懂定义中抽象和实现两个概念，是理解它的关键。

## 装饰器模式
装饰器也有组合的设计思想，用于避免继承爆炸的问题。Java IO 中就有装饰器的设计思想。

一段简单的 IO 代码
```java
InputStream in = new FileInputStream('path');
InputStream bin = new BufferedInputStream(in);
byte[] data = new byte[128];
while(bin.read(data) != -1) {}
```

你有没有思考过，为什么需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 来使用。为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedInputStream 呢。这样就可以这样使用，不是更简单吗
```java
InputStream in = new BufferedInputStream('path');
byte[] data = new byte[128];
while(bin.read(data) != -1) {}
```

如果只考虑到增强缓存读取的能力，那通过继承确实可以应付。但如果还需要对其他方面的增强，比如 DataInputStream 类，支持按照基本数据类型来读取数据。这时候又需要增加一个继承类，这还可以理解，但如果同时需要，就会导致更多的继承类。如果需要附加更多的功能，就会导致继承爆炸。

装饰器相对于简单的组合关系，还有两个比较特殊的地方
* 装饰类和原始类继承同样的父类，这样就可以对原始类嵌套多个装饰器类，比如如下的既支持缓存读取，又支持按照基本类型读取
  ```java
  InputStream in = new FileInputStream('path');
  InputStream bin = new BufferedInputStream(in);
  DataInputStream din = new DataInputStream(bin);
  int data = din.readInt()
  ```
* 装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点

> 代理类附加的是更原始类无关的功能，而在装饰器模式中，附加的是跟原始类相关的增强功能

## 适配器模式
Adapter Design Pattern：将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作

实现的两种主要方式
* 类适配器：通过继承关系来实现
* 对象适配器：通过组合关系来实现

具体例子：ITarget 表示要转换成的接口定义，Adaptee 是一组不兼容的 ITarget 接口定义的接口。Adaptor 将 Adaptee 转换成符合 ITarget 接口定义的接口
```java
public interface ITarget {
  void f1();
  void f2();
  void fc();
}

public class Adaptee {
  public void fa() {}
  public void fb() {}
  public void fc() {}
}

// 类适配器
public class Adaptor extends Adaptee implements ITarget {
  public void f1() {
    super.fa();
  }
  public void f2() {
    super.fb();
  }
}

// 对象适配器
public class Adaptor implements ITarget {
  private Adaptee adaptee;

  public Adaptor(Adaptee adaptee) {
    this.adaptee = adaptee;
  }

  public void f1() {
    this.adaptee.fa();
  }
  public void f2() {
    this.adaptee.f2();
  }
  public void fc() {
    this.adaptee.fc();
  }
}
```

实际开发该选择哪种方式呢
* 如果 Adaptee 接口并不多，那两种实现方式都可以
* 如果 Adaptee 接口很多，并且 Adaptee 和 ITarget 大致相同，则使用类适配器，因为可以复用父类的接口，代码量少一些
* 如果 Adaptee 接口很多，并且 Adaptee 和 ITarget 大部分不同，则使用对象适配器，因为组合更加灵活

常见的应用场景：**补偿模式，用来补救设计上的缺陷，应用这种模式算是无奈之举**
* 封装有缺陷的接口设计
* 统一多个类的接口：某个功能的实现依赖多个外部系统，通过适配器模式，将它们的接口适配为统一的接口定义
* 替换依赖的外部系统：将项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动
* 兼容老版本接口：将老接口标注为 deprecated，并将内部实现逻辑委托为新的接口实现
* 适配不同格式的数据

代理、桥接、装饰器和适配器的区别
* 笼统的来说，都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类
* 代理模式：在不改变原始类接口的条件下，为原始类定义个一个代理类，主要目的是访问控制，而非加强功能
* 桥接模式：将接口部分和实现部分分离，从而让他们可以较为容易、也相对独立的加以改变
* 装饰器模式：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用
* 适配器模式：一种事后补救策略，提供跟原始类不同的接口

## 门面模式
如何设计合理的接口粒度以兼顾接口易用性和通用性
* 为了保证接口的可复用性，需要尽量将接口设计得细粒度一点，职责单一一点
* 如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用 n 多细粒度的接口才能完成
* 如果接口粒度设计得太大，一个接口返回 n 多数据，要做 n 多事情，就会导致接口不够通用、可复用性不好，接口不可复用，那针对不同的调用者的业务需求，需要开发不同的接口来满足，就会导致系统的接口无限膨胀

门面模式，也叫做外观模式，英文全称是 Facade Design Pattern。门面模式为子系统以供一组统一的接口，定义一组高层接口让子系统更易用。

门面模式应用场景
* 解决易用性问题：封装底层实现，隐藏系统的复杂性
  * 设计原则、思想、模式很多时候都是相通的
  * 从隐藏实现复杂性，提供更易用接口的意图看，类似迪米特法则（最小知识原则）和接口隔离原则
  * 类似封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节
* 解决性能问题
  * 多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端响应速度
  * 代码组织问题
    * 如果门面接口不多，完全可以将它跟非门面接口放到一块，也不需要特殊标记，当做普通接口使用即可
    * 如果门面接口很多，可以在已有接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分
    * 如果门面接口特别多，并且很多都是跨多个子系统的，可以将门面接口放到一个新的子系统中
* 解决分布式事务问题
  * 创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功，一个失败
  * 要支持两个接口调用在一个事务中执行，很比较难的，涉及到分布式事务问题
  * 最简单的方式是，利用数据库事务或者 Spring 框架提供的事务，因此可以设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作

> 完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去

设计接口原则：**尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口**

## 组合模式
组合模式主要用来处理树形结构数据，一旦满足树形结构，应用这种模式就能发挥很大的作用，能让代码变得非常简洁。

定义：将一组对象组织成树形结构，以表示一种 "部分-整体" 的层次结构。组合让客户端（代码使用者）可以统一单个对象和组合对象的处理逻辑。

例子：
* 文件系统：File 类和 Directory 类
* OA 系统：部门和员工

组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树这种数据结构。

## 享元模式
英文名：Flyweight Design Pattern。

顾名思义就是被共享的单元，目的就是：复用对象，节省内存，前提是享元对象是不可变对象。

当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码**引用**，这样就可以减少内存中对象的数量，起到节省内存的目的。

不仅仅相同的对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分提取出来，设计成享元，让这些大量相似对象引用这些享元。

> 不可变对象指的是一旦通过构造函数初始化完成之后，它的状态就不会再被修改了。所以，不可变对象不能暴露任何 set 等修改内部状态的方法。之所以要求享元是不可变对象，因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码

享元的实现：**通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的**

享元 VS 单例、缓存、对象池
* 单例：一个类只能创建一个对象，而享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。享元是为了对象复用，节省内存
* 缓存：平时缓存主要时为了提高访问效率，而非复用
* 对象池：池化技术中的复用可以理解为重复使用，主要是为了节省时间。享元模式中的复用可以理解为共享使用，在整个生命周期中，都是被所有使用者共享的，主要目的是为了节省空间

扩展知识点：自动装箱和自动拆箱
* 自动装箱：自动将基本数据类型转换为包装器类型
* 自动拆箱：自动将包装器类型转换为基本数据类型

```java
Integer i = 56; // 自动装箱
// 相当于执行了
Integer i = Integer.valueOf(59);
int j = i; // 自动拆箱
// 相当于执行了
int j = i.intValue();
```

分析下面的代码
```java
Integer i1 = 56;
Integer i2 = 56;
Integer i3 = 129;
Integer i4 = 129;
System.out.println(i1 == i2)
System.out.println(i3 == i4)
```

答案不是两个 false，而是一个 true，一个 false。

上述奇怪现象的主要原因是：Integer 用到了享元模式来复用对象，才导致了这样的运行结构。当我们通过自动装箱，也就是调用 valueOf 创建 Integer 对象的时候，如果值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才会调用 new 方法创建

为什么只缓存 -128 到 127 之间的整数值呢。在 IntegerCache 的实现中，当类被加载的时候，缓存的享元对象会被集中一次性创建好，毕竟整型值太多了，我们不可能预先创建好所有的整型值，这样既占内存，也使得加载类时间过长。因此默认值选择缓存对于大部分应用来说最常用的整形值，也就是一字节的大小

因此对于平时开发中，对于下面三种创建整型对象的方式，优先使用后两种
```java
Integer a = new Integer(123);
Integer a = 123;
Integer a = Integer.valueOf(123);
```

跟 Integer 类的设计思路类似，String 类利用享元模式来复用相同的字符串常量。JVM 会开辟一块存储区来存储字符串常量，这块存储区叫做 "字符串常量池"

String 类的享元模式的设计，跟 Integer 稍微不同。Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。对于字符串而言，没法实现知道要共享哪些字符串常量，所以没办法实现创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。

需要注意的是：享元模式对 JVM 垃圾回收并不友好。因为享元工厂一直保存了对享元对象的引用，导致享元对象在没有任何代码使用的情况下，也并不会被 JVM 垃圾回收机制自动回收掉。

因此：某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元模式反倒可能会浪费更多的内存。