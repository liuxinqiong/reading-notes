## 模块含义
从广义的角度出发，解释为两方面
* 外部的模块：指代引入前端工程的某个外部的包，可能由多个 JS 文件组成，但会通过入口暴露给我们项目使用
* 内部的模块：指代我们自己的工程项目中编码的最小单元，即单个的文件

## 内部模块的组织
大致分为如下几个阶段
* 原生 JS 组织阶段
  * 将不同的 JS 文件在 html 中一一引入
  * 通过立即调用函数表达式，将每个模块包裹在一个函数作用域里面执行，这样就可以最大程度的避免污染全局执行环境
  * 通过执行匿名函数得到模块输出，暴露给其他模块使用
  * 存在的问题
    * 包含大量的 script 标签
    * script 标签的先后顺序并不能很好的契合模块间的依赖关系
    * 仍然会因为全局变量污染全局环境，导致命名冲突
* 在线处理阶段：等到用户浏览 web 页面下载了对应的 require.js 和 sea.js 文件之后，才开始进行模块分析，确定加载顺序和执行顺序
  * 代表的模块化规范 AMD/CMD
  * AMD（Asynchronous Module Definition），即异步模块定义，一种组织前端模块的方式
    * define 用于定义一个模块，require 用于真正执行模块
    * AMD 框架会以 require 方法作为入口，进行依赖关系分析并依次有序地进行加载
    * 去除了纯粹用 script 标签顺序组织模块带来的问题
      * 通过依赖数组的方式声明依赖关系，具体依赖的加载交给具体 AMD 框架处理
      * 避免声明全局变量带来的环境污染和变量冲突问题
      * 异步加载，防止加载 JS 阻塞页面渲染
  * CMD（Common Module Definition），意为通用模块定义
    * 不同于 AMD，没有提供前置的依赖数组，而是接受一个 factory 函数，包括 3 个参数
      * require 一个方法标识符，调用它可以动态获取一个依赖模块的输出
      * exports：一个对象，用于对其他模块提供输出接口
      * module：一个对象，存储了当前模块相关的一些属性和方法
    * 与 AMD 区别
      * 在依赖处理上，AMD 推崇依赖前置，通过依赖数组的方式提前声明当前模块，CMD 推崇依赖就近，在编程需要用到的时候通过调用 require 方法动态引入
      * 在对外输出上，AMD 推崇通过返回值的方式对外输出，CMD 推崇通过 module.exports 赋值的方式对外输出
    * sea.js 是遵循 CMD 规范实现的模块加载器，更准确的说法是，CMD 正是在 sea.js 推广的过程中逐步确立的规范，并不是 CMD 诞生了 sea.js，而 sea.js 诞生了 CMD
    * 背后实现原理
      1. 解析 define 接受方法体内 require 调用
        1. 通过正则匹配获取字符串中的 require 中的参数并存出到数组中返回
        2. 通过 toString 将 define 接收的方法转化为字符串，调用上面定义的解析，从而得到一个 define 方法里面所有的依赖模块的数组
      2. sea.js 执行的时候，会从入口开始遍历依赖模块，并以此将他们加载到浏览器中
        1. 定义 request 请求资源的方法，注册 onload 事件
        2. onload 方法中，sea.js 会设置一个技术变量 remain，用来计算依赖是否加载完毕，每加载完一个就值行 remain - 1，并通过 remain === 0 判断依赖是否执行完毕
        3. 全部执行完毕就执行 mod.callback 方法
      3. 将输出传递给 use 方法回调
* 预处理阶段：CommonJS && ES6
  * 最开始的时候，并不能在前端页面中使用它们，因为浏览器并不能理解这种语法
  * babel 帮助我们能够使用符合开发需求的编程风格去编写代码，然后通过编译转换成对浏览器兼容良好的 JS
    * Parse（解析）：通过词法分析和语法分析，将源代码解析成抽象语法树 AST
    * Transform（转换）：对解析出来的抽象语法书做中间转换处理
    * Generate（生成）：用经过转换后的抽象语法树生成新的代码
  * 解决了在线编译存在的问题
    * 在线组织的方式会延长前端页面的加载时间，影响用户体验
    * 加载过程中发出了海量的 http 请求，降低了页面性能
  * 于是开发了一个工具
    * 让他把组织模块的工作提前做好，在代码部署上线前就完成，从而解决页面加载时间
    * 使用工具进行代码合并，把多个 script 的代码合并到少数几个 script 里，减少 http 请求数量
  * 最典型的代码有：browserify（2011） 和 webpack（2012），最初的定位都是通过预先打包的方式，把前端项目里面的多个文件打包成单个文件或少数几个文件，减少首次页面访问时的 http 请求数量，从而提高性能
  * 面临的问题 && 解决方案
    * 打包后单个代码体积过大，webpack 引入了代码拆分功能（Code splitting），从全部打包后退一步，可以打包成多个包
    * Code splitting 主要带来两个作用
      * 实现第三方库和业务代码分离，因为第三方库更新频率是比较慢的，分离后可以有效利用浏览器缓存，通过 CommonChunkPlugin 完成
      * 按需加载，通过动态 import 实现
* 自动构建阶段
  * 目标：在开发流程中给开发者最大的自由度和便捷性，同时在生产流程中能保证浏览器兼容性和良好性能的工具
  * 不再满足于打包，渴望做更多事情
    * 开发时使用丰富且方便的 JS 新特性，比如 ES6、typescript，由自动化构建工具转化成浏览器兼容的 ES5 格式的 JS 代码
    * 用 Sass、less 编写阅读性和扩展性良好的样式代码，由构建工具转化成浏览器兼容的 CSS 代码
    * 提供开发时的 SourceMap 功能，即提供生产代码到源代码的映射，方便开发调试
    * 提供生产时代码压缩功能，压缩 js 和 css，删除注释，替换变量名，从而减少体积
    * 提供开发热重载功能
    * 其他……
  * 代表工具：gulp、grunt、webpack
    * gulp 是编程式的自动化构建工具，通过 pipe 方式进行链式加工处理
    * webpack 是配置式的自动化构建工具，通过 loader 机制实现文件的编译转化，每个 loader 会被链式调用
    * 均没有自己完成所有的功能，而是搭建一个平台，吸引世界各地开发者贡献插件，并构建起来一个繁荣生态
* 新趋势：bundleless
  * 最初 webpack 采用集中打包的方式，主要有如下原因
    * 浏览器兼容性还不够好，没有提供对 ES6 的足够支持，需要把每个 JS 文件打包成单一 bundle 中的闭包的方式实现模块化
    * 合并请求，减少 http/1.1 过多并发请求带来的性能问题
  * 发展到今天，问题得到很大缓解
    * 主流浏览器已经充分支持 ES6 了，import 和 export 均可使用
    * HTTP2.0 普及后并发请求的性能问题没有那么突出了
  * bundleless 就是把开发中拖慢速度的打包工作给去掉，从而获得更快的开发速度，代表工具是 vite 和 snowpack
