两个问题
* the difference about the rotate in three.js
* draw 2D shape with a hole


## rotate in three.js
在 three.js 中实现旋转的几种方式
* rotation：物体的局部旋转
* rotateY：物体的局部旋转，rotateY(rad) = rotation.y += rad
* rotateOnAxis：根据局部空间的标准化向量旋转，可自行指定任意空间
* rotateOnWorldAxis：根据世界空间的标准化向量旋转

确定参考点以及方向向量
* 参考点 align point 无论如何都是物体的 position 属性
* 具体方向看具体使用方式
  * rotateOnAxis 参考局部空间，自身是否存在平移、旋转
  * rotateOnWorldAxis 参考世界空间

项目中奇怪的现象就可以解释了
* 由于要配合大地旋转，因此对象也需要旋转 90 度，元素之间可能有层级的高度差。元素设置 Z 后，于此同时元素也旋转 90 度添加到场景不符合预期，但给每个元素套一个 Group 后就正常了
* 原因就处在参考点上，直接添加对象，对于旋转和平移都作用在物体上，它的参考点是物体自身的 position。套用 Group 后，旋转作用在 Group 上，同时 Group 的参考点默认是原点
* ……，好好思考吧，描述不清了

## draw a hole
```
// A-------------B     A(0,0), B(100,0), C(100,100), D(0,100)
// |      E      |     E(50,10), F(10,90), G(90,90)
// |     / \     |     H(50,90), I(50,100)
// |    /   \    |
// |   /     \   |
// |  F---H---G  |
// D------I------C
```

在 2D 图形中绘制带洞的多边形办法
* 覆盖绘制 overpainting
  * 优势：简单好理解
  * 劣势：如果背景发生改变，则不会生效。存在多余的绘制，在绘制较多图形时会有性能问题
* 欺骗法：通过拆分线段的方式，绘制为简单图形，比如上面的图形可以这么做：ABCI > HGEFH > IDA
  * 避免了覆盖绘制导致的背景色生效问题
  * 会导致额外的边，如果你需要给描边时问题就暴露出来了。同时由于精度问题，可能导致缝隙
* 环绕计数
  * 利用 nonzero 的判断规则
  * 优势：真正意义上的画一个一个带洞的形状
  * 劣势：必须保证顺时针和逆时针规则
* evenodd 规则
  * 优势：比计数规则更好理解
  * 在某些情形，计数规则会有更好的结果
* 裁剪区域
  * 利用裁剪规则
  * 优势：裁剪区域可以裁剪非常复杂的形状
  * 劣势：需要做很多的额外工作

> 推荐利用填充规则去解决这个问题

填充规则
* nonzero default
  * 用于判断该点属于该形状的内部还是外部
  * 从该点向任意方向的无限远处绘制射线，然后检测形状与射线相交的位置。从 0 开始统计，路径上每一条从左到右（顺时针）跨过射线的线段都会让结果加 1，每条从右向左（逆时针）跨过射线的线段都会让结果减 1。当统计结束后，如果结果为 0，则点在外部；如果结果不为 0，则点在内部。
* evenodd
  * 用于判断该点属于该形状的内部还是外部
  * 从该点向任意方向无限远处绘制射线，并统计这个形状所有的路径段中，与射线相交的路径段的数量。如果有奇数个路径段与射线相交，则点在内部；如果有偶数个，则点在外部。

相关资料
* [5 ways to draw a 2D shape with a hole in CoreGraphics](https://www.cocoawithlove.com/2010/05/5-ways-to-draw-2d-shape-with-hole-in.html)
* [Polygon with a hole in the middle with HTML5's canvas](https://stackoverflow.com/questions/13618844/polygon-with-a-hole-in-the-middle-with-html5s-canvas)