TypeScript 进阶

## 资料
* [了不起的 TypeScript 入门](https://juejin.im/post/6844904182843965453)
* [一文读懂 TypeScript 泛型及应用](https://juejin.im/post/6844904184894980104)
* [TypeScript 入门教程](https://ts.xcatliu.com/)
* [React+TypeScript Cheatsheets](https://github.com/typescript-cheatsheets/react)

定义一套接口格式和错误处理的规范，当失败时统一提示错误，代码只需考虑成功即可，具体格式
* success：表示是否成功，为 false 时按照 showType 和 errorMessage 做统一的错误提示，同时抛出异常
* data：响应数据
* errorCode：自定义的错误编码
* errorMessage：提示给用户的错误信息
* showType：错误信息的提示方式
  * silent：表示静默，不提示
  * message.warn：警告类消息提示
  * message.error：错误类消息提示
  * notification：通知类型
  * page：显示个错误页面，比如直接跳转到 /exception 页面
* traceId：唯一的请求 ID，方便后端进行错误排查
* host：当前访问的服务，也是为了后端进行错误排查

不同的用户权限不同，通常有如下场景
* 不同的用户在页面中可以看到的元素和操作不同
* 不同的用户对页面的访问权限不同

不同的控制级别
* 执行权限控制
* 渲染权限控制
* 路由权限控制

页面内的权限控制
* useAccess hook、Access 组件
* useAccess 获取权限定义，返回是否有某权限
* Access 有 accessible 和 fallback，用于页面元素的显示和隐藏的控制

路由和菜单的权限控制
* 路由定义中添加 access 属性绑定权限定义中的 key
* 权限路由控制相关的函数，接收当前处理的路由作为第一参数
* 如果值为 false，该路由会从菜单移除，通过 URL 访问对应路由，将看到一个 403 页面

TypeScript
* declare module/namespace
* d.ts 结尾的文件会被 TypeScript 默认导入到全局，但是其中不能使用 import 语法，如果需要引用需要使用三斜杠。

权限相关：plugin-access
* 获取权限相关的初始化信息
* 创建权限定义文件

ESLint 指定配置的方式
1. 通过单独的命名为 .eslintrc.* 文件
2. 通过 package.json 中的 eslintConfig 字段

那么如果同时设置两个，会有什么效果呢。优先级问题如何确定呢

为了社区的规范化，ESLint 对于配置文件以及插件等，还有一定的命名约束
* 使用 extends 继承已有配置时，约定使用 `eslint-config-` 作为前缀
* 插件机制使用，约定使用 `eslint-plugin-` 作为前缀
* 在具体配置时候，你可以自己选择是否加上前缀，ESLint 会自动格式化（判断有没有添加前缀，没有则自动加上）

> 简单阅读 ESLint 源码的过程中发现，针对 plugin 的配置，ESLint 还判断了是不是 `eslint:` 或 `plugin:` 开头，是的话会跳过格式化，暂没深究目的和原因

回到如果同时设置多个配置文件，ESLint 会怎么处理，以及优先级别的问题。大致可以在 config-array-factory.js 中得知。

关于配置文件的定义如下
```js
const configFilenames = [
    ".eslintrc.js",
    ".eslintrc.cjs",
    ".eslintrc.yaml",
    ".eslintrc.yml",
    ".eslintrc.json",
    ".eslintrc",
    "package.json"
];
```

官方文档中提到，如果在同一个目录存在多个配置文件，ESLint 只会使用一个，具体优先级顺序就是上面数组的定义顺序，.eslintrc.js 优先级最高，package.json 优先级最低

如果在不同目录层级，存在多份配置文件，则被校验的文件，会优先使用离它最近的文件，然后才是使用父目录的配置文件。这句话具体解释为：被校验的文件会基于两个配置的组合，如果存在冲突，则离得最近的优先级更高。

为了将 ESLint 限制到一个特定的项目，可以在配置中使用 root 字段，ESLint 一旦发现配置文件中有 "root": true，它就会停止在父级目录中寻找。

extends 属性值
* 指定配置的字符串
* 字符串数组：每个配置继承它前面的配置
* ESLint 会递归的扩展配置

event.stopPropagation() 的误解
* 由于事件分为冒泡阶段和捕获阶段，很容易误解成只能用于冒泡阶段，这是错误的，捕获阶段也可以使用，建议理解成向上/向下冒泡
* 正确定义阻止捕获和冒泡阶段中当前事件的进一步传播。

突然思考，for 语句的判断部分，右侧语句如果是个表达式，会多次执行吗
* 编译器一般没办法对函数进行优化，因为调用函数的效果是很难确定的，也就是它会反复调用多次的
* 对于在编译期就可计算出的，编译器会优化，否则不会优化

setStateOnNextFrame

jest 测试异步代码
* 使用 done 参数
* 返回 Promise 对象
* 使用 resolves/rejects 匹配器
* 使用 Async/Await 关键字

有时代码中会使用 setTimeout 创建定时器，jest 直接提供的 Timer Mocks 供使用
* 在 test 文件中使用 jest.useFakeTimers();
* 通过下述方式执行 Timers
  * jest.runAllTimers();
  * jest.runOnlyPendingTimers();
  * jest.advanceTimersByTime(ms);
* 通过 jest.clearAllTimers() 清空定时器

video.js vs video tag
* video.js 有更好的以及统一的外观、控制能力
* video.js 支持降级成 flash 播放
* video.js 修复了浏览器的不一致性
* video.js 通过插件的方式支持播放 HLS、DASH、360 视角、直播以及全景
* 其他特性：全屏、字幕
* 其他播放器的支持：TouTube、QuickTime


why fabric.js
* SVG parser
* 复杂对象模型
  * 均继承自：fabric.Object
    * setCoords
  * 7 种基本图形：fabric.Circle、fabric.Ellipse、fabric.Line、fabric.Polygon、fabric.Polyline、fabric.Rect、fabric.Triangle
  * 常见属性（get、set 机制）
    * 位置：left、top
    * 尺寸：width、height
    * 显示：fill、opacity、stroke、strokeWidth
    * 缩放与选择：scaleX、scaleY、angle
    * 翻转：flipX、flipY
  * 图片类：fabric.Image | fabric.Image.fromURL
  * 复杂图形：Path 和 PathGroup
    * Path 规则如同 SVG path
    * fabric.loadSVGFromString | fabric.loadSVGFromURL
* 图层交互
  * 如果不需要该功能，可直接使用 fabric.StaticCanvas 类
  * 分组管理
  * 事件机制
  * 内置图形操作交互（拖动、缩放、旋转等）

fabric.js 基础
* 画布原点：左上角
* fabric.Canvas 类
  * 管理所有的 objects
  * 画布配置中心：画布颜色、背景图、前置图
  * 相关 api
    * renderAll
    * add/remove
    * setBackgroundImage
    * setOverlayImage
    * calcViewportBoundaries 视窗大小
* 缓存机制
  * fabric 会将 canvas 节点转变成两个 canvas
  * 一个 upper-canvas 负责绘制作为缓存，lower-canvas 负责显示，使用 drawImage 将 upper-canvas 画到 lower-canvas
* 坐标相关
  * left、top、originX、originY

fabric.js 进阶
* 动画机制：object.animate(property, value, options)
* fabric.Image
  * 滤镜功能：filter 属性
* fabric.Color
  * 支持多种格式
  * 格式之间转换
  * 颜色之间转换
* 支持渐变
  * object.setGradient
* fabric.Text
  * object 的完整性
  * 相比原生，支持更丰富的配置
* 事件机制
  * on/off
  * 事件分类
    * 通用类：after:render
    * 鼠标类：mouse:down | mouse:move | mouse:up
    * 选择类：before:selection:cleared | selection:created | selection:cleared
    * 物件类：object:modified | object:selected | object:moving | object:scaling | object:rotating | object:added | object:removed
  * 其他常规事件类似于 dom 事件，但使用冒号分割
  * 事件参数：{ e: Event, target: fabric.Object }
* 分组机制
  * 将一组对象当做一个单元进行统一管理
  * 进行选择是，fabric 会隐式将选择的物件创建一个分组
  * 常用 api
    * getObjects
    * size
    * forEachObject
    * item
    * add/addWithUpdate
    * remove/removeWithUpdate
  * 通常推荐使用 addWithUpdate/removeWithUpdate（会更新尺寸和位置），除非你在进行批处理或者 group 有错误的宽高也无妨
* 序列化与反序列化
  * 序列化：toObject/toJSON/toSVG/toDatalessJSON
    * toDatalessJSON 通过链接 SVG 的方式简化数据表达
  * 通过将物件的 excludeFromExport 设置为 true，则物件不会被序列化
  * 反序列化：fabric.Canvas#loadFromJSON | fabric.Canvas#loadFromDatalessJSON | fabric.loadSVGFromURL | fabric.loadSVGFromString

fabric.js 更多
* 自由绘制
  * 画布设置 isDrawingMode 为 true 即可
  * 每次绘制都是一个 fabric.Path 实例，通过 path:created 事件通知
  * 支持设置 color 以及 width
* 定制化
  * 锁定功能：比如锁定某方向的平移、旋转或缩放
  * 定制边框、角点：是否显示颜色、点密度、大小等
  * 禁用选取：设置 selectable 为 false 即可
  * 定制选取效果：选择颜色、边框颜色、边框大小、虚线点密度
  * 设置先为虚线：strokeDashArray
  * 定制可点击区域
    * 默认是外边框
    * 通过 perPixelTargetFind 为 true 指定为仅限实际物体
  * 定制旋转点
  * 是否启动对象的非均匀缩放
* 常用实现
  * zoom：沿中心点还是鼠标点
  * pan：区分选取还是平移
  * rotate
* 其他
  * clipPath 实现裁剪

fabric.js transform
* Canvas
  * viewportTransform = matrix：canvas 的状态矩阵
* Objects
  * matrix = fabric.Object.prototype.calcTransformMatrix()：获取该图形对象的状态矩阵，可用于相对 object 的坐标到相对 canvas 坐标的转换
  * matrix = fabric.Object.prototype.calcOwnMatrix()
* Utils
  * point = fabric.util.transformPoint(point, matrix)：执行的就是下面的公式
  * matrix = fabric.util.multiplyTransformMatrices(matrix, matrix)
  * matrix = fabric.util.invertTransform(matrix)：求逆矩阵，A 点通过矩阵转换到 B，B 可通过逆矩阵还原到 A
  * options = fabric.util.qrDecompose(matrix)：对矩阵进行 qr 分解，求得该图形对象此时的状态（相对于初始状态缩放、旋转、平移），一个可能解
* 基础知识
  * 2 * 3 矩阵，行 * 列，坐标点均表示成 （x, y, 1）
  * 单位矩阵：如同数的乘法1，行数和列数相等，从左上角到右下角的对角线（称为主对角线）上的元素均为1。除此以外全都为0。
  * 对称矩阵：以主对角线为对称轴，各元素对应相等的矩阵，对称矩阵是一个方形矩阵，其转置矩阵和自身相等。
  * 旋转是 scale 和 skew 的组合
  * 逆矩阵：逆矩阵与原矩阵相乘等于单位举证，任何矩阵乘以单位矩阵的结果都是其本身。可用于实现矩阵的除法，针对 2 * 2 的计算
    1. 交换主对角线位置
    2. 副对角线取反
    3. 点乘关键表达式：1 / (主对角线乘积 - 负对角线乘积)，如果分母为 0 则可能没有逆矩阵
  * 矩阵乘法
    * AB != BA

```js
// 2 * 3 矩阵表示
[
  a, b,
  c, d,
  tx, ty
]
// 2 * 3 矩阵含义
[
  x(scale), y(skew),
  x(skew), y(scale),
  x(position), y(position)
]

// 选择矩阵
[
  cos(angle), sin(angle),
  -sin(angle), cons(angle),
  0, 0
]

// 矩阵计算公式
x' = x*a + y*c + tx
y' = x*b + y*d + ty
```

Doc Of
* fabric.Canvas
* fabric.Object

then vs catch vs finally

首先看 then、onrejected 和 catch 联系与区别
* onrejected 会在 Promise 异常或者 reject 的时候被调用，在提供了 onrejected 函数的前提下，后续的 catch 不会被调用，可以理解成错误已经被处理
* Promise 的抛错具有冒泡性，如果没有被处理，则能够不断传递，这样就能在下一个 catch 中统一处理，事实上 catch(onRejected) 从内部调用了 then(undefined, onRejected)
* 联系：如果 Promise 被 reject 掉，则 onrejected 和 catch 的参数为 reject 的值。如果是因为异常，则会是异常对象
* then 和 catch 都可以返回一个新的 Promise 对象，可以链式调用
* finally 本身无异常抛出的情况下，总是会返回原来的 Promise 对象值，若抛出异常，则返回异常的 Promise 对象

yield 报错后不再进入问题