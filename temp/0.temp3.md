why fabric.js
* SVG parser
* 复杂对象模型
  * 均继承自：fabric.Object
    * setCoords：基于 width、height、angle 重新计算外接矩形的四个角点
    * left、top：物体左上角起始坐标，可以通过 originX、originY 该点是中心或是四周某个点
    * originX、originY：可理解成绘制物体的原点，默认为 left、top。originX 值有 left/right/center，originY 值有 top/bottom/center
  * 7 种基本图形：fabric.Circle、fabric.Ellipse、fabric.Line、fabric.Polygon、fabric.Polyline、fabric.Rect、fabric.Triangle
  * 常见属性（get、set 机制）
    * 位置：left、top
    * 尺寸：width、height
    * 显示：fill、opacity、stroke、strokeWidth
    * 缩放与选择：scaleX、scaleY、angle
    * 翻转：flipX、flipY
  * 图片类：fabric.Image | fabric.Image.fromURL
  * 复杂图形：Path 和 PathGroup
    * Path 规则如同 SVG path
    * fabric.loadSVGFromString | fabric.loadSVGFromURL
* 图层交互
  * 如果不需要该功能，可直接使用 fabric.StaticCanvas 类
  * 分组管理
  * 事件机制
  * 内置图形操作交互（拖动、缩放、旋转等）

fabric.js 基础
* 画布原点：左上角
* fabric.Canvas 类
  * 管理所有的 objects
  * 画布配置中心：画布颜色、背景图、前置图
  * 相关 api
    * renderAll
    * add/remove
    * setBackgroundImage
    * setOverlayImage
    * calcViewportBoundaries 视窗大小
    * absolutePan：移动视口，默认在左上角
    * relativePan：移动视口，相对当前视口
    * dispose：清除 canvas 元素，且移除所有事件监听
    * clear：清除所有上下文（background、main、top）
    * requestRenderAll：合并所有 render 请求
    * renderAll：render top and secondary
    * renderTop：常用于渲染选择框
    * calcViewportBoundaries：计算画布的四个角点
* 缓存机制
  * fabric 会将 canvas 节点转变成两个 canvas
  * 一个 upper-canvas 负责绘制作为缓存，lower-canvas 负责显示，使用 drawImage 将 upper-canvas 画到 lower-canvas

fabric.js 进阶
* 动画机制：object.animate(property, value, options)
* fabric.Image
  * 滤镜功能：filter 属性
* fabric.Color
  * 支持多种格式
  * 格式之间转换
  * 颜色之间转换
* 支持渐变
  * object.setGradient
* fabric.Text
  * object 的完整性
  * 相比原生，支持更丰富的配置
* 事件机制
  * on/off
  * 事件分类
    * 通用类：after:render
    * 鼠标类：mouse:down | mouse:move | mouse:up
    * 选择类：before:selection:cleared | selection:created | selection:cleared
    * 物件类：object:modified | object:selected | object:moving | object:scaling | object:rotating | object:added | object:removed
  * 其他常规事件类似于 dom 事件，但使用冒号分割
  * 事件参数：{ e: Event, target: fabric.Object }
* 分组机制
  * 将一组对象当做一个单元进行统一管理
  * 进行选择是，fabric 会隐式将选择的物件创建一个分组
  * 常用 api
    * getObjects
    * size
    * forEachObject
    * item
    * add/addWithUpdate
    * remove/removeWithUpdate
  * 通常推荐使用 addWithUpdate/removeWithUpdate（会更新尺寸和位置），除非你在进行批处理或者 group 有错误的宽高也无妨
* 序列化与反序列化
  * 序列化：toObject/toJSON/toSVG/toDatalessJSON
    * toDatalessJSON 通过链接 SVG 的方式简化数据表达
  * 通过将物件的 excludeFromExport 设置为 true，则物件不会被序列化
  * 反序列化：fabric.Canvas#loadFromJSON | fabric.Canvas#loadFromDatalessJSON | fabric.loadSVGFromURL | fabric.loadSVGFromString

fabric.js 更多
* 自由绘制
  * 画布设置 isDrawingMode 为 true 即可
  * 每次绘制都是一个 fabric.Path 实例，通过 path:created 事件通知
  * 支持设置 color 以及 width
* 定制化
  * 锁定功能：比如锁定某方向的平移、旋转或缩放
  * 定制边框、角点：是否显示颜色、点密度、大小等
  * 禁用选取：设置 selectable 为 false 即可
  * 定制选取效果：选择颜色、边框颜色、边框大小、虚线点密度
  * 设置先为虚线：strokeDashArray
  * 定制可点击区域
    * 默认是外边框
    * 通过 perPixelTargetFind 为 true 指定为仅限实际物体
  * 定制旋转点
  * 是否启动对象的非均匀缩放
* 常用实现
  * zoom：沿中心点还是鼠标点
  * pan：区分选取还是平移
  * rotate
* 其他
  * clipPath 实现裁剪

fabric.js 仿射变换
* Canvas
  * viewportTransform = matrix：canvas 的状态矩阵
* Objects
  * matrix = fabric.Object.prototype.calcTransformMatrix()：获取该图形对象的状态矩阵，可用于相对 object 的坐标到相对 canvas 坐标的转换
  * matrix = fabric.Object.prototype.calcOwnMatrix()
* Utils
  * point = fabric.util.transformPoint(point, matrix)：执行的就是下面的公式
  * matrix = fabric.util.multiplyTransformMatrices(matrix, matrix)
  * matrix = fabric.util.invertTransform(matrix)：求逆矩阵，A 点通过矩阵转换到 B，B 可通过逆矩阵还原到 A
  * options = fabric.util.qrDecompose(matrix)：对矩阵进行 qr 分解，求得该图形对象此时的状态（相对于初始状态缩放、旋转、平移），一个可能解
* 基础知识
  * 2 * 3 矩阵，行 * 列，坐标点均表示成 （x, y, 1）
  * 单位矩阵：如同数的乘法1，行数和列数相等，从左上角到右下角的对角线（称为主对角线）上的元素均为1。除此以外全都为0。
  * 对称矩阵：以主对角线为对称轴，各元素对应相等的矩阵，对称矩阵是一个方形矩阵，其转置矩阵和自身相等。
  * 旋转是 scale 和 skew 的组合
  * 逆矩阵：逆矩阵与原矩阵相乘等于单位矩阵，任何矩阵乘以单位矩阵的结果都是其本身。可用于实现矩阵的除法，针对 2 * 2 的计算
    1. 交换主对角线位置
    2. 副对角线取反
    3. 点乘关键表达式：1 / (主对角线乘积 - 负对角线乘积)，如果分母为 0 则可能没有逆矩阵
  * 矩阵乘法
    * AB != BA

```js
// 2 * 3 矩阵表示
[
  a, b,
  c, d,
  tx, ty
]
// 2 * 3 矩阵含义
[
  x(scale), y(skew),
  x(skew), y(scale),
  x(position), y(position)
]

// 旋转矩阵
[
  cos(angle), sin(angle),
  -sin(angle), cons(angle),
  0, 0
]

// 矩阵计算公式
x' = x*a + y*c + tx
y' = x*b + y*d + ty
```

Doc Of
* fabric.Canvas
* fabric.Object

关于画布旋转：https://github.com/fabricjs/fabric.js/issues/2382

Three.js 矩阵变换

为什么需要矩阵
* 理论上讲我们的确可以只通过数学公式就能实现变换，但实际的情况却是在变换十分复杂时，直接使用数学表达式来进行运算也是相当繁复的
* 在现实中常常使用矩阵（由m × n个标量组成的长方形数组）来表示诸如平移、旋转以及缩放等线性变换
* 一个更有趣的事实是，当两个变换矩阵A和B的积为P=AB时，则变换矩阵P相当于A和B所代表的变换。矩阵乘法不符合交换律，因此AB和BA并不相等

> 矩阵与向量的乘法：横 * 竖

为什么 Three.js 使用 4*4 矩阵
* 使用 3*3 矩阵可以搞定旋转变换，但却解决不了平移问题
* 因为平移表达式中带有一个常量，没有办法使用 `3*3` 的矩阵来表示平移。解决办法就是使用 `4*4` 矩阵实现，随之而来的问题就是如何让三维坐标和 4*4 矩阵相乘呢
* 为了解决三维矢量和 4*4 矩阵相乘的问题，我们为三维矢量添加了第四个分量，这样之前的三维矢量 (x,y,z) 就变成了四维的 (x,y,z,w)，这样由 4 个分量组成的矢量便被称为齐次坐标。需要说明的是，齐次坐标 (x,y,z,w) 等价于三维坐标 (x/w,y/w,z/w)，因此只要 w 分量的值是 1，那么这个齐次坐标就可以被当作三维坐标来使用，而且所表示的坐标就是以 x，y，z 这 3 个值为坐标值的点。

Object3D 矩阵相关属性
* matrix 局部变换矩阵
* matrixAutoUpdate 将计算每一帧的位移、旋转和缩放矩阵，并重新计算 matrixWorld 属性，如果你希望在重新计算时手动控制，则可以通过将属性设置为 false 来获得更好的性能，更改任何属性后，调用 updateMatrix 手动更新矩阵
* matrixWorld 物体的世界变换，如果没有父级，则它和局部变换矩阵 matrix 相同
* matrixWorldNeedsUpdate 当这个属性设置了之后，它将计算在那一帧中的 matrixWorld，并将这个值重置为 false
* quaternion 表示对象局部旋转的四元数
* rotation 物体的局部旋转，以弧度来表示
* applyMatrix4(matrix: Matrix4) 对当前物体应用变换矩阵，并更新物体的位置、选择和缩放
* applyQuaternion(quaternion: Quaternion) 对当前物体应用由四元数所表示的变换
* localToWorld(vector: Vector3) 将向量从物体的局部空间转换到世界空间
* worldToLocal(vector: Vector3) 将该向量从世界空间转换到物体的局部空间
* setRotationFromEuler(euler: Euler)
* getWorldPosition(target: Vector3)
* getWorldQuaternion(target: Quaternion)
* getWorldScale(target: Vector3)
* updateMatrix()
* updateMatrixWorld()
* updateWorldMatrix()

欧拉角：Euler(x, y, z, order)，x/y/z 分别表示在对应轴上的旋转量，用弧度表示。order 表示顺序，默认为 XYZ

> 欧拉角存在万向锁问题：当三个万向节其中两个的轴发生重合时，会失去一个自由度的情形。

四元数的出现就可以解决欧拉角的万向锁问题和万向锁带来的插值不是线性的问题。同时比起三维正交矩阵表示，四元数表示能够更方便地给出旋转的转轴与旋转角。