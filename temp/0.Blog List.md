## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

dva dispatch yield 生成器函数异常中断，无法继续调用
* 在生成器函数中，哪怕是一点报错。都会导致程序无法再次执行。这是 yield 的特性导致的
* 解决方式将所有报错回避，并做好错误交互，比如多判断变量合法性或使用 try-catch

how to use webworker in cra：workerize-loader

k8s/jenkins/docker/heml

## React 18
React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 声明性地指定组件树的某个部分的加载状态，React18 支持了服务端渲染，对于 SSR 非常友好
  * 适合与 transition API 结合使用，如果你在 transition 过程中挂起（suspend）了，React 将会阻止已经可见的内容被 fallback 替换，React 会延迟渲染直到数据加载完毕，避免糟糕的加载状态
* 自动批量更新（automatic batching）
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的 UI 更新。
  * 紧急更新：直观的交互，如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹，ui 状态从 A 状态切换到 B 状态。被 startTransition 回调包裹的 setState 触发的渲染被标记为不紧急的渲染，这些渲染可能被其他紧急渲染所抢占
* SuspenseList
  * 用于控制多个 Suspense 同时存在时的展示顺序和展示方式
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* hooks
  * useId：调用组件内返回唯一的 id
  * useTransition：允许你非阻塞式的更新状态，通过 isPending 可判断 transition 是否在进行中。搭配 Suspense 使用，还可以避免 fallback 的显示
  * useDeferredValue 返回一个延迟响应的值。例如一个过滤列表的场景，可以针对列表使用 useDeferredValue 传入输入框对应的值，在与 Suspense 集成时，如果值的更新挂起了 UI，则不会看见 fallback，而是看见旧值。也可用于做性能优化，由于是延迟响应的值，通过 memo 配合，可以延迟一部分 UI 的渲染
  * useSyncExternalStore：用于订阅外部存储，用于将外部状态同步到组件内，大部分情况下推荐下 useState、useReducer 实现，改 api 在集成已存在的非 React code 时十分有用
  * useInsertionEffect：useEffect 另一个版本，为 CSS-in-JS 库提供的钩子，发生在 DOM 修改之前
  * 新的 startTransition 与 useDeferredValue API，本质上都是允许你将 UI 的一部分标记为较低的更新优先级。

函数式组件与类组件有何不同
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

重点：**时间切片、Suspense、并发模式（Concurrent）**

Vue Hook 不同之处
* 对调用顺序没有要求，由于渲染机制的不同，不会反复调用 Hook 函数，产生的的 GC 压力较小。
* 不用总是考虑 useCallback 的问题，因为模板解析内部会新建 cache 缓存函数，缓存函数内部进行函数调用，因此写内联函数也没关系
* 没有闭包问题，Vue 内部自动依赖关系跟踪确保观察者和计算值始终正确无误

渲染性能优化上的不同
* Vue 抛弃 time slice，模板中区分动态节点和静态节点。事件监听缓存，从而避免不必要子组件更新。运行时特性支持 tree-shaking，没用到的特性代码会被移除
* React 走了另一条道路，既然是 diff 导致问题卡顿，从 CPU 调度的方式解决问题，利用浏览器的空闲时间来做 diff，如果超过了 16ms，有动画或者用户交互的任务，就把主进程控制权还给浏览器，等空闲了继续

支持 SSR 常见问题
* DOM/BOM 缺失
  * 将 DOM/BOM 的访问放在 useEffect/useLayoutEffect 中运行
  * 通过 isBrowser 判断
* useLayoutEffect Warning
  * 根据环境动态指定使用 useLayoutEffect 还是 useEffect
* 对于接收 DOM/BOM 属性，使用函数形式传参

react-refresh 导致的热更新问题
* 对于 Class 类组件，react-refresh 会一律重新刷新（remount），已有的 state 会被重置。而对于函数组件，react-refresh 则会保留已有的 state。待验证！
* 热更新机制
  * 在热更新时为了保持状态，useState 和 useRef 的值不会更新
  * 热更新时 useEffect、useCallback、useMemo 等会重新执行
* 如何避免
  * 时刻想起 react-refresh 的怪异行为，想办法避免
  * 添加 `@refresh reset` 注释，但这会导致每次 remount，此时 useState 和 useRef 会被重置

尽可能避免滥用 useEffect
* useEffect 改为使用 useMemo
* useEffect 改为使用 event handler，尽可能通过事件处理函数处理副作用
* 通用场景封装自定义 hook

React18 在严格模式中又新增一个行为，以确保它与可重用状态兼容，每当组件**第一次挂载**时，这个新的检查将自动卸载和重新挂载每个组件，在第二次挂载时恢复以前的状态。为什么 React 需要可重用状态
* 帮助你发现一些 effect 需要进行 cleanup 工作。总结就是：如果重新挂载破坏了应用程序的逻辑，这通常会发现现有的错误
* 想要添加的多个特性都有一个约束，需要组件具有弹性，可以多次“安装”和“卸载”。这在 Fast Refresh 中也有所体现，如果你的组件因为偶尔的重新运行 effects 而奔溃，则导致它不能和 Fast Refresh 工作的很好
* 如果你有一个组件会被条件渲染，但组件自身有自己的状态，当组件被卸载时，状态就会丢失，到目前为止，解决办法就是做状态提升
* 新的 Offscreen API 的主要动机是允许 React 通过隐藏组件而不是卸载它们来保持这样的状态。为了做到这一点，React 将调用与卸载时相同的生命周期钩子，但它也将保留 React 组件和 DOM 元素的状态。

> 在开发过程中，严格模式它将记录额外的警告，双重调用那些它期望幂等的函数，以帮助你将提前暴露出来

React18 新的 api 都是建立在新的并发渲染器上，并发模式是可选的，只有当你使用并发特性时才会启用，但我们认为它将对人们构建应用程序的方式产生重大影响。

并发模式是一种新的幕后机制，使 React 能够同时准备多个版本的 UI。你可以把并发看作是一个实现细节，它很有价值，因为它可以解锁一些特性。React 在其内部实现中使用了复杂的技术，如优先队列和多个缓冲。

并发模式是什么？
* 并发渲染是可中断的，在添加任何并发特性之前，更新会在一个单一的、不间断的、同步的事务中呈现。使用同步呈现，一旦更新开始呈现，没有任何东西可以中断它，直到用户可以在屏幕上看到结果。
* 在并发模式中，React 可能会开始渲染一个更新，在中间暂停，然后继续。它甚至可能完全放弃正在进行的渲染。React 保证即使渲染中断，UI 也会显示一致。意味着 UI 可以立即响应用户输入，即使它是在一个大的渲染任务中，创建一个流畅的用户体验。
* 可复用的状态？？？

从长远来看，我们希望你添加并发到你的应用程序的主要方式是使用一个支持并发的库或框架。在大多数情况下，您不会直接与并发 api 交互。

深入 Suspense 组件
* 内置的 lazy 函数实现当相关代码还没有被加载完成时，挂起一个组件，告诉 React 当代码加载完成时进行重新渲染
* 期望添加一个 api 可以对任意组件实现挂起，且给 React 提供一个 Promise，React 不会使用 Promise 的结果，但会重新渲染
* Suspense 是一个让 React 意识到加载状态的机制，没有规定如何获取数据或代码的任何特定选择。
* 使用 useTransition 避免隐藏已经存在的内容，但通过提供 isPending 用于即使反馈
* 通过嵌套 Suspense 避免某个部分特别耗时的部分造成全局等待
* 当内容重新出现时，会重新执行 Layout effects

Learn from docs
* 移除不必要的状态
  * 这种状态会引起悖论吗：比如两个状态，当 A 为 true 时，B 不能为 true，这就导致耦合，容易出错
  * 同样的信息在另一个状态变量中已经存在了吗
  * 你能从另一个状态变量的取反得到同样的信息吗
* 选择合适的数据结构
  * 组合相关状态：如果这几个状态总是同时修改，可以考虑合并为一个状态
  * 避免状态矛盾：多个状态之间会彼此冲突，应该避免，比如 isSending 和 isSent 不能同时为 true
  * 避免冗余状态：如果一个状态可以通过其他状态计算出来，则不要增加状态，同样不要将 props 值映射为内部的 state，如果你真的需要使用 props 的值作为内部 state 的初始值，则使用 initial 或 default 开头
  * 避免重复状态：保持状态同步是困难的，比如保存 id 或 index，而不是具体 item
  * 避免深层次嵌套状态
* 提取组件状态到外部 reducer
* Effect 是 React 逃生舱，它们让你走出 React，将你的组件与一些外部系统同步。

深入 useEffect
* useEffect 表示将延迟一段代码的运行，直到该渲染显示在屏幕上。
* 如果 Effect 使用了某些值，但您不希望在 Effect 更改时重新运行它，则需要编辑 Effect 代码本身以使其不需要该依赖项
* 如果你的 Effect 获取了一些东西，清理函数应该取消获取或者忽略它的结果
  * 开发模式，你将会看到两个请求，但这不是错误
  * 生产模式，只会有一个请求，如果开发中的第二个请求让您感到困扰，那么最好的方法是使用能删除重复请求并在组件之间缓存它们的响应的解决方案
* 重点理解运行阶段和提交阶段，你就能区分逻辑是否该在 effect 中。当你在呈现过程中更新组件时，React 会丢弃返回的 JSX，并立即重新尝试呈现
* 如何处理连锁反应：一个状态的修改会影响其他状态，此时使用 effect 将是噩梦的开始，而是应该是运行期计算或事件处理
* 如果某些逻辑必须在每次加载应用程序时运行一次，而不是每次挂载组件时运行一次，你可以添加一个顶级变量来跟踪它是否已经执行，并且总是跳过重新运行它
* 不要将 effect 理解成渲染后或卸载前的回调或生命周期钩子，这种思考方式会变得复杂起来，而应该关注于开启或停止一个周期，你需要做的是描述如何开始同步，以及如何停止它
* 很多时候，你不希望 effect 运行多次，但却需要一些状态，你不应该通过禁用 lint 来解决
  * 检查你的 effect 是否表示一个独立的同步进程，如果 effect 未同步任何东西，它可能是不需要的，如果它同步几个独立的事情，就把它分开
  * 如果你想要读取最新值，而不想对其做出反应，可以尝试将 effect 分为响应部分（effect 中）和不响应部分（event function 中）
  * 避免依赖对象和函数
* 可能的新 api：useEffectEvent，表现如同 event handler，用于帮助从 effect 分离出非响应逻辑，该函数可直接在 effect 中使用，而无需加入 deps，强行加入反而会导致 lint 报错，允许您打破 Effects 的响应性和一些不应该是响应性的代码之间的链。
  * 仅在 effect 内部调用
  * 不要传递给其他组件或 hook

有趣的关于 hooks 设计的讨论
* 你应该把依赖数组作为性能优化的条件，而不是作为语义的保证。
* 把本不必要的 useEffect 中的逻辑前置到状态真正发生变化时处理的人，所写出来的代码是完全不同的，不论是数据流还是代码风格。实际工作中，一次迭代的上万行代码里，仅仅会在 didMount 后发起 get 请求时使用 useEffect，useEffect 本来就是个不那么常用的 api。事实上，reducer 和 context 是实际开发中使用最多的两个 api
* useEffect 理解成同步，状态同步就应该是任何时刻都可以发生的
* 如果代码种经常出现 useRef 或 useImperativeHandle，那一定存在更好的数据流
* 避免这种工作流：state change -> render -> effect -> state change -> effect
* 了解 Fiber，父子组件渲染时机
  * 渲染阶段，由父到子
  * 提交阶段，由子到父
* 如果你试图通过 effect 去做同步工作，但内部逻辑并不是按照同步的思维模式设计的，这时候就会产生冲突，这时候推荐一个中间操作去调节这个冲突，比如 ref
* Suspense Data Fetching React，目前仅为实验阶段

说到底，很多前端同学对「渲染」的理解仍然是过浅了。依赖 React 做所谓「渲染」，不外乎就是在改一堆对象（DOM）的状态而已，许多 GUI 技术栈里的重点和难点根本摸不到：
* 怎么避免屏幕闪烁？搞双缓冲区。
* 怎么避免计算密集的业务逻辑导致卡顿？拆分独立的 worker 线程。
* 怎么避免主线程被高耗绘制阻塞？序列化绘制命令为 command 数据或对象，然后交给渲染线程消费。顺带一提这样还可以做到跳帧。
* 怎么叠加渲染效果？渲染到纹理 FrameBuffer 里，然后多个 pass 叠加。
* 怎样避免高耗重绘？缓存渲染树节点，做脏检查。

## 前端研究
对于需要频繁修改的数据，如文档
* 每次更改提供 version 字段，避免网络问题导致请求的顺序不对
* 如果只保存最新数据，则发现更加新鲜的数据过来，则触发保存，否则丢弃
* 如果需要保存历史列表，则加入列表，以及是更加新鲜数据则更新当前数据

加快传输速度：使用 GraphQL 让客户机只从服务器请求所需的数据

数据模型设计
* 有时候会纠结两个模型之间，谁关联谁的问题，此时可以回归到关系型数据库中外键如何设计
* 针对计算属性，是应该单独请求还是作为字段呢？
* 考虑引入空方案的设计，路由 `plan/0`

自动切换方案逻辑--让人难受
* 复制多层方案中的单层方案时，自动切换到新方案
* 生成新多层方案时，自动切换到新方案中的第一个方案
* 删除多层方案时，当前方案置空
* 删除单层方案时，自动切换到下一个

## RTree
MBR，Minimun Bounding Rectangle：MBR 本身通过 x、y 坐标容易计算，计算 MBR 相交也十分简单高效，适用于应用在索引结构中

R-Tree 特点（R 表示 Rectangle）
* 由单个根、内部节点和叶节点组成，所有叶子节点都位于同一层，因此 R 树为平衡树
* 根包含指向空间域中的最大区域的指针
* 父节点包含指向子节点的指针，其中子节点的区域与父节点的区域完全重叠
* 叶节点包含到当前对象的 MBR 数据
* MBR 最小边界区域是指围绕所考虑的区域/对象的最小边界框参数
* 子节点数量有限制即存在节点分裂和合并

R 树与 B 树最显著的区别在于 R 树在非一维空间使用 MBR 描述节点的上下界，无法像 B 树节点一样准确适应子节点的分布。虽然通过通过 MBR 提高了计算和求交的效率，不过这也势必牺牲了空间利用率（父节点包含了空白区域）及查询效率（兄弟节点 MBR 可能会重叠）

B 树是一棵平衡树，它是把一维直线分为若干段线段，当我们查找满足某个要求的点的时候，只要去查找它所属的线段即可。这种思想其实就是先找一个大的空间，再逐步缩小所要查找的空间，最终在一个自己设定的最小不可分空间内找出满足要求的解。

常用空间查询方式
* 窗口查询：给定一个查询窗口（通常是一个矩形），返回与查询窗口相重叠的物体
* 点查询：给定一个点，返回包含这个点的所有几何图形

R-Tree 与四叉树（Quad-trees）比较
* 四叉树需要平铺层优化，而 R-Tree 不需要任何此类优化
* 四叉树可以在现有的 B-Tree 上实现，而 R-Tree 遵循与 B-Tree 不同的结构
* 四叉树空间索引创建速度比 R-Tree 快
* 对于最近邻居查询，R-Tree 比四叉树快，而对于窗口查询，四叉树比 R-Tree 快

通用规则
* 点索引可以使用网格索引 KDTree（k-dimensional tree)）
  * tree 的每一层，依次选一个维度把空间二分
  * 仅限点，不支持矩形
  * 静态的，不支持增删元素
  * 索引快 5-8 倍
* 线面索引使用 STRTree（Sort-Tile-Recursive Tree 递归网格排序） 或者 QuadTree
  * QuadTree 依次将每个子空间分层 4 份，直到不需要再分位置
  * 支持点，也支持矩形，用于表示任何几何对象

Grid Index：将要考虑的空间铺好网格，一遍快速锁定区间。适合做近邻搜索。

当面对大规模的空间数据时，一个最有效也是最重要的方法就是空间索引（Spatial Index）。

空间索引一系列可以通过排列几何数据来进行高效索引的算法，例如查询本区域所有的建筑，距此点最近的 1000 个加油站等问题，要求结果能在几毫秒内返回，即使所要查询的目标由几百万个。

空间数据有两种基础查询类型：最相邻查询和范围查询

最原始的处理方式
* 最朴素的方法：遍历计算再排序
* 针对复杂图形，如不规则多边形，则先转换为简单的包围盒判断，再进一步做复杂判断
* 网格查表法
* 建立空间索引

大规模地解决这两种问题时就需要将数据点转换到空间索引中。由于数据转变的频率会远远少于查询的频率，因此将数据转变到空间索引的花销对于之后的快速搜索是非常值得的。

几乎所有的空间数据结构都具有相同的原理，以实现有效的搜索：分支和绑定（https://en.wikipedia.org/wiki/Branch_and_bound）。数据被排列在一个树状结构中，因此当在某一节点的某一分支不符合查询条件时，该分支之下的所有的节点都可被略过。

K 相邻查询
* 对于特点查询点，如何判断哪棵子树上的节点与该节点最相邻呢？最相邻的点可能在树中里查询点很远的位置
* 优先队列：维护一个有序列表，将最小的元素以很快的速度提取出来
  * 与查询点更临近的矩形框可能有我们想要搜索的点，按从近到远的顺序将最大的矩形框排在队列中，从顶层开始进行搜索
  * 打开相邻的矩形框，从队列中移除，并将它的孩子节点放到队列中与其相邻的位置上
  * 重复上述步骤，当从队列中移除的相邻项是真正的点，而不是矩形框时，这就是我们要查找的点，队列顶部的第二个点就是第二个最相邻的点，依次类推
  * 扩展：不仅实现点对点，也可以扩展到线对点等

GIS 所表现的地理数据多维性使得传统的 B 树索引并不适用，因为 B 树所针对的字符、数字等传统数据类型是在一个良序集之中，即都是在一个维度上，集合中任给两个元素，都可以在这个维度上确定其关系只可能是大于、小于、等于三种，若对多个字段进行索引，必须指定各个字段的优先级形成一个组合字段，而地理数据的多维性，在任何方向上并不存在优先级问题，因此B树并不能对地理数据进行有效的索引，所以需要研究特殊的能适应多维特性的空间索引方式。

空间筛选的大致流程基本都是
1. 矩形框初筛，通过待查询矩形框与数据外包矩形相交快速判断
2. 对筛选后缩小了的数据集进行相交、包含、相切、相离等精准判断

空间索引的算法优劣，主要在于如何减少无关数据的访问次数

空间数据至少是二维数据，常用的一维索引（如 BTree/Bitmap 索引等）无法满足需求，常用的空间索引算法有 BSP 树、KD 树、R 树、R+ 树、四叉树和 CELL 树。

资料集合
* [深入理解空间搜索算法 ——数百万数据中的瞬时搜索](https://www.cnblogs.com/arxive/p/8138586.html)
* [A dive into spatial search algorithms](https://blog.mapbox.com/a-dive-into-spatial-search-algorithms-ebd0c5e39d2a)

## three.js 回顾
three.js 对底层 WebGL 的高级封装的同时，保留底层开发的特性，仍然可以使用点、面、法向量、UV 构造几何体，以及编写着色脚本来创造自己想要的特殊材质。

有趣的做法
* 把光源也绑定到摄像机上，这样光源就会随着摄像机移动
* 三维建模软件组成：本质上是一个 Group，组合多个 3D 对象层级，对象定义自己的 BufferGeometry 和 Materials 材质
* 通过 CanvasTexture 运行时生成纹理
* 通过 RenderTarget 根据 three api 动态生成纹理。渲染目标大体上指的是可以被渲染的纹理。当它被渲染之后，你可以像使用其他纹理一样使用它
* 判断用户是点击还是拖动，除了判断按下和松开的距离外，我们可以也判断时间间隔，如果大于 200ms，则认为是拖动，可能效果更好

理解相机原理：通过一些矩阵变换，将 near 至 far 之间物体，投影到 near 平面上，即为最终呈现到屏幕上的元素

自定义缓冲几何体
* 理解 BufferGeometry.attributes 的 position、normal、uv 和 color 属性
  * 顶点的组成部分：position、normal、uv、color，一个简单的顶点是所有组成部分的集合
  * 如果顶点需要其中的任一部分变得不同，那么它必须是一个不同的顶点
  * 比如方块的 Geometry，看起来在角的地方共用顶点，但是实际不是，因为 normal 和 uv 等通常不同
* 理解 BufferGeometry.index 属性

> uv 表示纹理坐标，因为 xyz 已经被顶点坐标使用，所以使用 uvw 表示纹理坐标，表示贴图映射到模型表面的依据，把表面的点与平面上的像素对应起来，通常通过 0-1 表示，其中 u 表示水平，v 表示垂直，w 表示垂直于显示器表面，一般情况只是在表面贴图，就涉及不到 w，所以常称为 uv

贴图原理
* 纹理坐标系统 [0, 1]，WebGL 坐标系统 [-0.5, 0.5]，维护好顶点坐标对应的纹理坐标，其余色值是通过光栅化自动生成的
* 一个几何体对象不同三角形可以对应不同材质，通过 groups 设置
* 通过 texture.offset 设置纹理偏移
* 通过 texture.repeat 设置重复次数

Group 和 Object3D 有区别吗
* 几乎没有任何区别，Group 继承自 Object3D，设置 type 为 Group 仅此而已
* 相比 Object3D 而言只是更语义化

研究相关问题
* 分析 BoxGeometry 是如何默认支持六面贴图的
  * 本质上是依次生成六个面
  * 生成一个面的步骤为
    * 计算每个面的四个顶点坐标、法向量以及 uv 坐标
    * 计算 index 数组，指定每三个顶点构成一个三角面
    * 通过 addGroup(groupStart, groupCount, materialIndex) 设置该面使用的索引下标，表示从 start 到 start+count 之间顶点构成的所有三角面使用该材质
* 理解 PlaneGeometry、CircleGeometry 的贴图原理
  * PlaneGeometry 没有调用 addGroup，因此仅能运用一个 Material
  * CircleGeometry 有调用 addGroup，那么圆形应用方形贴图会是什么效果呢
* ShapeGeometry 的贴图原理
  * 当传入的 shapes 为数组时，针对每个 shape 定义 addGroup，否则不指定
  * 内部调用 ShapeUtils.triangulateShape 对轮廓和 holes 进行三角化得到面
* 分析 CylinderGeometry 如何生成 BufferGeometry 和应用贴图
  * 分别两步，生成侧面以及上底和下底。
  * 侧面：根据设置的高度分段数和圆弧分段数，生成侧面的顶点坐标、法向量以及 uv 坐标
  * 侧面：根据设置的高度分段数和圆弧分段数，生成 index 以及计算 groupCount
  * 侧面：设置 addGroup，materialIndex 设置为 0，贴图效果应该是整个侧面
  * 底面：底面逻辑差不多，计算顶点、法向量、uv 坐标，计算 index，设置 materialIndex，top 为 1，bottom 为 2
* 分析 ExtrudeGeometry 的贴图原理，UVGenerator 工作原理
  * 相比其他规则图形而言，ExtrudeGeometry 要复杂很多
  * 遍历所有给定的 shapes 计算 position 和 uv 信息，通过调用 computeVertexNormals 计算方向量
  * 如果自定义了 UVGenerator 则使用传入的生成器，否则使用内置的 WorldUVGenetator
  * 对给定的 Shape 进行采样处理，逆时针转换，然后三角化
  * uvGen 签名
     * generateTopUV
     * generateSideWallUV

XYZ 平面问题，将 camera.up 设置为 z 轴后，总感觉有些奇怪的问题，需求目标：基于 z 旋转，基于 xy 绘制和坐标拾取

注意性能优化
* 应用 merge geometry 后，对于一整个 mesh，我们只能应用一个材质，因此只能使用一种颜色，某些场景下可以通过顶点着色法解决
* 大量物体的动画
  * 使用 Morphtargets 给每个顶点提供多个值，以及使用他们变形或 lerp 的方法
  * 通过设置 BufferGeometry 的 morphAttributes 来设置多个值，不同的是 position、color 等属性是一个 attribute 数组
  * 通过改变 mesh 的 morphTargetInfluences 属性来应用突变

有趣的例子：https://threejs.org/manual/#zh/load-gltf
* 如何一步一步矫正模型
* 如何让物体根据轨迹动起来

天空盒
* 使用 CubeTextureLoader 加载天空盒的六张图
* 使用等距矩形贴图(Equirectangular map)， 这是被 360 全景相机拍摄的一种特殊类型的图片。使用 WebGLCubeRenderTarget.fromEquirectangularTexture 从等距矩形纹理中生成一个立方体贴图，我们传入预期的立方体贴图的大小给 WebGLCubeRenderTarget

如何绘制透明的物体
* 简单而言是使用 transparent 和 opacity 属性
* 但有时候效果可能不太符合预期，因为对于 3d 物体的一般性绘制方式，对于每个几何体，一次绘制一个三角形。当三角形的一个像素在被绘制的时候，会记录两件事情，一是像素的颜色，一是像素的深度。当下一个三角形绘制时，对于深度大于先前被记录的深度的像素，将不会被绘制，这就对于透明物体而言，有东西消失了一般。这个问题的解决方案是将透明的物体进行排序，排在后面的物体比排在前面的物体先绘制。
* 三角形绘制的顺序和在几何体中构建的顺序是一致的， 取决于我们从哪个方向看向这些三角形，距离摄像机近一些的先被绘制。因此，在后面的那些三角形不会被绘制。这就是我们看不到后面的面的原因。
* alpha 测试是指像素的 alpha 值低于某个水平的时候，three.js 就不会绘制它。
* 完美的透明是困难的，有着各种问题、取舍和变通方法。

> 浏览器限制了 WebGL 上下文(WebGL contexts)的数量。通常浏览器将其限制为 8 个，一旦超出这个数量，最先创建的 WebGL 上下文就会被自动弃用。

数学库：Frustum 视窗体
```js
const frustum = new THREE.Frustum();
const viewProjection = new THREE.Matrix4();
viewProjection.multiplyMatrices(
    camera.projectionMatrix, camera.matrixWorldInverse);
frustum.setFromProjectionMatrix(viewProjection);
const inFrustum = frustum.contains(someMesh));
```

GPU 拾取：概念简单，使用复杂，为了完成 GPU 拾取，对每个对象使用唯一的颜色进行离屏渲染，然后检查鼠标位置关联的像素颜色，通过颜色告诉我们哪个对象被选中。这里演示了 [GPU 拾取的简单例子](https://threejs.org/manual/#zh/picking)

后期处理
* 在结果被输出到 canvas 之前，我们也可以通过另外的一个 RenderTarget 并应用一些后置效果。这被称为 PostProcessing，因为它发生在主场景渲染过程之后。
* 使用方式：EffectComposer 搭配各种 Pass 对象，每个 Pass 对象就是一个效果
* EffectComposer 工作原理：创建两个 RenderTarget，交替应用不同的 pass 对象，实现叠加的效果
* 对于几乎所有的后期处理 EffectComposer，RenderPass 都是必需的。因为它是初始输入。
* 自定义后期处理：ShaderPass

这两个示例好强
* [Voxel(Minecraft Like) Geometry](https://threejs.org/manual/#zh/voxel-geometry)
* [Start making a Game](https://threejs.org/manual/#zh/game)

## 代码设计
类设计类型
* Value Object
  * 纯数据结构，常用于底层数据结构
* Entity
  * 领域模型作为语言的扩展
  * 通常属性非常精简，大量使用接口约束其行为，偶尔使用继承封装更特异化领域对象
  * 警惕**数据耦合、方法耦合、超级方法簇**？？？
* Service/aggregate
  * 业务逻辑的步骤，常用于模块入口、顶层模块
  * 类名基本上都是以计算过程或者计算者命名，尽可能的精简属性

Shapely 分享
* 性能
  * STRTree
  * 桶方法
* 图形之间的 9 种关系
* 对象组合设计：类 进入某个模式
* 指定某个策略
* Predicator？？
* 职责链模式
* 柯立化类
* 找稳定的因素

## editor 改进优化
心荃：设备用房我觉得比较繁琐的。一个是激活和hover要改变和还原样式；另外单选多选编辑这三功能混一起，并且仅单选可编辑，这里处理也有点复杂

增强 editor
* StaticEditor：针对无须交互场景，提高性能
* getPointerPosition()
* getIntersection(pos)
* getObjectsAtPixel(pixel, targets)

lexical(文本编辑框架) api 分析
* editor：将所有内容连接在一起的核心对象
* registerCodeHighlighting(editor)
* Listeners, Node Transforms and Commands
  * registerNodeTransform
  * registerUpdateListener(callback) => 类似于特殊的 addEventListener
  * registerCommand(command, listener, priority)
  * dispatchCommand(type, payload)

命令模式（感觉类似事件机制）对于构建工具栏或复杂插件机制十分有用。

可能的优化
* 对于未激活的功能，监听不应开启，以及辅助元素不应添加到场景
* 更好的 line 支持度：http://evomap.cn/demo/sandbox/sandbox.html#line/line
* 场景常用 dom 元素封装，如 popup

增强事件机制 - 很重要
* 针对 editor 本身事件机制
* 针对 object 的事件机制

事件分类
* 鼠标类 mouse:down | mouse:move | mouse:up
* 物体类 object:modified | object:selected | object:moving | object:scaling | object:rotating | object:added | object:removed

增强基础编辑能力
* 移动、缩放、旋转
* 删除、编辑、复制
* 可选逻辑

增强样式操作
* styling/coloring
* highlight/resetHighlight

相关问题
* 内置的相关对象继承 Object3D，无法通过继承的方式扩展对象
* 整理场景样式修改的情形，如修改线颜色、线宽、线型、面颜色、点颜色、点大小、点型

一些发现
* raycaster 只会与有 geometry 对象做相交判断，因此 group 做相交会得到它的 children

## 技术需求
如何优雅控制元素显隐和副作用，如副作用：桩基墙枝处理、进入生成页
* 墙枝处理完后，通过 setState 控制某些 ui 的显示
* 需要调用 editor 去销毁场景元素

在同一个页面，如何清除副作用
* 多页时，组件销毁重建时，副作用自然消失
* 需要确定一个规则，如组件销毁时，用于清理副作用

全局功能可能会造成的影响
* 切换方案时的当前状态：切换多层、切换3D时同理
* 撤销重做多层的问题

产品细节
* 推荐整个地下室大堂（多层）
* 整个地下室平铺和方案平铺 - 使用模态框实现
* 触发保存的时机：切换时提示保存和退出时提示保存
* 手动车位重排+仅保存
* 图层信息面板：场景物体与图层ui联动
* 元素检测面板：收纳多个元素规范检测
* 辅助生成模式+编辑模式（根据选择对象确定工具栏）

方案生成
* 通过 mode 区分车位排布、设备用房、防火分区
* parent_id 表示项目，result_id 表示方案集，set_id 表示某个方案
* 查询参数 result_id 进入某个方案，此时页面原本的生成按钮消失
* 新增深化设计入口

前端产品讨论
* 有些操作新生成方案，有些是更新当前方案
* 柱网参数的逻辑没有闭环
* 辅助编辑进一步优化：拖面逻辑
* 当前方案可能来源于多个：方案库、浏览器
* 复制的进行中提示很重
* 左侧按钮分组问题？？？
* 切换方案很慢，路由进入退出导致切换频繁
* 坡道缺少指引：应该是交互有待优化，如坡道和入口，进入创建的交互
* 文案不一致性：完成、确定、退出
* 选择按钮类型的逻辑是什么

Vectary UI overview
* 顶部栏：模式切换和工具栏，根据模式的不同，会有不一样的工具栏
* 左侧栏：图层面板和素材
* 右侧栏：默认显示当前画布信息，有选择对象时显示当前对象信息
* 底部栏：控制 bar

产品设计
* model-based-design：自下而上
* scene-based-design：自上而下

测试反馈的流程问题
* 新功能紧急度 > bug 修复
* 确定 rc 版本后，测试会开始进行新增功能测试，最后一天时间用于回归。回归测试时间被压缩，且回归容易反复出现问题
* 确定两个主要测试范围：与版本无关的关键流程+本轮新增的修改测试（通过版本 diff 明确测试范围？）
* 测试建议：回归日和发版日分做两天
* 测试建议：通过功能确定时间周期，而不是周期来确定功能排期
* 产品文档和交互设计差异较大，前端工程师开发过程中以交互稿为主，导致产品和交互间信息差遗漏
* 产品文档和设计稿之间没有建立联系。新版本中，功能之间不够连贯，功能与功能之间的交互很难纳入考虑，每个产品经理仅考虑自己的设计

解决办法
* 针对产品文档和设计文档有出入问题：开发工程师以交互设计稿为准
* 针对版本管理不够系统，部分功能硬上问题，以及测试时间不够问题：根据功能反推时间，更灵活的发版周期
* 针对算法bug修复时间难确定问题：区分产品功能和算法功能bug

## 微信登录
OpenID vs UnionID：为了识别用户，每个用户针对每个公众号会产生一个安全的 OpenID，如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的 OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个 UnionID。

感觉绑定 unionid 比较通用。

state：用于预防 csrf 攻击，因为拥有 code 的 redirect_uri 地址一旦被劫持，此时通过 csrf 手段诱导其他用户访问该链接，就会导致认证信息错误认证，因为 redirect_uri 是没有发起者用户信息的，换一个用户访问也会认证通过，导致的后端就是，你把你账号绑定了别人的微信。为了应对这种情况，引入了 state 参数，用于保持请求和回调的状态，在回调时，会在查询参数时回传该参数，开发者可以通过该参数验证请求有效性。要求这个参数不可预测，又必须充分证明 client 和当前第三方网站的登录认证状态存在关联，如果存在过期时间则更好

相关接口描述
* 新增 wx_config 接口，用于返回 appid，目前感觉接口写死即可。（前端也可写死，但感觉交给后端更好一点）
* 新增 wx_userinfo 接口，目前后端直接调 access_token 接口即可，只需要 unionid，如需要更多信息，需要调 userinfo 接口
* 修改 login 接口，支持通过 unionid 登录
* 修改 register 接口，支持通过 unionid 注册
* 新增 patch user/current？用户更改用户信息，绑定与解绑微信
