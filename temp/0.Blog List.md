## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

## 前端研究
加快传输速度：使用 GraphQL 让客户机只从服务器请求所需的数据

数据模型设计
* 有时候会纠结两个模型之间，谁关联谁的问题，此时可以回归到关系型数据库中外键如何设计
* 针对计算属性，是应该单独请求还是作为字段呢？
* 考虑引入空方案的设计，路由 `plan/0`

## 代码设计
代码设计实践
* 对象组合设计：类 进入某个模式
* 指定某个策略
* 职责链模式
* 柯立化类
* 找稳定的因素

## editor 优化
增强 editor
* StaticEditor：针对无须交互场景，提高性能
* getPointerPosition()
* getIntersection(pos)
* getObjectsAtPixel(pixel, targets)

可能的优化
* 对于未激活的功能，监听不应开启，以及辅助元素不应添加到场景
* 更好的 line 支持度：http://evomap.cn/demo/sandbox/sandbox.html#line/line
* 场景常用 dom 元素封装，如 popup

增强事件机制 - 很重要
* 针对 editor 本身事件机制
* 针对 object 的事件机制

事件分类
* 鼠标类 mouse:down | mouse:move | mouse:up
* 物体类 object:modified | object:selected | object:moving | object:scaling | object:rotating | object:added | object:removed

增强基础编辑能力
* 移动、缩放、旋转
* 删除、编辑、复制
* 选择逻辑

增强样式操作
* styling/coloring
* highlight/resetHighlight

相关问题
* 内置的相关对象继承 Object3D，无法通过继承的方式扩展对象
* 整理场景样式修改的情形，如修改线颜色、线宽、线型、面颜色、点颜色、点大小、点型

## 技术需求
如何优雅控制元素显隐和副作用，如副作用：桩基墙枝处理、进入生成页
* 墙枝处理完后，通过 setState 控制某些 ui 的显示
* 需要调用 editor 去销毁场景元素

在同一个页面，如何清除副作用
* 多页时，组件销毁重建时，副作用自然消失
* 需要确定一个规则，如组件销毁时，用于清理副作用

全局功能可能会造成的影响
* 切换方案时的当前状态：切换多层、切换3D时同理
* 撤销重做多层的问题

方案生成
* 通过 mode 区分车位排布、设备用房、防火分区
* parent_id 表示项目，set_id 表示方案集，result_id 表示某个方案
* 查询参数 result_id 进入某个方案，此时页面原本的生成按钮消失
* 新增深化设计入口

Vectary UI overview
* 顶部栏：模式切换和工具栏，根据模式的不同，会有不一样的工具栏
* 左侧栏：图层面板和素材
* 右侧栏：默认显示当前画布信息，有选择对象时显示当前对象信息
* 底部栏：控制 bar

产品设计
* model-based-design：自下而上
* scene-based-design：自上而下

## StrictMode
Strict Mode 在开发环境下表现
* 组件将额外渲染一次，以发现由于不纯渲染导致的问题
* 组件将额外执行一次 effects，以发现由于没有 cleanup 导致的问题
* 检查过期 api 的使用

## WebGL 补充
WebGL 内置变量-顶点着色器
* gl_PointSize 用于 vertex shader 写光栅化后的点像素大小
* gl_Vertex 物体空间的顶点位置
* gl_Position 用于 vertex shader 写顶点位置
* gl_Color 顶点主颜色
* gl_Normal 顶点法线值

WebGL 内置变量-片元着色器
* gl_FragColor 用于 fragment shader 写片元颜色值
* gl_FragCoord 只读，片元的像素坐标，当前渲染的像素在画布内的坐标，左上角是[0,0]，右下角是[width,height]
* gl_PointCoord 点精灵的二维空间坐标范围在 (0.0, 0.0) 到 (1.0, 1.0) 之间，仅用于点图元和点精灵开启的情况下
* gl_FrontFacing 用于判断 fragment 是否属于 front-facing primitive，只读；bool
* gl_FragDepth 输出变量，我们可以使用它来在着色器内设置片段的深度值，如果着色器没有写入值到 gl_FragDepth，它会自动取用 gl_FragCoord.z 的值。在写入gl_FragDepth时，你就需要考虑到它所带来的性能影响。

内置函数
* 角度函数 radians/degree
* 三角函数 sin/cos/tan/asin/acos/atan
* 指数函数 pow/exp/log/exp2/log2/sqrt
* 通用函数 abs/min/max/mod/sign/floor/ceil/clamp
  * mix 线性内插：mix(colorA, colorB, weight)，两种颜色混合，其中 weight 代表 B 的权重，1-weight 代表 A 的权重。
  * step 步进函数：step(a, b)，当 b>a 时返回 1，当 a>b 时返回 0
  * smoothstep(edge0, edge1, x) 当 edge0 < x < edge1 时，smoothstep()在 0 和 1 之间执行平滑埃尔米特插值。
  * fract 取小数部分
  * lerp(a, b, x)：当 x=0 时返回 a，当 x=1 时返回 b，否则返回 ab 的差值
* 几何函数 length/distance/dot/cross/normalize/reflect/faceforward
  * reflect：返回一个向量相对于某个法向量的反射向量
* 矩阵函数 matrixCmpMult 逐元素乘法
  * 注意：不是按照线性代数中的矩阵乘法规则执行的，如果是线性代数中矩阵乘法规则，直接使用乘法符号 `*` 就可以，即 `x*y`
  * 内置矩阵函数 matrixCompMult() 的运算规则是同行同列的元素相乘，也就是 `x[i][j]` 和 `y[i][j]` 相乘
* 矢量函数 lessThan/lessThanEqual/greaterThan/greaterThanEqual/equal/notEqual/any/all/not
* 纹理查询函数
  * texture2D 在二维纹理中获取纹素
  * textureCube 从立方体纹理中获取纹素

长宽适配。在分辨率长宽不等的情况下，将坐标系映射为等边，映射后原先较长的一边其自变量会变大。举例：将一个正方形图贴在一个长方形上，此时图会被拉升，进行适配后则可以维持图片比例不变。
```js
uv.x *= u_resolution.x / u_resolution.y;
```

两个 step 或 smoothstep 相减，可以用来划线
```js
#version 300 es
precision highp float;
out vec4 FragColor;
uniform vec2 resolution;
void main() {
  vec2 st = gl_FragCoord.xy / resolution;
  vec2 center = vec2(0.5);
  float d = length(st - center);
  FragColor.rgb = (smoothstep(d - 0.015, d, 0.2) - smoothstep(d, d + 0.015, 0.18)) * vec3(1.0);
  FragColor.a = 1.0;
}
```

距离场构图法，最核心的思路是要定义一个形状的距离场，通俗来说，就是定义整个画布空间中每个像素点的距离值。

如果要绘制一条连续曲线，我们可以取相邻的三个点 A、B、C 采样，计算 P 点到这三个点构成的两条线段 AB 和 AC 的距离，取距离短的作为 P 到曲线的距离。

通过 `st = mix(vec2(-10, -10), vec2(10, 10), st);` 来扩大坐标系的区间，将坐标系从 `(0,0),(1,1)` 扩大到了 `(-10,-10),(10,10)`，这也是一种常用的数学技巧，可以牢记。

通过 `gl_FragCoord.xy / resolution` 可以将坐标值“归一”（即将值限制到 0~1 区间，这是一种在写着色器的时候经常使用的数学技巧）

网格技巧：将 uv 拉升 n 倍后取小数部分，处理后的 uv 会变成每个网格内的局部坐标，这个被广泛使用。

三角形绘制：定义点到三角形的距离为点到三角形三条边距离中最短的一条边的距离。

如果要在画布上绘制多个相同图形，不必一一绘制每一个图形，要我们有一些数学手段可以运用。
* 可以扩大 st 或 d 的值，然后对它取小数部分
* 这是两种不同的重复效果

容易搞混的坐标系
* uv：左下角是 [0, 0]，右上角是 [1, 1]
* FragCoord：左上角是 [0,0]，右下角是 [width, height]
* PointCoord：左上角是 [0, 0]，右下角是 [1.0, 1.0]

入门教程
* [充分理解WebGL（一）](https://juejin.cn/post/7098256201661546532)
* [基于three.js实现一个粒子系统](https://juejin.cn/post/6844904161574649870)

目前 Editor 中关于 Line 的使用
* MeshLine3D 存在问题：跟着相机不断调整朝向
* MeshPath3D 存在问题：无法支持特定像素大小

TODO
* 理解 uniform 传递 resolution 的作用
* 理解 sizeAttenuation 实现原理
  * false 所有粒子都将拥有一样的尺寸，无论距离多远
  * true 粒子大小将取决于相机远近

通常物体走的固有变换是
```js
void main() {
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );
}
```

SpriteMaterial 中 sizeAttenuation 实现原理
```js
void main() {
  // ……
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
  // vertex shader 中
  #ifndef USE_SIZEATTENUATION
    bool isPerspective = isPerspectiveMatrix( projectionMatrix );

    if ( isPerspective ) scale *= - mvPosition.z;
  #endif

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
  // ……
}
```

关键代码 `scale *= - mvPosition.z;` 为什么是合理的？注意，一个是 ifdef 一个是 ifndef

对比 PointsMaterial 实现
```js
void main() {
  gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
    // 离得越远，则 scale/-mvPosition.z 越小，从而实现衰减效果
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif

}
```


有意思：由于 step 返回值总是为 0 和 1，因此可以通过加、减、乘实现位运算，smoothstep 会出现中间值，此处不考虑。下面例子就是使用减法，实现组合 Circle 的方式绘制一张脸
```js
float Circle(vec2 uv, vec2 o, float r, float blur) {
  return smoothstep(r, r - blur, distance(uv, o));
}

float Face(vec2 uv, vec2 o) {
  float c = Circle(uv, vec2(.0, .0), 0.5, 0.01);
  c -= Circle(uv, vec2(-.2, -.2), 0.2, 0.01);
  c -= Circle(uv, vec2(.2, .2), 0.2, 0.01);
  return c;
}
```

总结常用函数：fract、mix、step、smoothstep、伪随机

TODO：深入理解 normalMatrix

#include 机制
* 开始以为是 glsl 语法，实际上是 three.js 尝试引入的模块机制
* 在 WebGLProgram 模块中对 #include 指令进行解析，配合 ShaderChunk 对象进行解析

## SonarQube
目标
* 代码质量：bug、安全性、复杂度、重复代码、单测
* 代码规范：结构与设计
* 成果可视化

基本使用
* Git Actions
* IDE：SonarLint 扩展
* jenkins 集成：SonarQube 插件
* 项目配置 sonar-project.properties 自定义配置

当前已知问题分析：真假问题
* 部分安全审查的作用没理解到
* 默认规则该挺全面的，连框架层面都有支持

项目实践
* 自定义规则（extend/copy）
* eslint 冲突问题：支持 sonar.eslint.reportPaths 设置导入 eslint 报告
* 仓库级项目配置 sonar-project.properties
* 文件或代码行级别的规则禁用
  * 文件级只能通过配置文件解决
  * 代码级别可通过内置注释 // NOSONAR
* 尽可能使用或兼容 eslint 替换
* 运维更新到最新版 sonar

## meshline vs line2
meshline vs line2
* meshline 是社区方案，目前处于不维护状态，line2 属于官方内置示例
* meshline 虚线绘制过于紧密，line2 表现良好
* 三维视角下，都存在正面不是维持向上问题
* line2 设置透明度后，顶点重叠部分效果不好（之前也正是因为该原因不支持透明度）

我们如何确定一个颜色
* 为什么是三原色？因为人类对色彩的感知结果位于一个三维的线性空间中。最少需要三种颜色的光才能有足够的表达能力来表现各种颜色
* 为什么选 RGB 作为三原色？因为色彩空间不是真正数学意义上的线性空间，从工程角度考虑，以 RGB 作为三原色，能让显示器能够显示更多的颜色
* 对于 RGB 色彩空间来说，关键点在于两个：1. 如何选择三个作为基底的颜色；2. 如何定义白色。一旦选好这两个关键参数，那么从 CIE XYZ 空间到设备的 RGB 空间的转换就完全确定了
* 不同的 RGB 空间所能表示的颜色范围是不一样的，并且我们可以推断出，即使是同样的 RGB 分量，在不同的 RGB 空间中所代表的颜色也是不一样的。所以我们在描述一个 RGB 颜色的时候，不仅需要描述它的 RGB 三个分量，还要说明是在哪个空间，这就是 ICC 文件的作用
* 常见的网络环境下图片的色彩空间是 sRGB，有很多浏览器不能正确地解析图片自带的色彩空间说明，默认按照 sRGB 来进行解析。

three.js 颜色空间
* 颜色空间由基色、白点、转换函数
* 常用空间 sRGB 和 Linear-sRGB，两者都使用相同的基色和白点，因此具有相同的颜色范围，都使用 RGB 颜色模型，它们仅在传输函数上有所不同
  * Linear-sRGB 相对于物理光强度是线性的。
  * sRGB 使用非线性 sRGB 传递函数，更接近于人眼感知光的方式和普通显示设备的灵敏度
* 这种区别很重要。光照计算和其他渲染操作通常必须在线性色彩空间中进行。然而，线性颜色存储在图像或帧缓冲区中的效率较低，并且在由人类观察者观看时看起来不正确。因此，输入纹理和最终渲染的图像通常会使用非线性的sRGB色彩空间。

颜色空间中三个角色
* 输入颜色空间：纹理、三维模型等资源都会有关联的颜色空间，不是 Linear-sRGB 颜色空间的必须被转换，在开启了 ColorManagement 后，某些转换(对于sRGB中的十六进制和CSS颜色)可以自动进行
* 工作颜色空间：渲染、插值和许多其他操作必须在开放域线性工作色彩空间中执行，其中 RGB 分量与物理照明成比例。在 three.js 中，工作颜色空间是 Linear-sRGB。
* 输入颜色空间：输出到显示设备、图像或视频可能涉及从开放域 Linear-sRGB 工作色彩空间到另一个色彩空间的转换。这种转换可以在主渲染通道(WebGLRenderer.outputColorSpace)中执行，也可以在后期处理期间执行。自定义着色器必须实现自己的输出颜色空间转换。

关于色彩系统的重要破坏性更新：https://discourse.threejs.org/t/updates-to-color-management-in-three-js-r152/50791

## rust
相关特性
* 借用和所有权
* 模式匹配
* 生命周期
* 并发编程：支持线程，同时还支持并发，允许在单线程中实现并发

& 符号有两个主要用途，它可以表示引用（reference）和借用（borrowing），* 符号用主要用解引用
* 当用 & 符号创建一个引用时，它创建了对某个值的引用，而不会转移该值的所有权。引用允许你在不拥有值的情况下访问它。引用通常用于函数参数、数据结构中的字段、以及在借用（borrowing）中。
* & 符号还可以用于创建借用，包括可变和不可变的借用。不可变借用允许对值进行只读访问，而可变借用则允许修改值。借用通常用于函数参数，以便在函数中引用数据而不获取所有权。
* 当 * 用于引用类型之前，它表示解引用操作，即访问引用所指向的值。因为在 Rust 中，使用引用时，我们通常使用 & 符号创建引用，而在需要使用引用指向的实际值时，我们使用 * 进行解引用。

在 Rust 中，生命周期通常以撇号（'）加上标识符的方式表示，例如 'a、'b 等。生命周期注解是 Rust 的一部分，用于指定引用之间的关系，使编译器能够验证引用的有效性。

关于生命周期的示例
```rs
struct Foo {
    x: &i32,
}

fn main() {
    let y = &5;
    let f = Foo { x: y };

    println!("{}", f.x);
}
// 上述代码会报错：y的借用被传递到了结构体 y 中，因此必须确保 y 的生命周期比 f 要长，此时我们添加生命周期标记
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5;
    let f = Foo { x: y };

    println!("{}", f.x);
}

// 如下的粒子 i 中，要求 x,y 具备相同的生命周期，但使用的时候由于 b 的生命周期较短，因此会报错提示 b 生命周期不够长
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
fn main() {
    let a = "hello";
    let result;
    {
        let b = String::from("world");
        result = longest(a, b.as_str());
    }
    println!("The longest string is {}", result);
}
```

## server-sent events
严格来说 http 无法向客户端主动发起推送信息，有一个种变通的方法，就是服务端向客户端说明要发送的是流信息，即发送的不是一次性的数据，而是一个数据流会连续不断的发送过来，这时客户端不会关闭连接，会一直等服务器发过来的新数据流，SSE 就是利用这种机制，使用流信息向浏览器推送信息。

基本实现
* 客户端使用 EventSource 对象
* 服务端需要指定 content-type 为 text/event-stream

SSE 相比于其他技术方案，SSE 有以下几个优势：
* SSE 使用更简单，不需要添加任何新组件，只需使用现有的后端语言和框架即可。
* SSE 完全复用现有的 HTTP 协议，因此可以直接运行于现有的代理服务器和认证技术。
* SSE 在浏览器端提供了原生的 EventSource 对象，可以方便地监听和处理服务器发送的事件。
* SSE 支持断线重连和消息追踪的功能，可以保证数据的完整性和一致性。
