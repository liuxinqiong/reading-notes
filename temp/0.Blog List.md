## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

## 前端研究
加快传输速度：使用 GraphQL 让客户机只从服务器请求所需的数据

数据模型设计
* 有时候会纠结两个模型之间，谁关联谁的问题，此时可以回归到关系型数据库中外键如何设计
* 针对计算属性，是应该单独请求还是作为字段呢？
* 考虑引入空方案的设计，路由 `plan/0`

## 代码设计
代码设计实践
* 对象组合设计：类 进入某个模式
* 指定某个策略
* 职责链模式
* 柯立化类
* 找稳定的因素

## 技术需求
如何优雅控制元素显隐和副作用，如副作用：桩基墙枝处理、进入生成页
* 墙枝处理完后，通过 setState 控制某些 ui 的显示
* 需要调用 editor 去销毁场景元素

在同一个页面，如何清除副作用
* 多页时，组件销毁重建时，副作用自然消失
* 需要确定一个规则，如组件销毁时，用于清理副作用

全局功能可能会造成的影响
* 切换方案时的当前状态：切换多层、切换3D时同理
* 撤销重做多层的问题

方案生成
* 通过 mode 区分车位排布、设备用房、防火分区
* parent_id 表示项目，set_id 表示方案集，result_id 表示某个方案
* 查询参数 result_id 进入某个方案，此时页面原本的生成按钮消失
* 新增深化设计入口

Vectary UI overview
* 顶部栏：模式切换和工具栏，根据模式的不同，会有不一样的工具栏
* 左侧栏：图层面板和素材
* 右侧栏：默认显示当前画布信息，有选择对象时显示当前对象信息
* 底部栏：控制 bar

产品设计
* model-based-design：自下而上
* scene-based-design：自上而下

## SonarQube
目标
* 代码质量：bug、安全性、复杂度、重复代码、单测
* 代码规范：结构与设计
* 成果可视化

基本使用
* Git Actions
* IDE：SonarLint 扩展
* jenkins 集成：SonarQube 插件
* 项目配置 sonar-project.properties 自定义配置

当前已知问题分析：真假问题
* 部分安全审查的作用没理解到
* 默认规则该挺全面的，连框架层面都有支持

项目实践
* 自定义规则（extend/copy）
* eslint 冲突问题：支持 sonar.eslint.reportPaths 设置导入 eslint 报告
* 仓库级项目配置 sonar-project.properties
* 文件或代码行级别的规则禁用
  * 文件级只能通过配置文件解决
  * 代码级别可通过内置注释 // NOSONAR
* 尽可能使用或兼容 eslint 替换
* 运维更新到最新版 sonar

## rust
相关特性
* 借用和所有权
* 模式匹配
* 生命周期
* 并发编程：支持线程，同时还支持并发，允许在单线程中实现并发

& 符号有两个主要用途，它可以表示引用（reference）和借用（borrowing），* 符号用主要用解引用
* 当用 & 符号创建一个引用时，它创建了对某个值的引用，而不会转移该值的所有权。引用允许你在不拥有值的情况下访问它。引用通常用于函数参数、数据结构中的字段、以及在借用（borrowing）中。
* & 符号还可以用于创建借用，包括可变和不可变的借用。不可变借用允许对值进行只读访问，而可变借用则允许修改值。借用通常用于函数参数，以便在函数中引用数据而不获取所有权。
* 当 * 用于引用类型之前，它表示解引用操作，即访问引用所指向的值。因为在 Rust 中，使用引用时，我们通常使用 & 符号创建引用，而在需要使用引用指向的实际值时，我们使用 * 进行解引用。

在 Rust 中，生命周期通常以撇号（'）加上标识符的方式表示，例如 'a、'b 等。生命周期注解是 Rust 的一部分，用于指定引用之间的关系，使编译器能够验证引用的有效性。

关于生命周期的示例
```rs
struct Foo {
    x: &i32,
}

fn main() {
    let y = &5;
    let f = Foo { x: y };

    println!("{}", f.x);
}
// 上述代码会报错：y的借用被传递到了结构体 y 中，因此必须确保 y 的生命周期比 f 要长，此时我们添加生命周期标记
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5;
    let f = Foo { x: y };

    println!("{}", f.x);
}

// 如下的粒子 i 中，要求 x,y 具备相同的生命周期，但使用的时候由于 b 的生命周期较短，因此会报错提示 b 生命周期不够长
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
fn main() {
    let a = "hello";
    let result;
    {
        let b = String::from("world");
        result = longest(a, b.as_str());
    }
    println!("The longest string is {}", result);
}
```

## server-sent events
严格来说 http 无法向客户端主动发起推送信息，有一个种变通的方法，就是服务端向客户端说明要发送的是流信息，即发送的不是一次性的数据，而是一个数据流会连续不断的发送过来，这时客户端不会关闭连接，会一直等服务器发过来的新数据流，SSE 就是利用这种机制，使用流信息向浏览器推送信息。

基本实现
* 客户端使用 EventSource 对象
* 服务端需要指定 content-type 为 text/event-stream

SSE 相比于其他技术方案，SSE 有以下几个优势：
* SSE 使用更简单，不需要添加任何新组件，只需使用现有的后端语言和框架即可。
* SSE 完全复用现有的 HTTP 协议，因此可以直接运行于现有的代理服务器和认证技术。
* SSE 在浏览器端提供了原生的 EventSource 对象，可以方便地监听和处理服务器发送的事件。
* SSE 支持断线重连和消息追踪的功能，可以保证数据的完整性和一致性。

## 道路编辑
两个关键问题
* 数据更新
  * 使用类似防抖的逻辑，使用全量提交的前提下，中间未提交数据可以舍弃。
  * 数据格式无需打断且允许非法
* 装饰生成速度慢
  * 后端测试，从路网到生成装饰，耗时 10s，这对于前端实时渲染而言是无法接受的
  * 主要慢在过滤重复数据、因此只关注当前操作的线段，去尝试生成和删除原有数据
  * 线段裁剪问题（十字路口，直角路口，丁字路口），建议这一块先忽略
* 原有道路编辑功能，先保留