## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

## 前端研究
加快传输速度：使用 GraphQL 让客户机只从服务器请求所需的数据

数据模型设计
* 有时候会纠结两个模型之间，谁关联谁的问题，此时可以回归到关系型数据库中外键如何设计
* 针对计算属性，是应该单独请求还是作为字段呢？
* 考虑引入空方案的设计，路由 `plan/0`

## 代码设计
代码设计实践
* 对象组合设计：类 进入某个模式
* 指定某个策略
* 职责链模式
* 柯立化类
* 找稳定的因素

## editor 优化
增强 editor
* StaticEditor：针对无须交互场景，提高性能
* getPointerPosition()
* getIntersection(pos)
* getObjectsAtPixel(pixel, targets)

可能的优化
* 对于未激活的功能，监听不应开启，以及辅助元素不应添加到场景
* 更好的 line 支持度：http://evomap.cn/demo/sandbox/sandbox.html#line/line
* 场景常用 dom 元素封装，如 popup

增强事件机制 - 很重要
* 针对 editor 本身事件机制
* 针对 object 的事件机制

事件分类
* 鼠标类 mouse:down | mouse:move | mouse:up
* 物体类 object:modified | object:selected | object:moving | object:scaling | object:rotating | object:added | object:removed

增强基础编辑能力
* 移动、缩放、旋转
* 删除、编辑、复制
* 选择逻辑

增强样式操作
* styling/coloring
* highlight/resetHighlight

相关问题
* 内置的相关对象继承 Object3D，无法通过继承的方式扩展对象
* 整理场景样式修改的情形，如修改线颜色、线宽、线型、面颜色、点颜色、点大小、点型

## 技术需求
如何优雅控制元素显隐和副作用，如副作用：桩基墙枝处理、进入生成页
* 墙枝处理完后，通过 setState 控制某些 ui 的显示
* 需要调用 editor 去销毁场景元素

在同一个页面，如何清除副作用
* 多页时，组件销毁重建时，副作用自然消失
* 需要确定一个规则，如组件销毁时，用于清理副作用

全局功能可能会造成的影响
* 切换方案时的当前状态：切换多层、切换3D时同理
* 撤销重做多层的问题

方案生成
* 通过 mode 区分车位排布、设备用房、防火分区
* parent_id 表示项目，set_id 表示方案集，result_id 表示某个方案
* 查询参数 result_id 进入某个方案，此时页面原本的生成按钮消失
* 新增深化设计入口

Vectary UI overview
* 顶部栏：模式切换和工具栏，根据模式的不同，会有不一样的工具栏
* 左侧栏：图层面板和素材
* 右侧栏：默认显示当前画布信息，有选择对象时显示当前对象信息
* 底部栏：控制 bar

产品设计
* model-based-design：自下而上
* scene-based-design：自上而下

## 微信登录
OpenID vs UnionID：为了识别用户，每个用户针对每个公众号会产生一个安全的 OpenID，如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的 OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个 UnionID。因此感觉绑定 UnionID 比较通用。

state：用于预防 csrf 攻击，因为拥有 code 的 redirect_uri 地址一旦被劫持，此时通过 csrf 手段诱导其他用户访问该链接，就会导致认证信息错误认证，因为 redirect_uri 是没有发起者用户信息的，换一个用户访问也会认证通过，导致的后果就是，你把你账号绑定了别人的微信。为了应对这种情况，引入了 state 参数，用于保持请求和回调的状态，在回调时，会在查询参数时回传该参数，开发者可以通过该参数验证请求有效性。要求这个参数不可预测，又必须充分证明 client 和当前第三方网站的登录认证状态存在关联，如果存在过期时间则更好。

相关接口描述
* 新增 wx_config 接口，用于返回 appid，目前感觉接口写死即可。（前端也可写死，但感觉交给后端更好一点）
* 新增 wx_userinfo 接口，目前后端直接调 access_token 接口即可，只需要 UnionID，如需要更多信息，需要调 userinfo 接口
* 修改 login 接口，支持通过 UnionID 登录
* 修改 register 接口，支持通过 UnionID 注册
* 新增 patch user/current 用户更改用户信息，绑定与解绑微信

## StrictMode
Strict Mode 在开发环境下表现
* 组件将额外渲染一次，以发现由于不纯渲染导致的问题
* 组件将额外执行依次 effects，以发现由于没有 cleanup 导致的问题
* 检查过期 api 的使用

## WebGL 补充
WebGL 内置变量-顶点着色器
* gl_PointSize 用于 vertex shader 写光栅化后的点像素大小
* gl_Vertex 物体空间的顶点位置
* gl_Position 用于 vertex shader 写顶点位置
* gl_Color 顶点主颜色
* gl_Normal 顶点法线值

WebGL 内置变量-片元着色器
* gl_FragColor 用于 fragment shader 写片元颜色值
* gl_FragCoord 只读，片元的像素坐标，当前渲染的像素在画布内的坐标，左上角是[0,0]，右下角是[width,height]
* gl_PointCoord 点精灵的二维空间坐标范围在 (0.0, 0.0) 到 (1.0, 1.0) 之间，仅用于点图元和点精灵开启的情况下
* gl_FrontFacing 用于判断 fragment 是否属于 front-facing primitive，只读；bool
* gl_FragDepth 输出变量，我们可以使用它来在着色器内设置片段的深度值，如果着色器没有写入值到 gl_FragDepth，它会自动取用 gl_FragCoord.z 的值。在写入gl_FragDepth时，你就需要考虑到它所带来的性能影响。

内置函数
* 角度函数 radians/degree
* 三角函数 sin/cos/tan/asin/acos/atan
* 指数函数 pow/exp/log/exp2/log2/sqrt
* 通用函数 abs/min/max/mod/sign/floor/ceil/clamp
  * mix 线性内插：mix(colorA, colorB, weight)，两种颜色混合，其中 weight 代表 B 的权重，1-weight 代表 A 的权重。
  * step 步进函数：step(a, b)，当 b>a 时返回 1，当 a>b 时返回 0
  * smoothstep(edge0, edge1, x) 当 edge0 < x < edge1 时，smoothstep()在 0 和 1 之间执行平滑埃尔米特插值。
  * fract 取小数部分
  * lerp(a, b, x)：当 x=0 时返回 a，当 x=1 时返回 b，否则返回 ab 的差值
* 几何函数 length/distance/dot/cross/normalize/reflect/faceforward
  * reflect：返回一个向量相对于某个法向量的反射向量
* 矩阵函数 matrixCmpMult 逐元素乘法
  * 注意：不是按照线性代数中的矩阵乘法规则执行的，如果是线性代数中矩阵乘法规则，直接使用乘法符号 `*` 就可以，即 `x*y`
  * 内置矩阵函数 matrixCompMult() 的运算规则是同行同列的元素相乘，也就是 `x[i][j]` 和 `y[i][j]` 相乘
* 矢量函数 lessThan/lessThanEqual/greaterThan/greaterThanEqual/equal/notEqual/any/all/not
* 纹理查询函数
  * texture2D 在二维纹理中获取纹素
  * textureCube 从立方体纹理中获取纹素

长宽适配。在分辨率长宽不等的情况下，将坐标系映射为等边，映射后原先较长的一边其自变量会变大。举例：将一个正方形图贴在一个长方形上，此时图会被拉升，进行适配后则可以维持图片比例不变。
```js
uv.x *= u_resolution.x / u_resolution.y;
```

两个 step 或 smoothstep 相减，可以用来划线
```js
#version 300 es
precision highp float;
out vec4 FragColor;
uniform vec2 resolution;
void main() {
  vec2 st = gl_FragCoord.xy / resolution;
  vec2 center = vec2(0.5);
  float d = length(st - center);
  FragColor.rgb = (smoothstep(d - 0.015, d, 0.2) - smoothstep(d, d + 0.015, 0.18)) * vec3(1.0);
  FragColor.a = 1.0;
}
```

距离场构图法，最核心的思路是要定义一个形状的距离场，通俗来说，就是定义整个画布空间中每个像素点的距离值。

如果要绘制一条连续曲线，我们可以取相邻的三个点 A、B、C 采样，计算 P 点到这三个点构成的两条线段 AB 和 AC 的距离，取距离短的作为 P 到曲线的距离。

通过 `st = mix(vec2(-10, -10), vec2(10, 10), st);` 来扩大坐标系的区间，将坐标系从 `(0,0),(1,1)` 扩大到了 `(-10,-10),(10,10)`，这也是一种常用的数学技巧，可以牢记。

通过 `gl_FragCoord.xy / resolution` 可以将坐标值“归一”（即将值限制到 0~1 区间，这是一种在写着色器的时候经常使用的数学技巧）

网格技巧：将 uv 拉升 n 倍后取小数部分，处理后的 uv 会变成每个网格内的局部坐标，这个被广泛使用。

三角形绘制：定义点到三角形的距离为点到三角形三条边距离中最短的一条边的距离。

如果要在画布上绘制多个相同图形，不必一一绘制每一个图形，要我们有一些数学手段可以运用。
* 可以扩大 st 或 d 的值，然后对它取小数部分
* 这是两种不同的重复效果

容易搞混的坐标系
* uv：左下角是 [0, 0]，右上角是 [1, 1]
* FragCoord：左上角是 [0,0]，右下角是 [width, height]
* PointCoord：左上角是 [0, 0]，右下角是 [1.0, 1.0]

入门教程
* [充分理解WebGL（一）](https://juejin.cn/post/7098256201661546532)
* [基于three.js实现一个粒子系统](https://juejin.cn/post/6844904161574649870)

目前 Editor 中关于 Line 的使用
* MeshLine3D 存在问题：跟着相机不断调整朝向
* MeshPath3D 存在问题：无法支持特定像素大小

TODO
* 理解 uniform 传递 resolution 的作用
* 理解 sizeAttenuation 实现原理
  * false 所有粒子都将拥有一样的尺寸，无论距离多远
  * true 粒子大小将取决于相机远近

通常物体走的固有变换是
```js
void main() {
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );
}
```

SpriteMaterial 中 sizeAttenuation 实现原理
```js
void main() {
  // ……
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
  // vertex shader 中
  #ifndef USE_SIZEATTENUATION
    bool isPerspective = isPerspectiveMatrix( projectionMatrix );

    if ( isPerspective ) scale *= - mvPosition.z;
  #endif

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
  // ……
}
```

关键代码 `scale *= - mvPosition.z;` 为什么是合理的？注意，一个是 ifdef 一个是 ifndef

对比 PointsMaterial 实现
```js
void main() {
  gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
    // 离得越远，则 scale/-mvPosition.z 越小，从而实现衰减效果
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif

}
```


有意思：由于 step 返回值总是为 0 和 1，因此可以通过加、减、乘实现位运算，smoothstep 会出现中间值，此处不考虑。下面例子就是使用减法，实现组合 Circle 的方式绘制一张脸
```js
float Circle(vec2 uv, vec2 o, float r, float blur) {
  return smoothstep(r, r - blur, distance(uv, o));
}

float Face(vec2 uv, vec2 o) {
  float c = Circle(uv, vec2(.0, .0), 0.5, 0.01);
  c -= Circle(uv, vec2(-.2, -.2), 0.2, 0.01);
  c -= Circle(uv, vec2(.2, .2), 0.2, 0.01);
  return c;
}
```

总结常用函数：fract、mix、step、smoothstep、伪随机

TODO：深入理解 normalMatrix

#include 机制
* 开始以为是 glsl 语法，实际上是 three.js 尝试引入的模块机制
* 在 WebGLProgram 模块中对 #include 指令进行解析，配合 ShaderChunk 对象进行解析

## SonarQube
目标
* 代码质量：复杂度、重复代码、单测、潜在 bug、结构与设计
* 代码规范
* 代码安全性
* 成果可视化

基本使用
* Git Actions
* IDE：SonarLint 扩展
* jenkins 集成：SonarQube 插件
* 项目配置 sonar-project.properties 自定义配置

工具冲突问题：sonarQube vs eslint
* 支持 sonar.eslint.reportPaths 设置导入 eslint 报告

当前已知问题分析：真假问题
* 部分安全审查的作用没理解到
* 默认规则该挺全面的，连框架层面都有支持

## meshline vs line2
meshline vs line2
* meshline 是社区方案，目前处于不维护状态，line2 属于官方内置示例
* meshline 虚线绘制过于紧密，line2 表现良好
* 三维视角下，都存在正面不是维持向上问题
* line2 设置透明度后，顶点重叠部分效果不好（之前也正是因为该原因不支持透明度）

我们如何确定一个颜色
* 为什么是三原色？因为人类对色彩的感知结果位于一个三维的线性空间中。最少需要三种颜色的光才能有足够的表达能力来表现各种颜色
* 为什么选 RGB 作为三原色？因为色彩空间不是真正数学意义上的线性空间，从工程角度考虑，以 RGB 作为三原色，能让显示器能够显示更多的颜色
* 对于 RGB 色彩空间来说，关键点在于两个：1. 如何选择三个作为基底的颜色；2. 如何定义白色。一旦选好这两个关键参数，那么从 CIE XYZ 空间到设备的 RGB 空间的转换就完全确定了
* 不同的 RGB 空间所能表示的颜色范围是不一样的，并且我们可以推断出，即使是同样的 RGB 分量，在不同的 RGB 空间中所代表的颜色也是不一样的。所以我们在描述一个 RGB 颜色的时候，不仅需要描述它的 RGB 三个分量，还要说明是在哪个空间，这就是 ICC 文件的作用
* 常见的网络环境下图片的色彩空间是 sRGB，有很多浏览器不能正确地解析图片自带的色彩空间说明，默认按照 sRGB 来进行解析。

three.js 颜色空间
* 颜色空间由基色、白点、转换函数
* 常用空间 sRGB 和 Linear-sRGB，两者都使用相同的基色和白点，因此具有相同的颜色范围，都使用 RGB 颜色模型，它们仅在传输函数上有所不同
  * Linear-sRGB 相对于物理光强度是线性的。
  * sRGB 使用非线性 sRGB 传递函数，更接近于人眼感知光的方式和普通显示设备的灵敏度
* 这种区别很重要。光照计算和其他渲染操作通常必须在线性色彩空间中进行。然而，线性颜色存储在图像或帧缓冲区中的效率较低，并且在由人类观察者观看时看起来不正确。因此，输入纹理和最终渲染的图像通常会使用非线性的sRGB色彩空间。

颜色空间中三个角色
* 输入颜色空间：纹理、三维模型等资源都会有关联的颜色空间，不是 Linear-sRGB 颜色空间的必须被转换，在开启了 ColorManagement 后，某些转换(对于sRGB中的十六进制和CSS颜色)可以自动进行
* 工作颜色空间：渲染、插值和许多其他操作必须在开放域线性工作色彩空间中执行，其中 RGB 分量与物理照明成比例。在 three.js 中，工作颜色空间是 Linear-sRGB。
* 输入颜色空间：输出到显示设备、图像或视频可能涉及从开放域 Linear-sRGB 工作色彩空间到另一个色彩空间的转换。这种转换可以在主渲染通道(WebGLRenderer.outputColorSpace)中执行，也可以在后期处理期间执行。自定义着色器必须实现自己的输出颜色空间转换。

关于色彩系统的重要破坏性更新：https://discourse.threejs.org/t/updates-to-color-management-in-three-js-r152/50791

## 深化编辑
深化编辑关键点（决定技术该如何选型）：编辑后是否需要保持某种全局关系
* 车位通达性
* 全局柱网的对齐
* 避障逻辑

三种编辑生成功能
* 策略批量生成
* 指定元素编辑：不会影响到其他已有元素吧
* 区域编辑重排：策略调整+路网调整+塔楼边策略，这里感觉只能放后端，与已有算法重合

## wasm
为什么 rust+wasm 方案
* wasm 大小是很重要的，因为其需要通过网络传播，rust 没有运行时，可以使 wasm 体积更小，因为没有像垃圾收集器那样额外的运行时，您只为实际使用的功能支付。
* 不需要重写任何东西，你可以将对性能最敏感的 JavaScript 函数移植到 Rust 开始，以立即获得好处
* rust+wasm 与现有的 JavaScript 工具集成良好，它支持 esm，你可以继续使用你喜欢的工具，比如 npm 和 webpack

什么是 wasm
* wasm 是一种简单的机器模型和具有广泛规范的可执行格式。它被设计成便携，紧凑，并以或接近本机速度执行。
* wasm 有一个文本格式(.wat)和一个二进制格式(.wasm)。
* 线性内存（Linear Memory）
* 一种“可移植的可执行”格式，并在各种上下文中使用。

环境准备
* 安装 rust 生态：rustup, rustc, and cargo
* 安装 wasm 支持：wasm-pack
* 安装 cargo-generate 快速创建项目
* 关键依赖 wasm-bindgen
  * 导入 js and 导出 rust
  * 允许 js/wasm 与字符串，js 对象，类等进行通信，而不是纯整数和浮点。
* 运行 wasm-pack build 命令会产出一个 npm 包，还支持 ts
  * package.json & readme.md
  * a.js & a.d.ts & a.wasm
  * a.js 是由 wasm-bindgen 产出的胶水文件，导入 DOM 或 js 函数给 rust，并向 js 提供 wasm 函数的 API。

最重要的概念
* JavaScript 的垃圾收集堆(对象、数组和 DOM 节点在其中分配)与 WebAssembly 的线性内存空间(Rust 值在其中)不同。
* WebAssembly 目前无法直接访问垃圾收集的堆。另一方面，JavaScript 可以读写到 WebAssembly 线性内存空间，但仅作为标量值（u8, i32, f64等...）的数组。WebAssembly 函数还具有并返回标量值。这些是所有 WebAssembly 和JavaScript 通信的构成块。
* wasm_bindgen 定义了如何跨界处理复杂结构，它包括对 Rust 结构进行装箱，并将指针包装在 JavaScript 类中以提高可用性，或者从 Rust 中将其索引到 JavaScript 对象表中。
* 在设计 WebAssembly 和 JavaScript 之间的接口时，我们希望优化以下属性
  * 最小化 WebAssembly 线性内存的复制。不必要的拷贝会带来不必要的开销。
  * 最小化序列化和反序列化。wasm_bindgen 帮助我们定义和使用 JavaScript 对象或盒装 Rust 结构的不透明句柄。

作为一般的经验法则，一个好的 JavaScript+WebAssembly 接口设计通常是这样的：大型的、长期存在的数据结构被实现为存在于 WebAssembly 线性内存中的 Rust 类型，并作为不透明句柄暴露给 JavaScript。JavaScript 调用导出的WebAssembly 函数，这些函数接受这些不透明句柄，转换它们的数据，执行大量计算，查询数据，并最终返回一个小的、可复制的结果。通过仅返回计算的小结果，我们避免在 JavaScript 垃圾收集的堆和 WebAssembly 线性内存之间来回复制和/或序列化所有内容。

两个关键概念
* 内存 Memory：可变长的 ArrayBuffer，能够被实例存取的原始字节内存。
* 表格 Table：可变长类型数组，存储诸如函数引用之类的不透明值并且能够被实例存取。

基础语法
```rust
// 导入预设 -- use 从外部库导入模块，而 mod 创建只能在当前文件中使用的内部模块。
use wasm_bindgen::prelude::*;

// 表示它下面的函数在 JavaScript 和 Rust 中都可以访问。
// extern 块将外部 JavaScript 函数 alert 导入 Rust
#[wasm_bindgen]
extern {
    fn alert(s: &str);
}
```

rust 针对 wasm 拓展
* js-sys
* web-sys：wasm 操作 web api
