## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

## 前端研究
加快传输速度：使用 GraphQL 让客户机只从服务器请求所需的数据

数据模型设计
* 有时候会纠结两个模型之间，谁关联谁的问题，此时可以回归到关系型数据库中外键如何设计
* 针对计算属性，是应该单独请求还是作为字段呢？
* 考虑引入空方案的设计，路由 `plan/0`

## 代码设计
代码设计实践
* 对象组合设计：类 进入某个模式
* 指定某个策略
* 职责链模式
* 柯立化类
* 找稳定的因素

## editor 优化
增强 editor
* StaticEditor：针对无须交互场景，提高性能
* getPointerPosition()
* getIntersection(pos)
* getObjectsAtPixel(pixel, targets)

可能的优化
* 对于未激活的功能，监听不应开启，以及辅助元素不应添加到场景
* 更好的 line 支持度：http://evomap.cn/demo/sandbox/sandbox.html#line/line
* 场景常用 dom 元素封装，如 popup

增强事件机制 - 很重要
* 针对 editor 本身事件机制
* 针对 object 的事件机制

事件分类
* 鼠标类 mouse:down | mouse:move | mouse:up
* 物体类 object:modified | object:selected | object:moving | object:scaling | object:rotating | object:added | object:removed

增强基础编辑能力
* 移动、缩放、旋转
* 删除、编辑、复制
* 选择逻辑

增强样式操作
* styling/coloring
* highlight/resetHighlight

相关问题
* 内置的相关对象继承 Object3D，无法通过继承的方式扩展对象
* 整理场景样式修改的情形，如修改线颜色、线宽、线型、面颜色、点颜色、点大小、点型

## 技术需求
如何优雅控制元素显隐和副作用，如副作用：桩基墙枝处理、进入生成页
* 墙枝处理完后，通过 setState 控制某些 ui 的显示
* 需要调用 editor 去销毁场景元素

在同一个页面，如何清除副作用
* 多页时，组件销毁重建时，副作用自然消失
* 需要确定一个规则，如组件销毁时，用于清理副作用

全局功能可能会造成的影响
* 切换方案时的当前状态：切换多层、切换3D时同理
* 撤销重做多层的问题

方案生成
* 通过 mode 区分车位排布、设备用房、防火分区
* parent_id 表示项目，set_id 表示方案集，result_id 表示某个方案
* 查询参数 result_id 进入某个方案，此时页面原本的生成按钮消失
* 新增深化设计入口

Vectary UI overview
* 顶部栏：模式切换和工具栏，根据模式的不同，会有不一样的工具栏
* 左侧栏：图层面板和素材
* 右侧栏：默认显示当前画布信息，有选择对象时显示当前对象信息
* 底部栏：控制 bar

产品设计
* model-based-design：自下而上
* scene-based-design：自上而下

## 微信登录
OpenID vs UnionID：为了识别用户，每个用户针对每个公众号会产生一个安全的 OpenID，如果需要在多公众号、移动应用之间做用户共通，则需前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的 OpenID，但他对所有这些同一开放平台账号下的公众号和应用，只有一个 UnionID。因此感觉绑定 UnionID 比较通用。

state：用于预防 csrf 攻击，因为拥有 code 的 redirect_uri 地址一旦被劫持，此时通过 csrf 手段诱导其他用户访问该链接，就会导致认证信息错误认证，因为 redirect_uri 是没有发起者用户信息的，换一个用户访问也会认证通过，导致的后果就是，你把你账号绑定了别人的微信。为了应对这种情况，引入了 state 参数，用于保持请求和回调的状态，在回调时，会在查询参数时回传该参数，开发者可以通过该参数验证请求有效性。要求这个参数不可预测，又必须充分证明 client 和当前第三方网站的登录认证状态存在关联，如果存在过期时间则更好。

相关接口描述
* 新增 wx_config 接口，用于返回 appid，目前感觉接口写死即可。（前端也可写死，但感觉交给后端更好一点）
* 新增 wx_userinfo 接口，目前后端直接调 access_token 接口即可，只需要 UnionID，如需要更多信息，需要调 userinfo 接口
* 修改 login 接口，支持通过 UnionID 登录
* 修改 register 接口，支持通过 UnionID 注册
* 新增 patch user/current 用户更改用户信息，绑定与解绑微信

## StrictMode
Strict Mode 在开发环境下表现
* 组件将额外渲染一次，以发现由于不纯渲染导致的问题
* 组件将额外执行依次 effects，以发现由于没有 cleanup 导致的问题
* 检查过期 api 的使用

## WebGL 补充
WebGL 内置变量-顶点着色器
* gl_PointSize 用于 vertex shader 写光栅化后的点像素大小
* gl_Vertex 物体空间的顶点位置
* gl_Position 用于 vertex shader 写顶点位置
* gl_Color 顶点主颜色
* gl_Normal 顶点法线值

WebGL 内置变量-片元着色器
* gl_FragColor 用于 fragment shader 写片元颜色值
* gl_FragCoord 只读，片元的像素坐标，当前渲染的像素在画布内的坐标，左上角是[0,0]，右下角是[width,height]
* gl_PointCoord 点精灵的二维空间坐标范围在 (0.0, 0.0) 到 (1.0, 1.0) 之间，仅用于点图元和点精灵开启的情况下
* gl_FrontFacing 用于判断 fragment 是否属于 front-facing primitive，只读；bool
* gl_FragDepth 输出变量，我们可以使用它来在着色器内设置片段的深度值，如果着色器没有写入值到 gl_FragDepth，它会自动取用 gl_FragCoord.z 的值。在写入gl_FragDepth时，你就需要考虑到它所带来的性能影响。

内置函数
* 角度函数 radians/degree
* 三角函数 sin/cos/tan/asin/acos/atan
* 指数函数 pow/exp/log/exp2/log2/sqrt
* 通用函数 abs/min/max/mod/sign/floor/ceil/clamp
  * mix 线性内插：mix(colorA, colorB, weight)，两种颜色混合，其中 weight 代表 B 的权重，1-weight 代表 A 的权重。
  * step 步进函数：step(a, b)，当 b>a 时返回 1，当 a>b 时返回 0
  * smoothstep(edge0, edge1, x) 当 edge0 < x < edge1 时，smoothstep()在 0 和 1 之间执行平滑埃尔米特插值。
  * fract 取小数部分
  * lerp(a, b, x)：当 x=0 时返回 a，当 x=1 时返回 b，否则返回 ab 的差值
* 几何函数 length/distance/dot/cross/normalize/reflect/faceforward
  * reflect：返回一个向量相对于某个法向量的反射向量
* 矩阵函数 matrixCmpMult 逐元素乘法
  * 注意：不是按照线性代数中的矩阵乘法规则执行的，如果是线性代数中矩阵乘法规则，直接使用乘法符号 `*` 就可以，即 `x*y`
  * 内置矩阵函数 matrixCompMult() 的运算规则是同行同列的元素相乘，也就是 `x[i][j]` 和 `y[i][j]` 相乘
* 矢量函数 lessThan/lessThanEqual/greaterThan/greaterThanEqual/equal/notEqual/any/all/not
* 纹理查询函数
  * texture2D 在二维纹理中获取纹素
  * textureCube 从立方体纹理中获取纹素

长宽适配。在分辨率长宽不等的情况下，将坐标系映射为等边，映射后原先较长的一边其自变量会变大。举例：将一个正方形图贴在一个长方形上，此时图会被拉升，进行适配后则可以维持图片比例不变。
```js
uv.x *= u_resolution.x / u_resolution.y;
```

两个 step 或 smoothstep 相减，可以用来划线
```js
#version 300 es
precision highp float;
out vec4 FragColor;
uniform vec2 resolution;
void main() {
  vec2 st = gl_FragCoord.xy / resolution;
  vec2 center = vec2(0.5);
  float d = length(st - center);
  FragColor.rgb = (smoothstep(d - 0.015, d, 0.2) - smoothstep(d, d + 0.015, 0.18)) * vec3(1.0);
  FragColor.a = 1.0;
}
```

距离场构图法，最核心的思路是要定义一个形状的距离场，通俗来说，就是定义整个画布空间中每个像素点的距离值。

如果要绘制一条连续曲线，我们可以取相邻的三个点 A、B、C 采样，计算 P 点到这三个点构成的两条线段 AB 和 AC 的距离，取距离短的作为 P 到曲线的距离。

通过 `st = mix(vec2(-10, -10), vec2(10, 10), st);` 来扩大坐标系的区间，将坐标系从 `(0,0),(1,1)` 扩大到了 `(-10,-10),(10,10)`，这也是一种常用的数学技巧，可以牢记。

通过 `gl_FragCoord.xy / resolution` 可以将坐标值“归一”（即将值限制到 0~1 区间，这是一种在写着色器的时候经常使用的数学技巧）

网格技巧：将 uv 拉升 n 倍后取小数部分，处理后的 uv 会变成每个网格内的局部坐标，这个被广泛使用。

三角形绘制：定义点到三角形的距离为点到三角形三条边距离中最短的一条边的距离。

如果要在画布上绘制多个相同图形，不必一一绘制每一个图形，要我们有一些数学手段可以运用。
* 可以扩大 st 或 d 的值，然后对它取小数部分
* 这是两种不同的重复效果

容易搞混的坐标系
* uv：左下角是 [0, 0]，右上角是 [1, 1]
* FragCoord：左上角是 [0,0]，右下角是 [width, height]
* PointCoord：左上角是 [0, 0]，右下角是 [1.0, 1.0]

入门教程
* [充分理解WebGL（一）](https://juejin.cn/post/7098256201661546532)
* [基于three.js实现一个粒子系统](https://juejin.cn/post/6844904161574649870)

目前 Editor 中关于 Line 的使用
* MeshLine3D 存在问题：跟着相机不断调整朝向
* MeshPath3D 存在问题：无法支持特定像素大小

TODO
* 理解 uniform 传递 resolution 的作用
* 理解 sizeAttenuation 实现原理
  * false 所有粒子都将拥有一样的尺寸，无论距离多远
  * true 粒子大小将取决于相机远近

通常物体走的固有变换是
```js
void main() {
  gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4( position, 1.0 );
}
```

SpriteMaterial 中 sizeAttenuation 实现原理
```js
void main() {
  // ……
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
  // vertex shader 中
  #ifndef USE_SIZEATTENUATION
    bool isPerspective = isPerspectiveMatrix( projectionMatrix );

    if ( isPerspective ) scale *= - mvPosition.z;
  #endif

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
  // ……
}
```

关键代码 `scale *= - mvPosition.z;` 为什么是合理的？注意，一个是 ifdef 一个是 ifndef

对比 PointsMaterial 实现
```js
void main() {
  gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
    // 离得越远，则 scale/-mvPosition.z 越小，从而实现衰减效果
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif

}
```


有意思：由于 step 返回值总是为 0 和 1，因此可以通过加、减、乘实现位运算，smoothstep 会出现中间值，此处不考虑。下面例子就是使用减法，实现组合 Circle 的方式绘制一张脸
```js
float Circle(vec2 uv, vec2 o, float r, float blur) {
  return smoothstep(r, r - blur, distance(uv, o));
}

float Face(vec2 uv, vec2 o) {
  float c = Circle(uv, vec2(.0, .0), 0.5, 0.01);
  c -= Circle(uv, vec2(-.2, -.2), 0.2, 0.01);
  c -= Circle(uv, vec2(.2, .2), 0.2, 0.01);
  return c;
}
```

总结常用函数：fract、mix、step、smoothstep、伪随机

TODO：深入理解 normalMatrix

#include 机制
* 开始以为是 glsl 语法，实际上是 three.js 尝试引入的模块机制
* 在 WebGLProgram 模块中对 #include 指令进行解析，配合 ShaderChunk 对象进行解析

## SonarQube
目标
* 代码质量：bug、安全性、复杂度、重复代码、单测
* 代码规范：结构与设计
* 成果可视化

基本使用
* Git Actions
* IDE：SonarLint 扩展
* jenkins 集成：SonarQube 插件
* 项目配置 sonar-project.properties 自定义配置

工具冲突问题：sonarQube vs eslint
* 支持 sonar.eslint.reportPaths 设置导入 eslint 报告

当前已知问题分析：真假问题
* 部分安全审查的作用没理解到
* 默认规则该挺全面的，连框架层面都有支持

项目实践
* 自定义规则（extend/copy）
* 仓库级项目配置
* 文件或代码行级别的规则禁用
* 尽可能使用或兼容 eslint
* 运维更新到最新版 sonar

## meshline vs line2
meshline vs line2
* meshline 是社区方案，目前处于不维护状态，line2 属于官方内置示例
* meshline 虚线绘制过于紧密，line2 表现良好
* 三维视角下，都存在正面不是维持向上问题
* line2 设置透明度后，顶点重叠部分效果不好（之前也正是因为该原因不支持透明度）

我们如何确定一个颜色
* 为什么是三原色？因为人类对色彩的感知结果位于一个三维的线性空间中。最少需要三种颜色的光才能有足够的表达能力来表现各种颜色
* 为什么选 RGB 作为三原色？因为色彩空间不是真正数学意义上的线性空间，从工程角度考虑，以 RGB 作为三原色，能让显示器能够显示更多的颜色
* 对于 RGB 色彩空间来说，关键点在于两个：1. 如何选择三个作为基底的颜色；2. 如何定义白色。一旦选好这两个关键参数，那么从 CIE XYZ 空间到设备的 RGB 空间的转换就完全确定了
* 不同的 RGB 空间所能表示的颜色范围是不一样的，并且我们可以推断出，即使是同样的 RGB 分量，在不同的 RGB 空间中所代表的颜色也是不一样的。所以我们在描述一个 RGB 颜色的时候，不仅需要描述它的 RGB 三个分量，还要说明是在哪个空间，这就是 ICC 文件的作用
* 常见的网络环境下图片的色彩空间是 sRGB，有很多浏览器不能正确地解析图片自带的色彩空间说明，默认按照 sRGB 来进行解析。

three.js 颜色空间
* 颜色空间由基色、白点、转换函数
* 常用空间 sRGB 和 Linear-sRGB，两者都使用相同的基色和白点，因此具有相同的颜色范围，都使用 RGB 颜色模型，它们仅在传输函数上有所不同
  * Linear-sRGB 相对于物理光强度是线性的。
  * sRGB 使用非线性 sRGB 传递函数，更接近于人眼感知光的方式和普通显示设备的灵敏度
* 这种区别很重要。光照计算和其他渲染操作通常必须在线性色彩空间中进行。然而，线性颜色存储在图像或帧缓冲区中的效率较低，并且在由人类观察者观看时看起来不正确。因此，输入纹理和最终渲染的图像通常会使用非线性的sRGB色彩空间。

颜色空间中三个角色
* 输入颜色空间：纹理、三维模型等资源都会有关联的颜色空间，不是 Linear-sRGB 颜色空间的必须被转换，在开启了 ColorManagement 后，某些转换(对于sRGB中的十六进制和CSS颜色)可以自动进行
* 工作颜色空间：渲染、插值和许多其他操作必须在开放域线性工作色彩空间中执行，其中 RGB 分量与物理照明成比例。在 three.js 中，工作颜色空间是 Linear-sRGB。
* 输入颜色空间：输出到显示设备、图像或视频可能涉及从开放域 Linear-sRGB 工作色彩空间到另一个色彩空间的转换。这种转换可以在主渲染通道(WebGLRenderer.outputColorSpace)中执行，也可以在后期处理期间执行。自定义着色器必须实现自己的输出颜色空间转换。

关于色彩系统的重要破坏性更新：https://discourse.threejs.org/t/updates-to-color-management-in-three-js-r152/50791

## 深化编辑
深化编辑关键点（决定技术该如何选型）：编辑后是否需要保持某种全局关系
* 车位通达性
* 全局柱网的对齐
* 避障逻辑

三种编辑生成功能
* 策略批量生成
* 指定元素编辑：不会影响到其他已有元素吧
* 区域编辑重排：策略调整+路网调整+塔楼边策略，这里感觉只能放后端，与已有算法重合

## wasm
开发软件时使用 wasm 的常见方式
* 纯 wasm 实现，包括 ui 和逻辑
* UI 使用 HTML/CSS/JS，逻辑计算使用 wasm
* 复用其他语言的库，使用 wasm 移植到已有的 web 软件中

现有的使用 wasm 编写的应用
* Google Earth
* AutoCAD Web
* PhotoShop Web：Web 端和 PC 端由一份编码编译生成
* Figma：wasm+rust 的 web 应用框架 zaplib
* bilibili：wasm 版的 FFmpeg/tensorflow

为什么 rust+wasm 方案
* wasm 大小是很重要的，因为其需要通过网络传播，由于 rust 没有像垃圾收集器那样额外的运行时，可以使 wasm 体积更小，您只为实际使用的功能买单。
* 不需要重写任何东西，你可以将对性能最敏感的 js 函数移植到 rust 开始，以立即获得好处。
* rust+wasm 与现有的 js 工具集成良好，它支持 esm，你可以继续使用你喜欢的工具，比如 npm 和 webpack。

什么是 wasm
* wasm 是一种简单的机器模型和具有广泛规范的可执行格式。被设计成便携，紧凑，并以或接近本机速度执行，并支持在各种上下文中使用。
* wasm 有一个文本格式(.wat)和一个二进制格式(.wasm)。
* 线性内存（Linear Memory）
  * 一种内存寻址技术，其中内存被组织在一块线性地址空间中，也被成为扁平内存模型，线性内存模型使理解、编程、和表示内存变得更容易，js 和 wasm 可以同步的读写内存
  * 缺点就是重新排列内存中的元素需要大量的执行时间，并且会浪费大量的内存区域

wasm 的局限性
* 复杂数据类型需要进行编解码，对于除数字、字符串以外的类型，如对象、数组需要先编码成二进制再存放到 wasm 内存段里
* 与 js 胶水代码的交互带来的性能损耗一定程度上抵消了 wasm 本身带来的性能提升

环境准备
* 安装 rust 生态：rustup, rustc, and cargo
* 安装 wasm 支持：wasm-pack
* 安装 cargo-generate 快速创建项目
* 关键依赖 wasm-bindgen
  * 导入 js 以及导出 rust
  * 允许 js/wasm 与字符串，js 对象，类等进行通信，而不是纯整数和浮点数
* 运行 wasm-pack build 命令会产出一个 npm 包，还支持 ts
  * package.json & readme.md
  * a.js & a.d.ts & a.wasm
  * a.js 是由 wasm-bindgen 产出的胶水文件，导入 dom 或 js 函数给 rust，并向 js 提供 wasm 函数的 api

> target wasm32-unknown-unknown：指示编译器该代码可以在任何机器上编译并在任何机器上运行。这将创建可以在任何机器上运行的 WebAssembly 模块

web 端使用示例
```js
(async () => {
    const bytes = await fetch("target/wasm32-unknown-unknown/debug/car_fib.wasm");
    const response = await bytes.arrayBuffer();
    const result = await WebAssembly.instantiate(response, {});
    console.log(result.instance.exports.add(10,3));
})();
```

我们可以简单调试一下 string 的解编码
```js
function getStringFromWasm0(ptr, len) {
  // 当我们的字符串是 【123我】 时，此时 len 为 6，因为 utf-8 编码中，123各一个字节，中文三个字节，结果为 49, 50, 51, 230, 136, 145，然后交给 TextDecoder 解码即可
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
```

最重要的概念
* js 的垃圾收集堆(分配对象、数组和 dom 节点的地方)与 wasm 的线性内存空间不同。
* wasm 目前无法直接访问垃圾收集的堆。js 可以读写 wasm 线性内存空间，但仅作为标量值（u8, i32, f64等...）的 ArrayBuffer。wasm 函数也接受和返回标量值。
* wasm_bindgen 定义了如何跨界处理复杂结构，它包括装箱 rust 结构，并将指针包装在 js 类中以提高可用性，或者从 rust 中索引到 js 对象表。
* 在设计 wasm 和 js 之间的接口时，我们希望优化以下属性
  * 最小化 wasm 线性内存的复制，不必要的拷贝会带来不必要的开销。
  * 最小化序列化和反序列化。与拷贝类似，序列化和反序列化也会产生开销，并且通常也会产生复制。如果我们将一个不透明的句柄传递给数据结构，而不是在一侧序列化它，将它复制到 wasm 线性内存中的某个位置，然后在另一侧反序列化，通常可以减少很多开销。wasm_bindgen 帮助我们定义和使用 js 对象或盒装 rust 结构的不透明句柄。

作为一般的经验法则，一个好的 js+wasm 接口设计通常是这样的：大型的、长期存在的数据结构被实现为 rust 类型，这些类型存在于 wasm 线性内存中，并作为不透明句柄暴露给 js。js 调用导出的 wasm 函数，这些函数接受这些不透明句柄，转换它们的数据，执行大量计算，查询数据，并最终返回一个小的、可复制的结果。通过仅返回计算的最小结果，我们避免在 js 垃圾收集的堆和 wasm 线性内存之间来回复制和/或序列化所有内容。
```rust
use wasm_bindgen::prelude::*;

// 定义一个简单的数据结构，例如 Vec<i32>
#[wasm_bindgen]
pub struct LargeData {
    data: Vec<i32>,
}

#[wasm_bindgen]
impl LargeData {
    // 创建 LargeData 的构造函数
    #[wasm_bindgen(constructor)]
    pub fn new(data: Vec<i32>) -> Self {
        LargeData { data }
    }

    // 获取数据的长度
    #[wasm_bindgen(getter)]
    pub fn length(&self) -> usize {
        self.data.len()
    }

    // 获取数据的指针
    pub fn data_ptr(&self) -> *const i32 {
        self.data.as_ptr()
    }
}
```

> 需要注意的是：js 的 TypedArray 是线性表结构，具有相同的内存模型，因此可以直接传递

两个关键概念
* 内存 Memory：可变长的 ArrayBuffer，能够被实例存取的原始字节内存。
* 表格 Table：位于 wasm 内存之外的可变长类型数组，用于存储多个函数引用，能同时被 js 或 wasm 访问和更改.

基础语法
```rust
// 导入预设 -- use 从外部库导入模块，而 mod 创建只能在当前文件中使用的内部模块。
use wasm_bindgen::prelude::*;

// 表示它下面的函数在 JavaScript 和 Rust 中都可以访问。
// extern 块将外部 JavaScript 函数 alert 导入 Rust
#[wasm_bindgen]
extern {
    fn alert(s: &str);
}
```

拓展：rust 针对 wasm 拓展
* js-sys：用于绑定 js 环境中的全局对象和函数的绑定
* web-sys：wasm 操作 web api

FFI(Foreign Function Interface)
* extern block：外部库中的函数签名列表
* extern "C"：是 extern 一种变体，它指定了一种特定的 ABI，即 C ABI，以确保与其他语言（特别是 C 和 C++）兼容。
* ABI（Application Binary Interface）是指在二进制层面上定义了函数调用约定、数据传递方式、栈帧布局等规则的接口标准。ABI 的目标是确保不同编程语言编写的模块之间能够正确地进行二进制级别的交互，使它们能够调用和被调用而不引起不兼容的问题。

## rust
相关特性
* 借用和所有权
* 模式匹配
* 生命周期
* 并发编程：支持线程，同时还支持并发，允许在单线程中实现并发

& 符号有两个主要用途，它可以表示引用（reference）和借用（borrowing），* 符号用主要用解引用
* 当用 & 符号创建一个引用时，它创建了对某个值的引用，而不会转移该值的所有权。引用允许你在不拥有值的情况下访问它。引用通常用于函数参数、数据结构中的字段、以及在借用（borrowing）中。
* & 符号还可以用于创建借用，包括可变和不可变的借用。不可变借用允许对值进行只读访问，而可变借用则允许修改值。借用通常用于函数参数，以便在函数中引用数据而不获取所有权。
* 当 * 用于引用类型之前，它表示解引用操作，即访问引用所指向的值。因为在 Rust 中，使用引用时，我们通常使用 & 符号创建引用，而在需要使用引用指向的实际值时，我们使用 * 进行解引用。

在 Rust 中，生命周期通常以撇号（'）加上标识符的方式表示，例如 'a、'b 等。生命周期注解是 Rust 的一部分，用于指定引用之间的关系，使编译器能够验证引用的有效性。

关于生命周期的示例
```rs
struct Foo {
    x: &i32,
}

fn main() {
    let y = &5;
    let f = Foo { x: y };

    println!("{}", f.x);
}
// 上述代码会报错：y的借用被传递到了结构体 y 中，因此必须确保 y 的生命周期比 f 要长，此时我们添加生命周期标记
struct Foo<'a> {
    x: &'a i32,
}

fn main() {
    let y = &5;
    let f = Foo { x: y };

    println!("{}", f.x);
}

// 如下的粒子 i 中，要求 x,y 具备相同的生命周期，但使用的时候由于 b 的生命周期较短，因此会报错提示 b 生命周期不够长
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
fn main() {
    let a = "hello";
    let result;
    {
        let b = String::from("world");
        result = longest(a, b.as_str());
    }
    println!("The longest string is {}", result);
}
```