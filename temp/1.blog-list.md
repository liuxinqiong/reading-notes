Diff 算法
* react 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

设备分辨率、物理分辨率

响应式设计 - 小狄

如何判断循环引用
* Set WeakSet
* Map WeakMap

yield 报错后不再进入问题

canvas globalCompositeOperation 了解

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具

## Cad 识别
ODA 优势
* 多文件格式
* 网页端渲染模型
* 图纸批注与标签
* 图纸测量
  * 两点之间距离
  * 某个多边形区域的面积
  * 某个角度大小
  * 为了适应用户的习惯，测量时可以捕捉端点、中点、垂足及线条。
* 图层列表与管理

VisualizeJS
* 渲染 Open Cloud 解析后的图形
* getVisualizeLibInst 获取实例
  * urlMemFile：Visualize.js.wasm 文件
  * TOTAL_MEMORY：所需的浏览器内存量
* visualizeLibInstance
  * postRun：准备就绪回调
  * canvas：执行用于绘制的 canvas 对象
  * getOverlayController
  * getViewer
* Viewer：单实例类
  * resize
  * update
  * addEmbedetFileWrapper
  * appendFileWrapper
  * createBlock、createLayer、createLocalDatabase、createModel、createRasterImage、createTextStyle、createVisualStyle
  * findXXX
* 插件机制
  * OdaViewerPlugin：集成平移、缩放、镜头控制等
  * OdaSlicePlanePlugin：切面
  * OdaMeasuringPlugin：测量工具
  * OdaWorkerTransportPlugin

常用类：
* Entity：表示图形单元，通过 layer 属性关联具体的 layer
* Block：多个 Entity 组成一个 Model，有点 Template 的味道
* Layer：主要用于管理该图层下的 Entity
* Model：有点分类管理 Entity 的味道
* Device：可以用于创建 view 对象，添加多个 view 实例
* View：拆分视窗

如何读取文件并显示
1. 上传文件到服务端得到一个 fileId
2. 使用 fileId 创建一个从文件中解析图形的任务，得到 jobId
3. 根据 jobId 轮训任务状态，直到任务完成
4. 使用 viewer api 直接渲染图形数据

视角参数 viewParams
* viewPosition
* viewTarget
* upVector
* viewFieldWidth
* viewFieldHeight
* perspective

> 形象的理解 Camera 的 upVector 属性：好比你的眼睛就是镜头，焦点就是 lookAt，你头顶就是 up 正方形方向

已知问题（开始时间：2021年1月19号）
1. polygon 没有 getPoints 方法：fixed
2. setColor 对于 block 不生效
3. getSnapPoint 对于 block 生效

常用矩阵
* view.projectionMatrix：投影矩阵
* view.worldToDeviceMatrix：世界坐标转屏幕坐标
* view.eyeToWorldMatrix：视图矩阵的逆矩阵，用于将视图坐标转回世界坐标
* view.viewingMatrix：视图矩阵，用于将世界坐标转视图坐标

```js
function odaMatrix3dToArray(odaMatrix3d: any) {
  const result = [];
  for (let i = 0; i < 4; i += 1) {
    for (let j = 0; j < 4; j += 1) {
      result.push(odaMatrix3d.get(i, j));
    }
  }
  return result;
}

// 1000 * 610
var a = lib.Point3d.createFromArray([1,1,0]);
a.transformBy(viewer.activeView.worldToDeviceMatrix); // [458.2600819854454, 159.3051914642516, 0.5]

var b = lib.Point3d.createFromArray([1,1,0]);
b.transformBy(viewer.activeView.viewingMatrix.postMultBy(viewer.activeView.projectionMatrix)); // [-1.3438006824319886, 2.685724923501441, 0.5]

var b = lib.Point3d.createFromArray([1,1,0]);
// 正确方式为左乘
b.transformBy(viewer.activeView.viewingMatrix.preMultBy(viewer.activeView.projectionMatrix)); // [0.4582600819854455, 0.7388439484192596, 0.5]

// 转 NDC 坐标 x = [-1, 1] y = [-1, 1] 下面的目的是将 [0, 1] 的范围扩展到 [-1, 1]
// Xn = 0.4582600819854455 * 2 - 1 = -0.08347983602910902
// 转设备坐标
// -0.08347983602910902 * 1000 / 2 + 1000 / 2 === 直接通过 worldToDeviceMatrix 直接获取的值

// Yn = 0.7388439484192596 * 2 - 1 = 0.4776878968385192
// 转设备坐标
// 0.4776878968385192 * -610 / 2 + 305 = 159.30519146425164
```

Geometry：Shell（外壳）、ColoredShape（彩色平面）、Mesh（网状面）、Grid（网格线）
```js
entityPtr.appendShell([-2, 0, 0, 2, 0, 0, 2, 2, 0, -2, 2, 0], [3, 0, 1, 2, 3, 2, 3, 0])

entityPtr.appendColoredShape([-2, 0, 0, 2, 0, 0, 2, 2, 0, -2, 2, 0], [3, 0, 1, 2, 3, 2, 3, 0])

entityPtr.appendMesh(3, 3, 9, [-2, 2, 0, 0, 2, 0, 2, 2, 0, -2, 0, 0, 0, 0, 0, 2, 0, 0, -2, -2, 0, 0, -2, 0, 2, -2, 0])

entityPtr.appendGrid([0, 0, 0], [-2, 2, 0], [2, 2, 0], 4, 3, 1)
```

相关函数
* viewer.toEyeToWorld(x, y, z)
* viewer.screenToWorld(x, y)
* point3d.transformBy(matrix)
* viewer.getTransform(from, to)

变化操作：空间区别
* 局部空间：3D 模型的坐标。定义了 3D 模型本身的顶点空间
* 世界空间：将局部空间坐标 * 世界矩阵从而进入到世界空间。是我们想象中的 3D 世界，没有考虑任何视角
* 视图空间：局部顶点 * 世界矩阵 * 视图矩阵从而进入到视图空间。这是坐标在屏幕上的位置，和具体使用的视角有关。如果您使用透视投影，这会使所有坐标看起来像它们具有深度
* 投影矩阵：用投影矩阵 * 上述结果后，将获取到 3D 透视点，并将其正确映射到 2D 窗口
* NDC 坐标：也叫做设备无关坐标

## 优化接口请求
request 优化
* 增强错误默认处理
  * HTTP 状态码非 200 区间时走默认错误处理
  * 请求体 success 为 false 时走默认错误处理
  * 增加 skipErrorHandler 参数，针对不需要默认处理的接口情况
* 判断是否是新接口，暂采用直接判断是否定义 success 和 errorCode 字段
* 数据返回问题
  * 状态码为 200 且 success 字段为 true 时，直接返回 data.data，这样原有接口使用逻辑不变
  * 其他情况会走失败逻辑，可用 axios.isCustomError 判断是不是由于 success 为 false 抛出的错误，CustomRequest 会有 errorCode 和 errorMessage 字段
Feature
  * 新增 loading 参数，可用于设置接口级别的 message.loading
  * 新增 getResponse 参与，用于需要获取完整 response 的情况，比如获取分页的请求头 X_TOTAL_COUNT
  * 新增 skipErrorHandler 用于不需要进行默认错误处理的情况
  * 新增 axios.isCustomError 函数用于判断是不是由于 success 为 false 抛出的错误
* 管理多个 request 对象
* 完整的 response 响应结构
  * data
  * status
  * statusText
  * headers
  * config
  * request
* 中间件、拦截器
  * 拆分多个拦截器，每个只做一件事
  * 全局配置：axios 的全局配置竟然是失效的！！！
  * 实例单独配置
* 缓存功能设计
  * 缓存开关：useCache
  * 缓存时间：ttl
  * 缓存 key：url + params + method
  * 最大缓存数：maxCache
  * 自定义缓存：validateCache

## Obj 文件
Obj 文件内容如下
* v：表示顶点，即组成图的点
* vt：纹理坐标，其值为 u、v、w
* vn：顶点法向量，其值为 x、y、z，这个法向量表示顶点的朝向。比如由三个顶点组成一个面，面由两个朝向，向里或向外，可以通过顶点的朝向来确定面的朝向。而且这三个顶点的法向量是一样的
* f：表示一个面，由三个 v/vt/vn 的索引形式组成。比如 obj 文件中 f 5/15/7 4/14/6 6/16/8 ，表示由第 5、第 4、第 6 这三个顶点组成了一个三角平面,平面的纹理由第 15、第 14、第 16 这三个纹理坐标形成，这个平面的朝向是第 7、第 6、第 8 这三个顶点的法向量求平均值

补充说明
* 顶点的个数与顶点法向量的个数一样多。
* 顶点的个数不一定与纹理坐标的个数一样多，因为有可能很多顶点公用一个纹理坐标的像素。
* 面索引的个数也与其余数据数量无关。
* 最终每个三角面的颜色，是由构成这个三角面的三个顶点进行插值计算

## 前端代码共享方案
如何在多个仓库间复用代码，关于这个话题讨论越来越多。

这里介绍复用代码的 5 种方案，代码复用归根到底是一个关于人际沟通的文化问题，最重要的是不忘模块化这一初心
* Bit
* NPM with/without Lerna
  * 为多个软件包配置和维护多个仓库可能很困难，因此有些项目采用多软件包仓库（monorepo），Lerna 之类的工具可以帮助我们将项目转换为软件包仓库
  * 不同的包放不同的仓库，这样做很快就会超出掌控范围，很难在项目间更新变更。Lerna 可以帮助你在单个仓库中管理、配置多个软件包，统一构建和测试流程，从而减少不同的包放不同的仓库带来的麻烦。这样你就不用为不同的软件包配置、维护不同的仓库了。
  * 独立发布
* 公共库
  * 优势在于可以把所有需要复用的代码放在一个仓库里，这样比采用多个小软件包更容易维护和分发。和 Lerna monorepo 的区别在于，公共库会作为一个软件包使用。
  * 把所有需要复用的代码放在一个仓库里有一个问题，使用时需要将整个公共库引入项目，会引入冗余的代码、依赖，也会增加项目的大小和复杂度。这也导致更新和修改非常笨拙，任何变更都需要项目所有者更新整个软件包。
  * 公共库内组件的可发现性也不好。这些问题导致 Lodash 之类的社区花了很长时间和很多精力将组件拆成单独软件包发布到 NPM 上。
  * Lerna 可以将公共库仓库中的组件拆成多个软件包。Bit 可以用来分发公共库中的组件。
* Git sub-module
  * sub-module 不会管理模块间的依赖关系
  * 父目录 pull 不会自动更新 sub-module
  * 如果 sub-module 不稳定，更改时多次提交会很繁琐
  * 有各种工具为 sub-module 添加了额外的自动化，比如 git-subtree
* 复制粘贴代码

使用 Bit 可以轻松将 multi-repo 切换成 multi-package monorepo
* 你不需要更改仓库中的任何代码
* 所有的内部依赖会被 Bit 自动管理
* 不需要为每个 package 配置 build/test 环境
* 增加复用代码的可发现性
* 支持 monorepos 之间的双向共享和协作

multi-repo 的优势
* 清晰的所有权：小团体可以独立的开发和部署
* 更好的伸缩性：小仓库可以更好的被管理，更少的合并地狱，团队不需要与其他团队协调，从而更快地执行
* 窄克隆：大部分版本控制工具，比如 Git 不支持部分克隆，对于大型的代码库，clones、pulls、pushes 会花费更多的时间

multi-repo 的劣势
* 实施代码标准化是一项挑战
* 导致代码评审困难，因为缺失上下文

monorepo：服务可以独立开发和部署，所有服务代码在同一个仓库中，带来的好处有
* 更好的开发体验：开发者可以轻松的在本地运行整个平台，可以帮助开发者更好的理解服务之间是如何一起工作的，开发者可以更好的在本地发现 bug
* 减少代码复杂度：高级开发者可以很容易的在所有服务之间推行标准化，因为可以很容易的跟踪到所有的请求和更改
* 更有效的代码评审
* 更容易重构：重构工具更好的发挥作用

> 我们转向 monorepo 的最大好处是我们没有放弃微服务架构的任何优势。

Lerna 的问题
* 现有代码仓库的重组
* 手动维护多个 packages 的配置和依赖树

为解决代码复用而衍生出来的一系列工具
* Bit：方便共享和管理组件
* Lerna：管理和发布从一个仓库中发布多个包
* StoryBook：可视化组件

## 资料
* [Our journey to microservices: mono repo vs multiple repositories](http://blog.shippable.com/our-journey-to-microservices-and-a-mono-repository)

## DOM 坐标
MouseEvent
* clientX/clientY：相对客户端窗口的 X/Y 坐标
* layerX/layerY：已启用，忘记它吧
* offsetX/offsetY：相对于事件源元素的 X/Y 坐标，注意相对于目标（target），而非 currentTarget
* pageX/pageY：相对于整个文档的 X/Y 坐标
* screenX/screenY：相对用户屏幕的 X/Y 坐标
* x/y：clientX/clientY 的别名（所以忘记它吧）

DomElement 属性
* clientHeight/clientWidth
  * 包括 padding 但不包括 border，也就是元素的 padding box 尺寸，如果有滚动条，也不包含滚动条
  * 注意：inline 元素没有可视宽高的说法（clientHeight 和 clientWidth 永远是 0）
* clientLeft/clientTop
  * 边框的左边框宽度/上边框宽度
* offsetHeight/offsetWidth
  * 包括 padding 和 border，也就是元素的 border box 尺寸，效果与 e.getBoundingClientRect() 相同
* offsetLeft/offsetTop
  * 元素的外边缘距离已定位的父容器的左边距离/上边距离
* scrollHeight/scrollWidth
  * content + padding + 溢出内容的尺寸 = clientXXX + 移除内容尺寸
* scrollLeft/scrollTop
  * 滚动条左边/上方卷去的高度
* getClientRects：返回一个列表，里面包含元素对应的每一个盒所占据的客户端矩形区域，可以用 x、y、width、height、top、left、right、bottom 来获取它的位置和大小
* getBoundingClientRect：这个 API 更接近我们脑海中的元素盒的概念，返回元素对应的所有盒的包裹的矩形区域，需要注意，这个 API 获取的元素会包括当 overflow 为 visible 时的子元素区域

## CSS 图形变化
理解几个 CSS 动画中比较复杂的属性
* matrix
* skew
* origin
* perspective

matrix 矩阵
* 前言：实践 2d，3d 中 canvas 图形变换后，发现 CSS 中早就定义好了，是之前自己不关注！！！
* CSS3 中的矩阵指的是一个方法，书写为 matrix() 和 matrix3d，前者表示元素 2D 平面的变换，是 3x3 的矩阵，后者则是 3D 变换，是 4x4 的矩阵
* matrix 共有 6 个参数，matrix(a, b, c, d, e, f)，在矩阵中书写方向是竖的，矩阵相乘是 `横列*竖列` 规则
* matrix3d 共有 16 个参数，书写规则和 matrix 一样

rotate：旋转操作
* 这个属性本身很好理解，表示顺时针选择多少角度，但从 matrix 角度而言 rotate 会比 translate 和 scale 来的复杂，因此重点学习一下
* 旋转设计到三角函数，可自行推导，矩阵表示为 matrix(cosθ, sinθ, -sinθ, cosθ, 0, 0)，具体记忆简写为 CS-SC 对称结构帮助理解

skew：扭曲操作
* matrix：matrix(1, tan(θy), tan(θx), 1, 0, 0)
* skewX：表示 X 方向的扭曲，达到这个目的的方式是逆时针旋转 Y 轴，y 方向值保持不变
* skewY：表示 Y 方向的扭曲，达到这个目的的方式是顺时针旋转 X 轴，x 方向值保持不变

origin：表示原点
* 在 transform 中，origin 默认在元素的中心，也就是 50% 50% 0
* 取值可以为：length、percent，以及 top、left、right、bottom、center 关键字

问题：既然提供了便于理解的 rotate、skew、translate，为何还要提供 matrix 呢：对于简单的交互，使用提供的方法足够了，但对于一些高级效果，还是需要 matrix 来帮忙

难懂的 perspective 属性
* 可选的属性值
  * number：元素具体视图的距离
  * none（默认值，与 0 相同，不设置透视）
* CSS3 3D transform 的透视点是在浏览器的前方
* 可通过给父元素设置 perspective，以及子元素设置 translateZ 观察近大远小的效果
* 两种书写形式
  * 用在动画元素们的共同父辈元素上，此时也叫做舞台元素
  * 用在当前动画元素上，此时需要与 transform 的其他属性写在一起
  * 如果舞台只有一个元素，则两种写法效果一致，如果有多个元素，则差异就会表现出来，第二种写法每个元素都有自己的视点

其他属性
* perspective-origin：lookAt 的位置，默认在看舞台或元素中心
* transform-style：preserve-3d|flat
  * flat：表示平面，默认值
  * preserve-3d：表示 3d 透视，实现一些 3D 效果的时候，通常需要设置该值
* backface-visibility
  * CSS3 的 3D 世界中，默认情况下可以看到背后的元素
  * 为了切合实际，通常会设置 hidden 使后面值不可见

## Math
什么是反函数：对于 y = f(x)，如果存在一个函数 g 是的，g(y) = g(f(x)) = x，那么 x = g(y) 就是反函数

几个常见但是比较生疏的数学函数
* acos：反余弦
* asin：反正弦
* atan：反正切
* atan2：返回从 x 轴到点 (x, y) 的弧度

## pointer-events
超牛的 pointer-events 属性
* auto：与未指定时的表现效果相同
* none：除了指示该元素不是鼠标事件的目标之外，值 none 表示鼠标事件“穿透”该元素并且指定该元素“下面”的任何东西。