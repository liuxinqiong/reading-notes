~~[探索 webpack5 新特性 Module federation 在腾讯文档的应用](https://mp.weixin.qq.com/s/iS-prT1xZPV6cpH7MHRRdQ)~~
~~[图解常用的 Git 指令含义](https://mp.weixin.qq.com/s/oKMdlo6jsIcMcZW8nzoAUg)~~
~~[这才是真正的Git——Git内部原理揭秘！](https://mp.weixin.qq.com/s/jN-CGrf7oosutxLEvxvWiw)~~
~~[Service Worker 运用与实践](https://mp.weixin.qq.com/s/vI2bxaFsFSB5rGC4Bkr8vQ)~~
~~[JavaScript 20 年中文版 - 语言诞生](https://mp.weixin.qq.com/s/eRne5EIQGDbE0-JclAzNAA)~~
~~[微前端在小米 CRM 系统的实践](https://mp.weixin.qq.com/s/5qwgZ9aNKFC3naWRUGajmA)~~
~~[微前端在企业级应用中的实践(上)](https://mp.weixin.qq.com/s/tutFXv6djecT6lnL9Je71Q)~~

~~[NutUI Picker组件的设计与实现](https://mp.weixin.qq.com/s/13kGxbdIVeOzbObrECdEeQ)~~
~~[多应用项目开发架构和多进程间构建优化分析](https://mp.weixin.qq.com/s/O0e2Iou96PDUiNN5uciyIA)~~
~~[Mutex 和上厕所居然有这么多异曲同工之妙](https://mp.weixin.qq.com/s/3gAa31IkCaj6P0rgM03-LQ)~~

~~[可扩展的前端 -- 架构基础](https://mp.weixin.qq.com/s/AYf8CkwY1NjBvv_HzggmZw)~~
~~[可扩展的前端 -- 常见模式](https://mp.weixin.qq.com/s/6LJH6Myr4ulrYByIAaq_XQ)~~

~~[闪电智能创作平台项目前端总结](https://mp.weixin.qq.com/s/sQHLetPT85w4fKrv15Qf0g)~~
~~[在浏览器中存储数据 - IndexedDB](https://mp.weixin.qq.com/s/EO10qD9hn4cuH5o74_EPSQ)~~
~~[奇妙的 CSS MASK](https://mp.weixin.qq.com/s/XMiEBQT9MpV9pJyAWsb0qQ)~~

~~[2020年大前端技术趋势解读](https://mp.weixin.qq.com/s/slghkDUyng7tOha3JFzeCQ)~~
~~[如何自己开发一款力导向图？](https://mp.weixin.qq.com/s/jnqmcOVQwnEZ8atzgZe1pQ)~~
~~[交互导入模式](https://mp.weixin.qq.com/s/6O3CYnzbBCHrUWeYG-Yx4Q)~~
~~[2020 CSS 现状调查](https://mp.weixin.qq.com/s/9B_xxJh9Lx2t0vssCh5buA)~~
~~[自适应布局最佳实践](https://mp.weixin.qq.com/s/8GvZetosiFJmZ1n3ZLfxNA)~~
~~[CSS现状和如何学习](https://mp.weixin.qq.com/s/1Zg1sQyP186UNpr2GtDvqw)~~

~~[如何提高CSS性能](https://mp.weixin.qq.com/s/Sc3ksTndrrNSH5wAhtgAaw)~~
~~[前端质量保证体系建设](https://mp.weixin.qq.com/s/5eKznqIkIf4-4AjbPwUR6w)~~
~~[前端性能优化](https://mp.weixin.qq.com/s/J60NkG8A_E-vI3RpKQSTmw)~~
~~[单元测试最佳实践](https://mp.weixin.qq.com/s/1A8t_YA8Iszi-BljUKs6GQ)~~

~~[深入了解现代浏览器之四](https://mp.weixin.qq.com/s/XN9wUM-FdWbE1m66jkEgIg)~~
~~[JavaScript代码整洁之道-概述篇](https://mp.weixin.qq.com/s/jvnDyNdhjpYaABwgl6YunQ)~~
~~[JavaScript代码整洁之道-函数篇](https://mp.weixin.qq.com/s/dmvlOiu7iOmBQpNPAXXotw)~~
~~[JavaScript代码整洁之道-复杂判断](https://mp.weixin.qq.com/s/tpkGpxNUl2K7d4AFvZym_g)~~

~~[从 Prompt 来看微前端路由劫持原理](https://mp.weixin.qq.com/s/WDvtyELAPZ_gtn-wF4G7Dw)~~
~~[仅使用CSS提高页面渲染速度](https://mp.weixin.qq.com/s/nM_M-B6oDk9PHJkURBKFkA)~~
~~[狼叔看next.js](https://mp.weixin.qq.com/s/EWa6QZHItPlj6H3Q_H247w)~~

~~[前端架构 101：在谈论它们之前我们需要达成的共识](https://mp.weixin.qq.com/s/iupP8wiJzUjJJ2cqSDDFLQ)~~
~~[前端架构 101：MVC 初探](https://mp.weixin.qq.com/s/8ILlKiZIGCqqVoKhH4VDtA)~~
~~[前端架构 101：MVC启示录 - 模块的职责，作用域和通信](https://mp.weixin.qq.com/s/w24UUSl_kosclM_ct8Hk3w)~~
~~[前端架构 101：MVC 的不足与 Flux 的崛起](https://mp.weixin.qq.com/s/BB1VUmtQ5uBJ7VSnRf11ZQ)~~
~~[前端架构 101：从 Flux 进化到 Model-View-Presenter](https://mp.weixin.qq.com/s/jB3POItNJ-MjI_Ubeu_Dfw)~~
~~[前端架构 101：整洁（Clean Architecture）架构是归宿](https://mp.weixin.qq.com/s/n9myHRtXleOY2MKZWhN8Eg)~~

~~[前端架构鉴赏01：Angular 架构模式与最佳实践](https://mp.weixin.qq.com/s/gz98PLI4ne1-AAa-MMC6aw)~~
~~[前端架构鉴赏02：可拓展 Angular 2 架构](https://mp.weixin.qq.com/s/4bd-xkyus-tNuylTBm_tGw)~~
~~[前端架构鉴赏03：Angular 与 MVP 模式](https://mp.weixin.qq.com/s/7uYxFxbvcZS4wjbWPVmGpg)~~

[彻底搞懂 React 源码调度原理（Concurrent模式）](https://mp.weixin.qq.com/s/xHfhMqa5Nsw_5i6MkK2X0A)
[从 React Hooks 看 React 的本质](https://mp.weixin.qq.com/s/t0CLAb7CCZY-paEJque1RA)
[React Hooks 的体系设计之四 - 玩坏 ref](https://mp.weixin.qq.com/s/7c6zncb5ZIef9xgaAvt9uw)
[React Hooks 设计思想](https://mp.weixin.qq.com/s/9Uuy5t-TL9cnCWY_GtQpNQ)
[React 18 新特性之 startTransition](https://mp.weixin.qq.com/s/JAFdq0BBu4rVAoPAdKWe8A)
[React Conf 2021 为 React 18 带来了哪些新东西？](https://mp.weixin.qq.com/s/tKxM2YcNk2K5Ot1nCbqoeg)
[探索 React 的内在 — Fiber & Algebraic Effects](https://mp.weixin.qq.com/s/7MQp1CrZFwNd4dQ3y2C-UA)
[探索 React 的内在 - postMessage 和 Scheduler](https://mp.weixin.qq.com/s/x4HvKm6w_nc02CZcOiwTTA)
[深入源码剖析componentWillXXX为什么UNSAFE](https://mp.weixin.qq.com/s/aL5NHz3Jq4KZT_m5rIbx3A)

~~[连0.2这么简单的数字都搞不定！你被炒了！](https://mp.weixin.qq.com/s/Cd4uRslnek8r_a6chjwnYQ)~~
[图解 | 你管这破玩意叫计算机？](https://mp.weixin.qq.com/s/prJ767KGkhw3cc53BniNJg)
[图解 | 你管这破玩意叫动态规划](https://mp.weixin.qq.com/s/JIQKOxKsFa0I3HyQvOT5Jw)
[图解 | 你管这破玩意叫文件系统？](https://mp.weixin.qq.com/s/GcIZRk2kWrpKx7Ti3KqDHQ)
[图解 | 你管这破玩意叫 class？](https://mp.weixin.qq.com/s/-_Y-zFNTrBVQchQxj7TGHA)
[图解线程状态，看完浑身通透](https://mp.weixin.qq.com/s/aG_uBLQevyZEFTOLK-kH9g)
[你管这破玩意叫 IO 多路复用？](https://mp.weixin.qq.com/s/3gC-nUnFGv-eoSBsEdSZuA)
[都是缓存惹的祸](https://mp.weixin.qq.com/s/7PgUa696U5pZFLEcbWHYSA)
[你管这破玩意叫哨兵？](https://mp.weixin.qq.com/s/ijTnqfKvwP7ldYusQGl9tA)
[最多能创建多少个TCP连接？](https://mp.weixin.qq.com/s/mGkf-9LZhhUgSIRBRqfRDw)
[你管这破玩意叫 RDB？](https://mp.weixin.qq.com/s/vsmoOxMXn2nG7OYjJkbb7A)
[你管这破玩意叫 OAuth？](https://mp.weixin.qq.com/s/FnWUwEp2PuOxqnF5URB-WA)
[图解 | 你管这破玩意儿叫指针？](https://mp.weixin.qq.com/s/EuxKxa870RsFVE4KvzYuxA)
[从上厕所想到的线程池设计原理](https://mp.weixin.qq.com/s/rxaNWAgpt7umtftDk3eKUA)

~~[手把手教你定制一套适合团队的微前端体系](https://mp.weixin.qq.com/s/ovwjufnPmCoYNLMkv5xv2g?forceh5=1)~~
[浏览器的5种Observer](https://mp.weixin.qq.com/s/fywhj-R84Xp2qj3drghH3Q?forceh5=1)
[动手打造一款 canvas 排版引擎](https://mp.weixin.qq.com/s/KD9G_XFLFQ0Hh-XVJUnFaQ?forceh5=1)
[QUIC 和 HTTP/3 队头阻塞的细节](https://mp.weixin.qq.com/s/-Z5ei-zXMfjPHUrQZs87ag)
[如何用一行 CSS 实现 10 种现代布局](https://mp.weixin.qq.com/s/fyOP86kGicEIcVKoR8Iayg)
[ServiceWorker 缓存与 HTTP 缓存](https://mp.weixin.qq.com/s/OlOMm20cSRaQESiZ_DC7mQ)
[Web页面全链路性能优化指南](https://mp.weixin.qq.com/s/IZEjbVbBmPlMGRw0fpyl_Q)

<!-- 20220828 -->
[从零开始搞监控系统 —— SDK](https://mp.weixin.qq.com/s/y6oZuej94mR6KkkI3bAQag)
[认识下浏览器的 5 种观察器 API](https://mp.weixin.qq.com/s/AhgeezXk3k0-qXNNvjspJQ)
[HTTP史记 - 从HTTP/1到HTTP/3](https://mp.weixin.qq.com/s/uWcWApTHamlWI3FRIOER1A)
~~[Web 应用实时版本检测](https://mp.weixin.qq.com/s/wvK2ky-1rPa1esAFEoyDzw)~~ # 挺有意思的小工具
[使用 React Testing Library 的 15 个常见错误](https://mp.weixin.qq.com/s/gssYOb7xgSx2HsAeRGTgxA)
[你不知道的CSS](https://mp.weixin.qq.com/s/RMe8ZoKi0bv1MDm7VeZesw)
[前端场景下请求的Race Conditions](https://mp.weixin.qq.com/s/PL_uWkSTo12hxmxMmUKndw)
[前端构建效率优化之路](https://mp.weixin.qq.com/s/UZ-ytVffpCnyrvm_bkgiUA)
~~[将微前端做到极致-无界方案](https://mp.weixin.qq.com/s/qeykVPcXkKSxbMK3didHfQ) # 把玩一下原理~~
[在复杂应用中设计空状态：3条准则](https://mp.weixin.qq.com/s/bN9D4Yo11h5Zw-iUfZr6WQ) # 产品设计的思考
[你想知道的前后端协作规范都在这](https://mp.weixin.qq.com/s/CwSbttvIBTF37uOetDLc4g)

<!-- 20221128 -->
[异步分片计算在腾讯文档的实践](https://mp.weixin.qq.com/s/d5M_-8XqFGYnpif7GQNmLA)
[全新的 React 组件设计理念 Headless UI](https://mp.weixin.qq.com/s/yoO3UNmIs1gUHwML7Ab3Kw)
[WebGL 实战之绘制圆角矩形](https://mp.weixin.qq.com/s/R-jDUDMd54oYpfb718-kHQ)
[React 渲染的未来](https://mp.weixin.qq.com/s/d0Sh0tanTJ6x0jsXcA4PFQ)

<!-- 20230520 -->
[Islands 架构原理和实践](https://mp.weixin.qq.com/s/hLDtOz2AEbLCdRVBHkb3MQ)
[打包JavaScript库的现代化指南](https://mp.weixin.qq.com/s/m-i_Et6YqkZ0aj537vN2_A)
[基于 GraphQL 的云音乐 BFF 建设实践](https://mp.weixin.qq.com/s/YxtCo96XUNXYjTIBWju0_Q)
[模块联邦在微前端架构中的实践](https://mp.weixin.qq.com/s/8vfTp-FZbYNk2k8gCIGc8w)
[2022大前端总结和2023就业分析](https://mp.weixin.qq.com/s/AU-d819I-Zo9sQOdbbU3Iw)
[React 纪录片心得 — 重新思考最佳实践](https://mp.weixin.qq.com/s/x1HGf4MNPoifIJIaLEg9uQ)
[腾讯文档智能表格渲染层 Feature 设计](https://mp.weixin.qq.com/s/cLoE_RydYueo7OeYp4_56A)
[浅谈 Canvas 渲染引擎](https://mp.weixin.qq.com/s/X2mOSZoDICS3jyWpoYzZXQ)
[0.1 + 0.2 不等于 0.3？原来是因为这个](https://mp.weixin.qq.com/s/4dTBbRxek2XzrQC_RnyleA)
[React Ref Callback：最佳实践](https://mp.weixin.qq.com/s/qW3L4y_kmQISRJPOvFlMEw)
[当我们说插件系统的时候，我们在说什么](https://mp.weixin.qq.com/s/4LPWoaLNc0-TLiJmV9EJhg)
[现代图片性能优化及体验优化指南](https://mp.weixin.qq.com/s/YfJSqUYsJvlTXH6gRHhrmw)
[基于 HTTP Range 实现文件分片并发下载！](https://mp.weixin.qq.com/s/kZvD2OvsY-aFfb34grjqug)
[那些在做 React 组件库时，没注意到的小细节](https://mp.weixin.qq.com/s/Gnqc2GzkyF6MLMUBE6Dh3A)

<!-- 20230924 -->
[如何编写一个友好支持 Tree-shaking 的库](https://mp.weixin.qq.com/s/ovdshkEmUF8CuN32FKwJ4Q)
[漫画前端的前世今生](https://mp.weixin.qq.com/s/eYUFX0bq-4O_mTunI63GCg)
[Node.js健康检查和过载保护](https://mp.weixin.qq.com/s/FBhim0kJosnUIXsdchNL7Q)
[携程火车票7个优化动画性能的方法](https://mp.weixin.qq.com/s/G8C_vr01SrRx47SjZ73srw)
[让数据说话！前端实现埋点上报](https://mp.weixin.qq.com/s/Q2OApBm6uwRtGLyvIpgXng)
[基于 Nginx 实现一个灰度上线系统](https://mp.weixin.qq.com/s/Mv3gG51UWA4b-6GquEEzfw)
[前端简洁架构](https://mp.weixin.qq.com/s/OQ_ySD-N4j0hyaWouvF8Sw)
[前端文件流、切片下载和上传：优化文件传输效率与用户体验](https://mp.weixin.qq.com/s/AmV22FF0kUvGk5SYLCu6fw)
[React 18 如何提高应用程序性能](https://mp.weixin.qq.com/s/9_E27UPHlJ-EFMHRXhJLJA)
[leaferjs，全新的 Canvas 渲染引擎](https://mp.weixin.qq.com/s/Fgf4kBPHM5UyslX5M4nBFw)
[详解Module Federation的实现原理](https://mp.weixin.qq.com/s/1dUTODMMuNufilEpB1d8_Q)
[浅尝IM方案在H5活动场景中的应用](https://mp.weixin.qq.com/s/BcjG3askh3JH8dbwkybXVA)
[给 Web 前端工程师看的用 Rust 开发 wasm 组件实战](https://mp.weixin.qq.com/s/3uJO-iooD9th1NgDf-beyw)

## 异常监控
前端异常监控与之最大的不同，就是需要把客户端发生的异常数据通过网络再收集起来。可以使用下面几个方式来收集数据：
* window.onerror 捕获语法异常
* 可以重写 setTimeout、setInterval 等异步方法，用同步的写法包裹 try 来捕获异步函数中发生的错误
* window.addEventListener('unhandledrejection', …); 捕获未处理的异步 reject
* window.addEventListener(‘error’, …) 捕获资源异常
* 重写 fetch、XMLHttpRequest 来捕获接口状态

## React
在早期的 React Router 中，提供了开箱即用的滚动恢复的支持。

浏览器开始处理带有历史记录的滚动恢复。它已经在浏览器中工作的很好。

因为浏览器开始处理默认情况，而应用程序有不同的滚动需求。

比如滚动到顶部
```js
export default function ScrollToTop() {
  const { pathname } = useLocation();

  useEffect(() => {
    window.scrollTo(0, 0);
  }, [pathname]);

  return null;
}

function ScrollToTopOnMount() {
  useEffect(() => {
    window.scrollTo(0, 0);
  }, []);

  return null;
}
```

ScrollRestoration 的工作原理
* 操作 window 对象
* 使用 location.key 进行 window 滚动位置记录到 sessionStorage
* 当 ScrollRestoration 组件挂载时，从 sessionStorage 寻找滚动位置

## 架构
相关共识
* 满足非功能性需求
  * 可扩展性、可维护性、可测试性
  * 和业务需求没有任何关系，产品经理不在乎你写得多烂，只在乎能够上线，至于这部分代码将来的维护成本有多高与他无关，但与我们有关
  * 减少项目的维护成本，还能够让新加入团队的成员更快的上手融入团队
* 好的系统应该让开发变得容易，使得程序员很容易就能做正确的事情
  * 一个好的团队的项目的代码库风格看上去应该是一致的，而不是迥异的
  * 不管一开始看起来什么样，它永远是人的问题。我们需要类似于 eslint 这类东西尽可能的移除 “人” 这样的干扰因素，通过硬技术手段保证项目的稳定产出。
* 活在当下，避免过度设计：不要尝试去预测未来，让程序能够灵活应对未来的变化即可
* 简洁和清晰
  * 尽可能降低项目维护和学习的门槛
  * 如果不好执行，可以从限制单文件行数入手

从多个视图更新的需求理解 MVC
* 用户行为驱动的意识流编码
  * 视图 A 某行为发生后，也需要更新视图 B/C，想当然的 A 持有 B、C 的引用，然后调用对应的方法，同样 B 某行为发生后需要更新 A、C，导致的结构互相持有多个引用
  * 交叉关系严重，每个实例彼此直接通信，互相折磨，因为当新增或删减视图时，需要维护彼此的调用关系
* 解决办法：职责分离，转换为一份数据对应多个消费者问题，解耦消费者
  * 全局 Store，数据绑定机制
  * 事件机制
* 原则：分离关注点，有助于我们理解系统，专注局部
  * 按照什么样的规则分离关注点 - 职责
  * 关注点的可见度（系统内能做的，能访问的数据）有多少 - 作用域
  * 不同关注点之间如何协作 - 通信
* 单一职责
  * React 中针对容器组件和展示组件的分类，就是一个单一职责划分的例子
* 作用域
  * 当不同的关注点被分离成独立的模块后，它的知识边界在哪里？它们能够知道些什么，不应该知道些什么
* 通信
  * 主动 pull：store.get
  * 主动 push
  * Broadcast 广播
  * Command 命令模式，指示去完成一件事，结果是可以预见，而 event 只是通知而已
  * 被动 push 监听事件的发生
* 数据同步问题：读取、回写

MVC 的不足
* 不可预测：事件发生后，并不知道谁会响应这个事件，是单个对象还是多个对象会响应这个事件
* 级联修改：当一个事件发生后，A 组件接受后在响应的过程中，还可能发出其他的事件触发后续的修改，你并不知道这个事件会在何处结束，会造成什么样的结果
* 响应顺序：如果存在多个对象响应同一个事件的话，有时候对响应的顺序是有要求的，某些变更不可以出现在其他的变更之前
* 有条件响应：对于传播方而言，并非希望所有的时间都一视同仁的广播出去；对于消费方而言，也并不希望一视同仁的响应所有的事件

Flux 设计
* 特征
  * 单向数据流
  * 全局状态管理
  * store/selector 等概念
* 抽取 store 来保证唯一数据源
* 所有的业务逻辑也都封装在 store 中，避免了散落在各处
* store 完成上一个 action 工作之前，不会有其他的 action 再次经过 dispatch 到达 store
* 使用 command 模式避免事件机制造成的不可预测性

我们都统一表现成逻辑和视图实现分离，那么分离之后放哪里呢
* 服务层：服务层和视图层的合作方式也非常简单，通常是把事件委托给服务层而已
* 针对 React 而言，dispatch 扮演者委托角色，store/reducer 类似服务层

> 类库和框架区别在于类库是被你所写的代码调用，而框架是调用你所写的代码。

## CSS
[奇妙的 CSS MASK](https://mp.weixin.qq.com/s/XMiEBQT9MpV9pJyAWsb0qQ)，虽然兼容性不是很好，但真的很有趣。

有趣的 Tailwind CSS，自动根据规则生成使用的 CSS 样式

CSS 的层叠分为两部分
* 样式层叠
* 具体概念的层叠
  * 文档流
  * 格式上下文
  * 层叠上下文
  * 层叠顺序

CSS contain 属性
* 允许开发者声明当前元素和它的内容尽可能独立 DOM 树的其他部分，这使得浏览器在重新计算时，只影响到有限的 DOM 区域，而不是整个页面，有效的改善性能
* 主要目的是隔离指定内容的样式、布局和渲染，它能建立起一个边界，产生一个新的根布局，保证它和它的子元素的 DOM 变化不会触发父元素重新布局、渲染等
* 为什么浏览器不自动实现 contain 功能：浏览器已经尽可能做了优化，但每个浏览器的实现方式不尽相同，contain 提供一种标准的方式告诉浏览器，哪些可以优化，哪些不能优化

CSS 使用 CSS 提高页面的渲染速度
* 新增特性 content-visibility：用于跳过屏幕外的内容渲染，可以接受 visible、auto、hidden 属性
  * 如果浏览器不渲染页面内的一些元素，滚动将是一场噩梦，因为无法正确计算页面高度。content-visibility 会将分配给它的元素的高度（height）视为 0，浏览器在渲染之前会将这个元素的高度变为 0，从而使我们的页面高度和滚动变得混乱。但如果已经为元素或其子元素显式设置了高度，那这种行为就会被覆盖。
  * 如果你的元素中没显式设置高度，并且因为显式设置 height 可能会带来一定的副作用而没设置，那么我们可以使用 contain-intrinsic-size 来确保元素的正确渲染，同时也保留延迟渲染的好处。
  * content-visibility 提供的另外两个值 visible 和 hidden 可以让我们实现元素的显式和隐藏，类似于 display 的 none 和非 none 值的切换，在这种情况下，content-visibility 可以提高频繁显示或隐藏的元素的渲染性能，例如模态框的显示和隐藏。content-visibility 可以提供这种性能提升
* 新增特性 contain：控制页面的重绘与重排
  * layout ：该值表示元素的内部布局不受外部的任何影响，同时该元素以及其内容也不会影响以上级
  * paint ：该值表示元素的子级不能在该元素的范围外显示，该元素不会有任何内容溢出（或者即使溢出了，也不会被显示）
  * size ：该值表示元素盒子的大小是独立于其内容，也就是说在计算该元素盒子大小的时候是会忽略其子元素
  * content ：该值是 contain: layout paint 的简写
  * strict ：该值是 contain: layout paint size 的简写
* 合理使用 will-change：该属性可以表明元素将修改特定的属性，让浏览器事先进行必要的优化
  * 如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。
  * will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。
* 使用 font-display 解决由于字体造成的布局偏移
* scroll-behavior 让滚动更流畅
* 开启 GPU 渲染动画
* 减少渲染阻止时间：响应式布局拆分样式表，在这种情况下，我们可以只让主 CSS 文件阻塞关键路径，并以高优先级下载它，而让其他样式表以低优先级方式下载。
* 避免 @import 包含多个样式表
  * 关于 @import 的关键事实是，它是一个阻塞调用，因为它必须通过网络请求来获取文件，解析文件，并将其包含在样式表中。如果我们在样式表中嵌套了 @import，就会妨碍渲染性能。
  * 与使用 @import 相比，我们可以通过多个 link 来实现同样的功能，但性能要好得多，因为它允许我们并行加载样式表。
* 注意动态修改自定义属性方式
  * CSS 自定义属性又称为 CSS 变量，该特性已经是非常成熟的特性了，可以在 Web 的开发中大胆的使用该特性
  * 在使用 CSS 自定义属性时，时常在 root（根元素）上注册自定义属性，这种方式注册的自定义属性是个全局的自定义属性（全局变量），可以被所有嵌套的子元素继承
  * 可以使用 style.setProperty 来重新设置已注册好的自定义属性的值。但在修改根自定义属性时，需要注意，因为它会影响 Web 的性能

## 2021 前端技术发展
通过项目分布的情况，明显能看到 React 生态圈 >> Vue 生态圈 >> Angular 生态圈；

WebAssembly 核心规范成为浏览器的标准。

在多端复用模块代码中，以 TS + Jest 为基本要求，保证公共代码的可维护性和可测试性：在 TS 编写中，我们更多地遵循面向对象设计原则（SOLID 原则、KISS 原则等），适当的运用设计模式，帮助更好地进行代码开发和维护。同时，在 TS 践行中，辅以单元测试覆盖，可以指导我们更好地拆分组织代码，编写可测试的模块，在公共核心业务模块中覆盖单测用例。

来源于一份榜单总结：[2021年JavaScript明星项目](https://mp.weixin.qq.com/s/f4Vo0WliR_ASGtwmxUeOQw)

值得把玩一下 google 出品的 zx，用 javascript 编写命令行脚本
* 你可以使用 bash 表达式，也可以使用 javascript 语法
* 包含几个流行包提供的使用工具
  * chalk 多样化 log 输出
  * node-fetch 在浏览器中使用相同的 API 进行 HTTP 请求
  * fs-extra 来处理文件系统操作
  * globby 用户友好的 glob 匹配
  * which 类似于 which unix 命令。在 PATH 中查找可执行文件的第一个实例

值得期待的 vite，就不多说啦。

简单介绍一下 next.js 是什么哈
* 创建完备的 React 项目，免于繁琐配置，类似 cra
* 基于约定而非代码的方式，封装了一下路由系统，应该是内化了 react-router
* 预渲染，也就是编译期间生成 html 代码，可以用于生成静态站点，比如解析 markdown，生成静态站点，类似 gatsby
* 服务端渲染，用于优化首屏加载与 SEO
* 可以用来写后端 api，类似 koa.js

主要的 UI 框架都有自己的"元框架"来构建现代和可扩展的应用程序，提供诸如路由、服务器端渲染、页面的静态生成、为生产优化构建等功能。
* React 有 Next.js
* Vue 有 Nuxt.js
* Svelte 有 SvelteKit

构建工具
* vite
* esbuild - go
* swc - rust
* lerna：仍然被广泛使用，但没有得到很好的维护
* nx：monorepo 工具，它可以大大缩短构建时间。**这个值得关注**

TypeDoc 生成使用文档

静态网站
* Next.js 嘿嘿，你又出现了
* Docusaurus
* Nuxt.js
* Gatsby

状态管理
* 我只能说 React 状态管理是真的多：Zustand/XState/Jotai/Valtio/Recoil/Redux/Mobox
* Vue 就正常很多：Pinia/Vuex
