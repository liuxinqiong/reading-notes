~~[探索 webpack5 新特性 Module federation 在腾讯文档的应用](https://mp.weixin.qq.com/s/iS-prT1xZPV6cpH7MHRRdQ)~~
~~[图解常用的 Git 指令含义](https://mp.weixin.qq.com/s/oKMdlo6jsIcMcZW8nzoAUg)~~
~~[这才是真正的Git——Git内部原理揭秘！](https://mp.weixin.qq.com/s/jN-CGrf7oosutxLEvxvWiw)~~
~~[Service Worker 运用与实践](https://mp.weixin.qq.com/s/vI2bxaFsFSB5rGC4Bkr8vQ)~~
~~[JavaScript 20 年中文版 - 语言诞生](https://mp.weixin.qq.com/s/eRne5EIQGDbE0-JclAzNAA)~~
~~[微前端在小米 CRM 系统的实践](https://mp.weixin.qq.com/s/5qwgZ9aNKFC3naWRUGajmA)~~
~~[微前端在企业级应用中的实践(上)](https://mp.weixin.qq.com/s/tutFXv6djecT6lnL9Je71Q)~~

~~[NutUI Picker组件的设计与实现](https://mp.weixin.qq.com/s/13kGxbdIVeOzbObrECdEeQ)~~
~~[多应用项目开发架构和多进程间构建优化分析](https://mp.weixin.qq.com/s/O0e2Iou96PDUiNN5uciyIA)~~
~~[Mutex 和上厕所居然有这么多异曲同工之妙](https://mp.weixin.qq.com/s/3gAa31IkCaj6P0rgM03-LQ)~~

~~[可扩展的前端 -- 架构基础](https://mp.weixin.qq.com/s/AYf8CkwY1NjBvv_HzggmZw)~~
~~[可扩展的前端 -- 常见模式](https://mp.weixin.qq.com/s/6LJH6Myr4ulrYByIAaq_XQ)~~

~~[闪电智能创作平台项目前端总结](https://mp.weixin.qq.com/s/sQHLetPT85w4fKrv15Qf0g)~~
~~[在浏览器中存储数据 - IndexedDB](https://mp.weixin.qq.com/s/EO10qD9hn4cuH5o74_EPSQ)~~
~~[奇妙的 CSS MASK](https://mp.weixin.qq.com/s/XMiEBQT9MpV9pJyAWsb0qQ)~~

~~[2020年大前端技术趋势解读](https://mp.weixin.qq.com/s/slghkDUyng7tOha3JFzeCQ)~~
~~[如何自己开发一款力导向图？](https://mp.weixin.qq.com/s/jnqmcOVQwnEZ8atzgZe1pQ)~~
~~[交互导入模式](https://mp.weixin.qq.com/s/6O3CYnzbBCHrUWeYG-Yx4Q)~~
~~[2020 CSS 现状调查](https://mp.weixin.qq.com/s/9B_xxJh9Lx2t0vssCh5buA)~~
~~[自适应布局最佳实践](https://mp.weixin.qq.com/s/8GvZetosiFJmZ1n3ZLfxNA)~~
~~[CSS现状和如何学习](https://mp.weixin.qq.com/s/1Zg1sQyP186UNpr2GtDvqw)~~

~~[如何提高CSS性能](https://mp.weixin.qq.com/s/Sc3ksTndrrNSH5wAhtgAaw)~~
~~[前端质量保证体系建设](https://mp.weixin.qq.com/s/5eKznqIkIf4-4AjbPwUR6w)~~
~~[前端性能优化](https://mp.weixin.qq.com/s/J60NkG8A_E-vI3RpKQSTmw)~~
~~[单元测试最佳实践](https://mp.weixin.qq.com/s/1A8t_YA8Iszi-BljUKs6GQ)~~

~~[深入了解现代浏览器之四](https://mp.weixin.qq.com/s/XN9wUM-FdWbE1m66jkEgIg)~~
~~[JavaScript代码整洁之道-概述篇](https://mp.weixin.qq.com/s/jvnDyNdhjpYaABwgl6YunQ)~~
~~[JavaScript代码整洁之道-函数篇](https://mp.weixin.qq.com/s/dmvlOiu7iOmBQpNPAXXotw)~~
~~[JavaScript代码整洁之道-复杂判断](https://mp.weixin.qq.com/s/tpkGpxNUl2K7d4AFvZym_g)~~

~~[从 Prompt 来看微前端路由劫持原理](https://mp.weixin.qq.com/s/WDvtyELAPZ_gtn-wF4G7Dw)~~
~~[仅使用CSS提高页面渲染速度](https://mp.weixin.qq.com/s/nM_M-B6oDk9PHJkURBKFkA)~~
~~[狼叔看next.js](https://mp.weixin.qq.com/s/EWa6QZHItPlj6H3Q_H247w)~~

~~[前端架构 101：在谈论它们之前我们需要达成的共识](https://mp.weixin.qq.com/s/iupP8wiJzUjJJ2cqSDDFLQ)~~
~~[前端架构 101：MVC 初探](https://mp.weixin.qq.com/s/8ILlKiZIGCqqVoKhH4VDtA)~~
~~[前端架构 101：MVC启示录 - 模块的职责，作用域和通信](https://mp.weixin.qq.com/s/w24UUSl_kosclM_ct8Hk3w)~~
~~[前端架构 101：MVC 的不足与 Flux 的崛起](https://mp.weixin.qq.com/s/BB1VUmtQ5uBJ7VSnRf11ZQ)~~
~~[前端架构 101：从 Flux 进化到 Model-View-Presenter](https://mp.weixin.qq.com/s/jB3POItNJ-MjI_Ubeu_Dfw)~~
~~[前端架构 101：整洁（Clean Architecture）架构是归宿](https://mp.weixin.qq.com/s/n9myHRtXleOY2MKZWhN8Eg)~~

~~[前端架构鉴赏01：Angular 架构模式与最佳实践](https://mp.weixin.qq.com/s/gz98PLI4ne1-AAa-MMC6aw)~~
~~[前端架构鉴赏02：可拓展 Angular 2 架构](https://mp.weixin.qq.com/s/4bd-xkyus-tNuylTBm_tGw)~~
~~[前端架构鉴赏03：Angular 与 MVP 模式](https://mp.weixin.qq.com/s/7uYxFxbvcZS4wjbWPVmGpg)~~

[彻底搞懂 React 源码调度原理（Concurrent模式）](https://mp.weixin.qq.com/s/xHfhMqa5Nsw_5i6MkK2X0A)
[从 React Hooks 看 React 的本质](https://mp.weixin.qq.com/s/t0CLAb7CCZY-paEJque1RA)
[React Hooks 的体系设计之四 - 玩坏 ref](https://mp.weixin.qq.com/s/7c6zncb5ZIef9xgaAvt9uw)
[React Hooks 设计思想](https://mp.weixin.qq.com/s/9Uuy5t-TL9cnCWY_GtQpNQ)
[React 18 新特性之 startTransition](https://mp.weixin.qq.com/s/JAFdq0BBu4rVAoPAdKWe8A)
[React Conf 2021 为 React 18 带来了哪些新东西？](https://mp.weixin.qq.com/s/tKxM2YcNk2K5Ot1nCbqoeg)
[探索 React 的内在 — Fiber & Algebraic Effects](https://mp.weixin.qq.com/s/7MQp1CrZFwNd4dQ3y2C-UA)
[探索 React 的内在 - postMessage 和 Scheduler](https://mp.weixin.qq.com/s/x4HvKm6w_nc02CZcOiwTTA)
[深入源码剖析componentWillXXX为什么UNSAFE](https://mp.weixin.qq.com/s/aL5NHz3Jq4KZT_m5rIbx3A)

~~[连0.2这么简单的数字都搞不定！你被炒了！](https://mp.weixin.qq.com/s/Cd4uRslnek8r_a6chjwnYQ)~~
[图解 | 你管这破玩意叫计算机？](https://mp.weixin.qq.com/s/prJ767KGkhw3cc53BniNJg)
[图解 | 你管这破玩意叫动态规划](https://mp.weixin.qq.com/s/JIQKOxKsFa0I3HyQvOT5Jw)
[图解 | 你管这破玩意叫文件系统？](https://mp.weixin.qq.com/s/GcIZRk2kWrpKx7Ti3KqDHQ)
[图解 | 你管这破玩意叫 class？](https://mp.weixin.qq.com/s/-_Y-zFNTrBVQchQxj7TGHA)
[图解线程状态，看完浑身通透](https://mp.weixin.qq.com/s/aG_uBLQevyZEFTOLK-kH9g)
[你管这破玩意叫 IO 多路复用？](https://mp.weixin.qq.com/s/3gC-nUnFGv-eoSBsEdSZuA)
[都是缓存惹的祸](https://mp.weixin.qq.com/s/7PgUa696U5pZFLEcbWHYSA)
[你管这破玩意叫哨兵？](https://mp.weixin.qq.com/s/ijTnqfKvwP7ldYusQGl9tA)
[最多能创建多少个TCP连接？](https://mp.weixin.qq.com/s/mGkf-9LZhhUgSIRBRqfRDw)
[你管这破玩意叫 RDB？](https://mp.weixin.qq.com/s/vsmoOxMXn2nG7OYjJkbb7A)
[你管这破玩意叫 OAuth？](https://mp.weixin.qq.com/s/FnWUwEp2PuOxqnF5URB-WA)
[从上厕所想到的线程池设计原理](https://mp.weixin.qq.com/s/rxaNWAgpt7umtftDk3eKUA)

# 笔记记录

## 工程
多应用如何做到代码共享

chunk 和 module
* module：每个源码 js 文件其实都可以看成一个 module
* chunk：每个打包落地的 js 文件其实都是一个 chunk，每个 chunk 包含很多 module
* 默认的 chunk 数量实际上是由你的入口文件的 js 数量决定的，但是如果你配置动态加载或者提取公共包的话，也会生成新的 chunk

webpack5 的 Module federation：允许运行时动态决定代码的引入和加载。先看下简单配置
```js
{
    plugins: [
        new ModuleFederationPlugin({
            name: 'app1',
            library: {
                type: 'var',
                name: 'app1',
            },
            remotes: {
                app2: 'app2',
            },
            shared: ['react', 'react-dom']
        })
    ]
}
```

你需要了解的是
* remotes 的代码自己不打包，类似 external
* shared 的代码自己是有打包的

## Git
Git object 类型
* blob 类型：存储文件内容，不包括文件名等其他信息
* tree 类型：当前目录结构打了一个快照
* commit 类型：存储一个提交的信息，包括对应目录结构的快照 tree 的哈希值、上一个提交的哈希值、提交的作者以、提交时间和提交信息
* tag 类型：在添加含附注的 tag 时会新建

非常不错的 Git 图解资料：[CS Visualized: Useful Git Commands](https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1)，加深了我对一些命令的理解，比如
* git merge 的两种合并策略
  * fast-forward
  * no-fast-forward
* git rebase
  * 为什么 git rebase 提交历史会很清爽
* 交互式变基
  * reword 修改提交信息
  * edit 修改此提交
  * squash 将当前提交合并到之前的提交中
  * fixup 将当前提交合并到之前的提交中，不保留提交日志信息
  * exec 在每一个需要变基的提交上执行一条命令
  * drop 删除提交
* git revert 用于还原某次提交的修改，会创建一个包含已还原更改的新提交记录

## 微前端
实现微前端的常见方式
* 路由分发：比较传统的方式，你可以通过 HTTP 服务器的反向代理来实现
* 前端微服务化：通过模块化的方式组合出完整的应用，比较典型的实现：single-spa
* 微应用：开发时以微小应用的方式存在，运行时，通过构建合并这些应用
* 微件化：一段直接嵌入应用上运行的代码，开发人员预先编译好且部署到指定的服务器上
* iframe
* Web Components：允许开发者创建可重用的定制元素

对于微前端的诉求
* 独立开发、独立部署、增量更新、技术栈无关
* 运行时隔离与共享：js 和 css 互相隔离不受影响，同时又有同新机制保证应用之间能够互相通信或数据共享
* 单页面应用的良好体验：不会 reload 整个页面，如同单页般站内路由切换

## React
在早期的 React Router 中，提供了开箱即用的滚动恢复的支持。

浏览器开始处理带有历史记录的滚动恢复。它已经在浏览器中工作的很好。

因为浏览器开始处理默认情况，而应用程序有不同的滚动需求。

比如滚动到顶部
```js
export default function ScrollToTop() {
  const { pathname } = useLocation();

  useEffect(() => {
    window.scrollTo(0, 0);
  }, [pathname]);

  return null;
}

function ScrollToTopOnMount() {
  useEffect(() => {
    window.scrollTo(0, 0);
  }, []);

  return null;
}
```

ScrollRestoration 的工作原理
* 操作 window 对象
* 使用 location.key 进行 window 滚动位置记录到 sessionStorage
* 当 ScrollRestoration 组件挂载时，从 sessionStorage 寻找滚动位置

## 架构
相关共识
* 满足非功能性需求
  * 可扩展性、可维护性、可测试性
  * 和业务需求没有任何关系，产品经理不在乎你写得多烂，只在乎能够上线，至于这部分代码将来的维护成本有多高与他无关，但与我们有关
  * 减少项目的维护成本，还能够让新加入团队的成员更快的上手融入团队
* 好的系统应该让开发变得容易，使得程序员很容易就能做正确的事情
  * 一个好的团队的项目的代码库风格看上去因该是一致的，而不是迥异的
  * 不管一开始看起来什么样，它永远是人的问题。我们需要类似于 eslint 这类东西尽可能的移除 “人” 这样的干扰因素，通过硬技术手段保证项目的稳定产出。
* 活在当下，避免过度设计：不要尝试去预测未来，让程序能够灵活应对未来的变化即可
* 简洁和清晰
  * 尽可能降低项目维护和学习的门槛
  * 如果不好执行，可以从限制单文件行数入手

从多个视图更新的需求理解 MVC
* 用户行为驱动的意识流编码
  * 视图 A 某行为发生后，也需要更新视图 B/C，想当然的 A 持有 B、C 的引用，然后调用对应的方法，同样 B 某行为发生后需要更新 A、C，导致的结构互相持有多个引用
  * 交叉关系严重，每个实例彼此直接通信，互相折磨，因为当新增或删减视图时，需要维护彼此的调用关系
* 解决办法：职责分离，转换为一份数据对应多个消费者问题，解耦消费者
  * 全局 store，数据绑定
  * 事件机制
* 原则：分离关注点，有助于我们理解系统，专注局部
  * 按照什么样的规则分离关注点 - 职责
  * 关注点的可见度（系统内能做的，能访问的数据）有多少 - 作用域
  * 不同关注点之间如何协作 - 通信
* 单一职责
  * React 中针对容器组件和展示组件的分类，就是一个单一职责划分的例子
* 作用域
  * 当不同的关注点被分离成独立的模块后，它的知识边界在哪里？它们能够知道些什么，不应该知道些什么
* 通信
  * 主动 pull：store.get
  * 主动 push
  * Broadcast 广播
  * Command 命令模式，指示去完成一件事，结果是可以预见，而 event 只是通知而已
  * 被动 push 监听事件的发生
* 数据同步问题：读取、回写

MVC 的不足
* 不可预测：事件发生后，并不知道谁会响应这个事件，是单个对象还是多个对象会响应这个事件
* 级联修改：当一个事件发生后，A 组件接受后在响应的过程中，还可能发出其他的事件触发后续的修改，你并不知道这个事件会在何处结束，会造成什么样的结果
* 响应顺序：如果存在多个对象响应同一个事件的话，有时候对响应的顺序是有要求的，某些变更不可以出现在其他的变更之前
* 有条件响应：对于传播方而言，并非希望所有的时间都一视同仁的广播出去；对于消费方而言，也并不希望一视同仁的响应所有的事件

Flux 设计
* 特征
  * 单向数据流
  * 全局状态管理
  * store/selector 等概念
* 抽取 store 来保证唯一数据源
* 所有的业务逻辑也都封装在 store 中，避免了散落在各种
* store 完成上一个 action 工作之前，不会有其他的 action 再次经过 dispatch 到达 store
* 使用 command 模式避免事件机制造成的不可预测性

我们都统一表现层逻辑和视图实现分离，那么分离之后放哪里呢
* 服务层：服务层和视图层的合作方式也非常简单，通常是把事件委托给服务层而已
* 针对 React 而言，dispatch 扮演者委托角色，store/reducer 类似服务层

> 类库和框架区别在于类库是被你所写的代码调用，而框架是调用你所写的代码。

代码中常看到 Utils 和 Helper 类，但他们有什么区别呢？中文社区一般偏向于区别不大，但老外 还是很讲究的
* Utils 类：一般是无状态的，只包含静态方法，使用时无需创建类的实例
* Helper 类：可以有状态，一般需要创建实例才能使用

## 前端质量
质量保证措施
* 需求理解错误
  * 方案评审会议
  * 验收标准制定
* 程序编码错误
  * 静态检查
  * 代码审查
  * 自动化测试
* 罕见特殊状态
  * 大规模 Beta 测试
  * 监控机制
  * 回滚机制

方案设计要点
* **流程图**
* **组件/类图**
* **时序图**
* 外部依赖
* 性能监控
* 功能影响
* 兼容性

静态检查配置
* 语言
  * eslint-plugin-sonarjs
  * @typescript-eslint/parser
  * eslint-config-airbnb-typescript
* 框架
  * eslint-plugin-react
  * eslint-plugin-react-hooks
  * eslint-plugin-jest
* 安全
  * eslint-plugin-security
* 无障碍
  * eslint-plugin-jsx-a11y
* 自定义
  * eslint-plugin-local-rules

监控机制
* 异常监控 - sentry.io
* 性能监控
* 安全监控 -checkmarx
* BUG 反馈系统

回滚机制
* 基于 LaunchDarkly 实验性功能开关控制
* 基于 Lambda@Edge 的整体回滚方案

团队成长
* 快速试错
  * 早期成本低
  * 快速成长
* 定期回顾
  * 流程回顾：有何问题？如何改进？
  * BUG 回顾：根源是啥？如何避免？

React 性能监控
* 配置 Profile - 开启组件更新高亮
* 配置 Profile - 开启组件渲染原因记录

单元测试实践
* 在日常开发中践行 TDD，把需求点转换为测试点，先测试后开发。
* 大粒度结合小粒度，大粒度测功能，小粒度测独立模块，大粒度测主干，小粒度测特殊情况。
* 可复用模块进行独立的小粒度测试
* 大粒度测试与 QA 的测试点对应：Given... When... Should...
* 避免直接测试私有方法/属性，因为它通常是非常不稳定的
* 减少重复代码
  * 善用 describe/beforeEach/beforeAll
  * 提取变量，创建工具方法，setUp/functions/mock utils

## 代码整洁
变量命名
* ……
* 避免使用智能统一词，统一团队用语
* 避免不必要的上下文：主要用在类或者包中变量名的定义上
* 避免使用魔法数字和魔法字符串：使用一个有语义的常量存储

关于函数
* 参数入参不易过多，在我看来 3 个已经是上限了，过多时考虑是否可以组合成一个对象
* 避免副作用
  * 全局变量
  * 对象变异
* 只做一件事
* 更多的使用函数式编程，而不是命令式

复杂判断
* 不要使用标记（flag）作为函数参数，会破坏函数功能的单一性。推荐创建两个函数实现各自对应的逻辑功能
* 封装判断条件，将条件封装在具有明确语义的函数或变量中，可以更直观的理解代码逻辑
* 使用卫语句：开发中不应该有嵌套的条件语句存在，卫语句是我们避免嵌套条件的主要技术之一，本质上就是提前结束
* 空对象模式：通过返回空串、空数组、甚至自定义的空对象行为的对象，来减少不需要的判断
* 通过多态删除条件判断
* 使用策略模式/命令模式移除条件

关于异常处理
* 优选选择异常，而不是错误码：如果语言本身有错误处理机制的前提
* 不要忘记捕获异常：进行错误上报和提示
* 不要忽略 promise reject 的情况
* 异常等级

## 基础

### 关于锁
* 原子操作：指不会被线程调度打断的操作，操作一旦开始，就会一直运行到结束，中间不会有上下文切换。数据库事务中的 ACID 中的 A 指的就是原子性。
* 原子操作可以分为软件层面和硬件层面，硬件层面的原子操作又分为单核 CPU 和多核 CPU，单核 CPU 中，能够在一个指令中完成的操作都可以看做原子操作，因为中断只发生在指令切换中。多核 CPU 情况下，runtime 运行着多个独立 CPU，即使单个指令的操作，也可能被干扰。原子操作在硬件层面有所实现，比如 x86 架构下，CPU 提供了 HLOCK pin 引线，允许 CPU 在执行某个指令时拉低 HLOCK pin 引线的电位，直到指令执行完毕才放开。锁住了总线其他核就无法继续执行指令，此时就可以保证多核处理器的原子性
* CAS 用来保证加锁过程中的原子性，会比较地址指针是否为 old，为 old 说明操作期间没有被打断，就地址值替换为 new，返回 true,不为 old, 代表操作期间被其他线程打断了，返回 false。

### 关于浮点数
计算机的本质决定了它是一个二进制的世界，人类熟悉的十进制数字需要转行成二进制才能被计算机处理。但是这个转化的过程却会遇到问题。从漫画中可以看出十进制整数都能精确地转化为二进制表示，但是十进制小数却并不一定。

对于工程计算和科学计算，一个非常近似的二进制小数是可以满足要求的，但是在商业计算尤其是金融领域，必须要精确地表示，精确地计算，这个时候就不能直接使用 float，double 等类型了，需要用一个工具类如 BigDecimal 来进行处理。

拼凑法进行转换
* 整数部分和小数部分，各自对应者一个工具箱，分别存储着 2^n 和 2^-n 方对应的二进制值。当十进制数进来时，查表看有没有，没有则查找最近的，然后不断进行拼凑
* 对于十进制整数，只要能表示层 2^n 次方的和，就能拼凑出来。十进制小数只要能表示成 2^-n 的和，也能拼凑，但有不少十进制小数不满足这个性质
* 解决不精准问题：把小数转换成整数，记录下小数点后面有几位小数，然后通过整数进行运算。这就是 BigDecimal 的原理

对于浮点数的存储制定了规范，比如 IEEE 754
* 定点数方案：比如针对 32 位的存储，首位（符号为）+ 8 位整数位 + 23 位小数位，小数点固定在了具体的位置，因此称为定点数。但对于整数部分和小数部分位数的分配是个问题，整数部分大，能表示的范围大，小数部分大，那数据就更精确。所以很难选择，不是完美的解决方案
* 科学记数法：368.79 表示为 3.6879 * 10^2
* 浮点数就是利用指数达到小数点浮动的效果，从而灵活的表达更大范围内的数。不过对于同一个浮点数，也有很多表达方式，取决于你的指数取多大，由于其多样性，因此我们需要特定的标准
* IEEE 754 标准，有单精度（32）和双精度（64）
  * 科学表示为：(+ or - ) 1.(mantissa) * 2 ^ exponent，比如 5.8 表示成 1.45 * 2 ^ 2
  * 针对 5.8：符号为 s = 0；指数部分需要注意，指数也有正负之分，既要用 8 为表示正数，又要能表示负数，因此分开使用 0-127 表示负数，128-255 表示正数。127 被称为偏置值。所以 exponent = 127 + 2 = 129。尾数 mantissa 是 0.45，需要转化成二进制，不断的乘 2，去结果的整数部分就行，有时候这一部会出现无限循环，这时候取到要求的 23 位就行，可见浮点数是不精确的

## CSS
[奇妙的 CSS MASK](https://mp.weixin.qq.com/s/XMiEBQT9MpV9pJyAWsb0qQ)，虽然兼容性不是很好，但真的很有趣。

有趣的 Tailwind CSS，自动根据规则生成使用的 CSS 样式

CSS 的层叠分为两部分
* 样式层叠
* 具体概念的层叠
  * 文档流
  * 格式上下文
  * 层叠上下文
  * 层叠顺序

CSS contain 属性
* 允许开发者声明当前元素和它的内容尽可能独立 DOM 树的其他部分，这使得浏览器在重新计算时，只影响到有限的 DOM 区域，而不是整个页面，有效的改善性能
* 主要目的是隔离指定内容的样式、布局和渲染，它能建立起一个边界，产生一个新的根布局，保证它和它的子元素的 DOM 变化不会触发父元素重新布局、渲染等
* 为什么浏览器不自动实现 contain 功能：浏览器已经尽可能做了优化，但每个浏览器的实现方式不尽相同，contain 提供一种标准的方式告诉浏览器，那些可以优化，哪些不能优化

CSS 使用 CSS 提高页面的渲染速度
* 新增特性 content-visibility：用于跳过屏幕外的内容渲染，可以接受 visible、auto、hidden 属性
  * 如果浏览器不渲染页面内的一些元素，滚动将是一场噩梦，因为无法正确计算页面高度。content-visibility 会将分配给它的元素的高度（height）视为 0，浏览器在渲染之前会将这个元素的高度变为 0，从而使我们的页面高度和滚动变得混乱。但如果已经为元素或其子元素显式设置了高度，那这种行为就会被覆盖。
  * 如果你的元素中没显式设置高度，并且因为显式设置 height 可能会带来一定的副作用而没设置，那么我们可以使用 contain-intrinsic-size 来确保元素的正确渲染，同时也保留延迟渲染的好处。
  * content-visibility 提供的另外两个值 visible 和 hidden 可以让我们实现像元素的显式和隐藏，类似于 display 的 none 和非 none 值的切换，在这种情况下，content-visibility 可以提高频繁显示或隐藏的元素的渲染性能，例如模态框的显示和隐藏。content-visibility 可以提供这种性能提升
* 新增特性 contain：控制页面的重绘与重排
  * layout ：该值表示元素的内部布局不受外部的任何影响，同时该元素以及其内容也不会影响以上级
  * paint ：该值表示元素的子级不能在该元素的范围外显示，该元素不会有任何内容溢出（或者即使溢出了，也不会被显示）
  * size ：该值表示元素盒子的大小是独立于其内容，也就是说在计算该元素盒子大小的时候是会忽略其子元素
  * content ：该值是contain: layout paint的简写
  * strict ：该值是contain: layout paint size的简写
* 合理使用 will-change：该属性可以表明元素将修改特定的属性，让浏览器事先进行必要的优化
  * 如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。
  * will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。
* 使用 font-display 解决由于字体造成的布局偏移
* scroll-behavior 让滚动更流畅
* 开启 GPU 渲染动画
* 减少渲染阻止时间：响应式布局拆分样式表，在这种情况下，我们可以只让主 CSS 文件阻塞关键路径，并以高优先级下载它，而让其他样式表以低优先级方式下载。
* 避免 @import 包含多个样式表
  * 关于 @import 的关键事实是，它是一个阻塞调用，因为它必须通过网络请求来获取文件，解析文件，并将其包含在样式表中。如果我们在样式表中嵌套了 @import，就会妨碍渲染性能。
  * 与使用 @import 相比，我们可以通过多个 link 来实现同样的功能，但性能要好得多，因为它允许我们并行加载样式表。
* 注意动态修改自定义属性方式
  * CSS 自定义属性又名 CSS 变量，该特性已经是非常成熟的特性了，可以在 Web 的开发中大胆的使用该特性
  * 在使用 CSS 自定义属性时，时常在 root（根元素）上注册自定义属性，这种方式注册的自定义属性是个全局的自定义属性（全局变量），可以被所有嵌套的子元素继承
  * 可以使用 style.setProperty 来重新设置已注册好的自定义属性的值。但在修改根自定义属性时，需要注意，因为它会影响 Web 的性能

## 趋势
通过项目分布的情况，明显能看到 React 生态圈>> Vue 生态圈>> Angular 生态圈；

WebAssembly 核心规范成为浏览器的标准。

在多端复用模块代码中，以 TS + Jest 为基本要求，保证公共代码的可维护性和可测试性：在 TS 编写中，我们更多地遵循面向对象设计原则（SOLID 原则、KISS 原则等），适当的运用设计模式，帮助更好地进行代码开发和维护。同时，在 TS 践行中，辅以单元测试覆盖，可以指导我们更好地拆分组织代码，编写可测试的模块，在公共核心业务模块中覆盖单测用例。

区分一下 no-code、low-code、pro-code
* no-code：自己编程给自己用，给用户的感觉就是一个软件。因此，平台不会给自己定位成一个“编程工具”。主要是通过图形化的操作来降低学习曲线，类似PPT、Excel等。在垂直领域的特定场景中，才能做到好用。
* low-code：编程给其他人用，通过降低专业难度，让运营人员（CitizenDeveloper）也参与进来。平台评估好预制的场景和需求，减少从头写代码的成本，一定程度上可以通过图形化的方式满足业务诉求。
* pro-code：日常软件开发过程中的手写代码，可以通过逻辑和模块复用来进行提效。

## 2021 前端技术发展
来源于一份榜单总结：[2021年JavaScript明星项目](https://mp.weixin.qq.com/s/f4Vo0WliR_ASGtwmxUeOQw)

值得把玩一下 google 出品的 zx，用 javascript 编写命令行脚本
* 你可以使用 bash 表达式，也可以使用 javascript 语法
* 包含几个流行包提供的使用工具
  * node-fetch 在浏览器中使用相同的 API 进行 HTTP 请求
  * fs-extra 来处理文件系统操作
  * globby 匹配给定用户友好模式的文件名

值得期待的 vite 就不多说啦。

我尝试给你介绍一下 next.js 是什么哈
* 创建完备的 React 项目，免于繁琐配置，类似 cra
* 基于约定而非代码的方式，封装了一下路由系统，应该是内化了 react-router
* 预渲染，也就是编译期间生成 html 代码，可以用于生成静态站点，比如解析 markdown，生成静态站点，类似 gatsby
* 服务端渲染，用于优化首屏加载与 SEO
* 可以用来写后端 api，类似 koa.js

主要的 UI 框架都有自己的"元框架"来构建现代和可扩展的应用程序，提供诸如路由、服务器端渲染、页面的静态生成、为生产优化构建等功能。
* React 有 Next.js
* Vue 有 Nuxt.js
* Svelte 有 SvelteKit

构建工具
* vite
* esbuild - go
* swc - rust
* lerna：仍然被广泛使用，但没有得到很好的维护
* nx：monorepo 工具，它可以大大缩短构建时间。**这个值得关注**

React 18 即将到来的新特性
* 自动批处理
* SSR 对于 Suspense 支持
* 并发模式

React 18 带来了以下 3 个方面的更新：
* Automatic batching
* SSR for Suspense
* New APIs for app and library developers

什么时候中断渲染呢？当一个更高优先级渲染到来时，通过放弃当前的渲染，立即执行更高优先级的渲染，换来视觉上更快的响应速度。
* useTransition：允许组件在切换到下一个界面之前等待内容加载，从而避免不必要的加载状态。
* startTransition：被 startTransition 回调包裹的 setState 触发的渲染 被标记为不紧急的渲染，这些渲染可能被其他紧急渲染所抢占。
* useDeferredValue：返回一个延迟响应的值，例如一个选择输入框过滤列表的场景，我们可以针对列表使用 useDeferredValue 传入选择器对应的值。
新的 startTransition 与 useDeferredValue API，本质上都是允许你将 UI 的一部分标记为较低的更新优先级。

如果你要你要禁用自动合并更新，可以使用 react-dom 导出的 flushSync 进行同步更新

TypeDoc 生成使用文档

静态网站
* Next.js 嘿嘿，你又出现了
* Docusaurus
* Nuxt.js
* Gatsby

状态管理
* 我只能说 React 状态管理是真的多：Zustand/XState/Jotai/Recoil/Redux/Valtio/Mobox
* Vue 就正常很多：Pinia/Vuex
