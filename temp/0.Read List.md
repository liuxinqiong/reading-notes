~~[探索 webpack5 新特性 Module federation 在腾讯文档的应用](https://mp.weixin.qq.com/s/iS-prT1xZPV6cpH7MHRRdQ)~~
~~[图解常用的 Git 指令含义](https://mp.weixin.qq.com/s/oKMdlo6jsIcMcZW8nzoAUg)~~
~~[这才是真正的Git——Git内部原理揭秘！](https://mp.weixin.qq.com/s/jN-CGrf7oosutxLEvxvWiw)~~
~~[Service Worker 运用与实践](https://mp.weixin.qq.com/s/vI2bxaFsFSB5rGC4Bkr8vQ)~~
~~[JavaScript 20 年中文版 - 语言诞生](https://mp.weixin.qq.com/s/eRne5EIQGDbE0-JclAzNAA)~~
~~[微前端在小米 CRM 系统的实践](https://mp.weixin.qq.com/s/5qwgZ9aNKFC3naWRUGajmA)~~
~~[微前端在企业级应用中的实践(上)](https://mp.weixin.qq.com/s/tutFXv6djecT6lnL9Je71Q)~~

~~[NutUI Picker组件的设计与实现](https://mp.weixin.qq.com/s/13kGxbdIVeOzbObrECdEeQ)~~
~~[多应用项目开发架构和多进程间构建优化分析](https://mp.weixin.qq.com/s/O0e2Iou96PDUiNN5uciyIA)~~
~~[Mutex 和上厕所居然有这么多异曲同工之妙](https://mp.weixin.qq.com/s/3gAa31IkCaj6P0rgM03-LQ)~~

~~[可扩展的前端 -- 架构基础](https://mp.weixin.qq.com/s/AYf8CkwY1NjBvv_HzggmZw)~~
~~[可扩展的前端 -- 常见模式](https://mp.weixin.qq.com/s/6LJH6Myr4ulrYByIAaq_XQ)~~

~~[闪电智能创作平台项目前端总结](https://mp.weixin.qq.com/s/sQHLetPT85w4fKrv15Qf0g)~~
~~[在浏览器中存储数据 - IndexedDB](https://mp.weixin.qq.com/s/EO10qD9hn4cuH5o74_EPSQ)~~
~~[奇妙的 CSS MASK](https://mp.weixin.qq.com/s/XMiEBQT9MpV9pJyAWsb0qQ)~~

~~[2020年大前端技术趋势解读](https://mp.weixin.qq.com/s/slghkDUyng7tOha3JFzeCQ)~~
~~[如何自己开发一款力导向图？](https://mp.weixin.qq.com/s/jnqmcOVQwnEZ8atzgZe1pQ)~~
~~[交互导入模式](https://mp.weixin.qq.com/s/6O3CYnzbBCHrUWeYG-Yx4Q)~~
~~[2020 CSS 现状调查](https://mp.weixin.qq.com/s/9B_xxJh9Lx2t0vssCh5buA)~~
~~[自适应布局最佳实践](https://mp.weixin.qq.com/s/8GvZetosiFJmZ1n3ZLfxNA)~~
~~[CSS现状和如何学习](https://mp.weixin.qq.com/s/1Zg1sQyP186UNpr2GtDvqw)~~

~~[如何提高CSS性能](https://mp.weixin.qq.com/s/Sc3ksTndrrNSH5wAhtgAaw)~~
~~[前端质量保证体系建设](https://mp.weixin.qq.com/s/5eKznqIkIf4-4AjbPwUR6w)~~
~~[前端性能优化](https://mp.weixin.qq.com/s/J60NkG8A_E-vI3RpKQSTmw)~~
~~[单元测试最佳实践](https://mp.weixin.qq.com/s/1A8t_YA8Iszi-BljUKs6GQ)~~

~~[深入了解现代浏览器之四](https://mp.weixin.qq.com/s/XN9wUM-FdWbE1m66jkEgIg)~~
~~[JavaScript代码整洁之道-概述篇](https://mp.weixin.qq.com/s/jvnDyNdhjpYaABwgl6YunQ)~~
~~[JavaScript代码整洁之道-函数篇](https://mp.weixin.qq.com/s/dmvlOiu7iOmBQpNPAXXotw~~)
~~[JavaScript代码整洁之道-复杂判断](https://mp.weixin.qq.com/s/tpkGpxNUl2K7d4AFvZym_g)~~

~~[从 Prompt 来看微前端路由劫持原理](https://mp.weixin.qq.com/s/WDvtyELAPZ_gtn-wF4G7Dw)~~
~~[仅使用CSS提高页面渲染速度](https://mp.weixin.qq.com/s/nM_M-B6oDk9PHJkURBKFkA)~~
~~[狼叔看next.js](https://mp.weixin.qq.com/s/EWa6QZHItPlj6H3Q_H247w)~~

[彻底搞懂 React 源码调度原理（Concurrent模式）](https://mp.weixin.qq.com/s/xHfhMqa5Nsw_5i6MkK2X0A)
[从 React Hooks 看 React 的本质](https://mp.weixin.qq.com/s/t0CLAb7CCZY-paEJque1RA)
[React Hooks 的体系设计之四 - 玩坏 ref](https://mp.weixin.qq.com/s/7c6zncb5ZIef9xgaAvt9uw)
[React Hooks 设计思想](https://mp.weixin.qq.com/s/9Uuy5t-TL9cnCWY_GtQpNQ)
[React 18 新特性之 startTransition](https://mp.weixin.qq.com/s/JAFdq0BBu4rVAoPAdKWe8A)
[React Conf 2021 为 React 18 带来了哪些新东西？](https://mp.weixin.qq.com/s/tKxM2YcNk2K5Ot1nCbqoeg)
[探索 React 的内在 — Fiber & Algebraic Effects](https://mp.weixin.qq.com/s/7MQp1CrZFwNd4dQ3y2C-UA)
[探索 React 的内在 - postMessage 和 Scheduler](https://mp.weixin.qq.com/s/x4HvKm6w_nc02CZcOiwTTA)
[深入源码剖析componentWillXXX为什么UNSAFE](https://mp.weixin.qq.com/s/aL5NHz3Jq4KZT_m5rIbx3A)

[前端架构 101：在谈论它们之前我们需要达成的共识](https://mp.weixin.qq.com/s/iupP8wiJzUjJJ2cqSDDFLQ)
[前端架构 101：MVC启示录 - 模块的职责，作用域和通信](https://mp.weixin.qq.com/s/w24UUSl_kosclM_ct8Hk3w)
[前端架构 101：MVC 初探](https://mp.weixin.qq.com/s/8ILlKiZIGCqqVoKhH4VDtA)
[前端架构 101：MVC 的不足与 Flux 的崛起](https://mp.weixin.qq.com/s/BB1VUmtQ5uBJ7VSnRf11ZQ)
[前端架构 101：从 Flux 进化到 Model-View-Presenter](https://mp.weixin.qq.com/s/jB3POItNJ-MjI_Ubeu_Dfw)
[前端架构 101：整洁（Clean Architecture）架构是归宿](https://mp.weixin.qq.com/s/n9myHRtXleOY2MKZWhN8Eg)

[前端架构鉴赏01：Angular 架构模式与最佳实践](https://mp.weixin.qq.com/s/gz98PLI4ne1-AAa-MMC6aw)
[前端架构鉴赏02：可拓展 Angular 2 架构](https://mp.weixin.qq.com/s/4bd-xkyus-tNuylTBm_tGw)
[前端架构鉴赏03：Angular 与 MVP 模式](https://mp.weixin.qq.com/s/7uYxFxbvcZS4wjbWPVmGpg)

~~[连0.2这么简单的数字都搞不定！你被炒了！](https://mp.weixin.qq.com/s/Cd4uRslnek8r_a6chjwnYQ)~~
[图解 | 你管这破玩意叫计算机？](https://mp.weixin.qq.com/s/prJ767KGkhw3cc53BniNJg)
[图解 | 你管这破玩意叫动态规划](https://mp.weixin.qq.com/s/JIQKOxKsFa0I3HyQvOT5Jw)
[图解 | 你管这破玩意叫文件系统？](https://mp.weixin.qq.com/s/GcIZRk2kWrpKx7Ti3KqDHQ)
[图解 | 你管这破玩意叫 class？](https://mp.weixin.qq.com/s/-_Y-zFNTrBVQchQxj7TGHA)
[图解线程状态，看完浑身通透](https://mp.weixin.qq.com/s/aG_uBLQevyZEFTOLK-kH9g)
[你管这破玩意叫 IO 多路复用？](https://mp.weixin.qq.com/s/3gC-nUnFGv-eoSBsEdSZuA)
[都是缓存惹的祸](https://mp.weixin.qq.com/s/7PgUa696U5pZFLEcbWHYSA)
[你管这破玩意叫哨兵？](https://mp.weixin.qq.com/s/ijTnqfKvwP7ldYusQGl9tA)
[最多能创建多少个TCP连接？](https://mp.weixin.qq.com/s/mGkf-9LZhhUgSIRBRqfRDw)
[你管这破玩意叫 RDB？](https://mp.weixin.qq.com/s/vsmoOxMXn2nG7OYjJkbb7A)
[你管这破玩意叫 OAuth？](https://mp.weixin.qq.com/s/FnWUwEp2PuOxqnF5URB-WA)
[从上厕所想到的线程池设计原理](https://mp.weixin.qq.com/s/rxaNWAgpt7umtftDk3eKUA)

# 笔记记录

## 工程
多应用如何做到代码共享

chunk 和 module
* module：每个源码 js 文件其实都可以看成一个 module
* chunk：每个打包落地的 js 文件其实都是一个 chunk，每个 chunk 包含很多 module
* 默认的 chunk 数量实际上是由你的入口文件的 js 数量决定的，但是如果你配置动态加载或者提取公共包的话，也会生成新的 chunk

webpack5 的 Module federation：允许运行时动态决定代码的引入和加载。先看下简单配置
```js
{
    plugins: [
        new ModuleFederationPlugin({
            name: 'app1',
            library: {
                type: 'var',
                name: 'app1',
            },
            remotes: {
                app2: 'app2',
            },
            shared: ['react', 'react-dom']
        })
    ]
}
```

你需要了解的是
* remotes 的代码自己不打包，类似 external
* shared 的代码自己是有打包的

## Git
Git object 类型
* blob 类型：存储文件内容，不包括文件名等其他信息
* tree 类型：当前目录结构打了一个快照
* commit 类型：存储一个提交的信息，包括对应目录结构的快照 tree 的哈希值、上一个提交的哈希值、提交的作者以、提交时间和提交信息
* tag 类型：在添加含附注的 tag 时会新建

非常不错的 Git 图解资料：[CS Visualized: Useful Git Commands](https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1)，加深了我对一些命令的理解，比如
* git merge 的两种合并策略
  * fast-forward
  * no-fast-forward
* git rebase
  * 为什么 git rebase 提交历史会很清爽
* 交互式变基
  * reword 修改提交信息
  * edit 修改此提交
  * squash 将当前提交合并到之前的提交中
  * fixup 将当前提交合并到之前的提交中，不保留提交日志信息
  * exec 在每一个需要变基的提交上执行一条命令
  * drop 删除提交
* git revert 用于还原某次提交的修改，会创建一个包含已还原更改的新提交记录

## 微前端
实现微前端的常见方式
* 路由分发：比较传统的方式，你可以通过 HTTP 服务器的反向代理来实现
* 前端微服务化：通过模块化的方式组合出完整的应用，比较典型的实现：single-spa
* 微应用：开发时以微小应用的方式存在，运行时，通过构建合并这些应用
* 微件化：一段直接嵌入应用上运行的代码，开发人员预先编译好且部署到指定的服务器上
* iframe
* Web Components：允许开发者创建可重用的定制元素

对于微前端的诉求
* 独立开发、独立部署、增量更新、技术栈无关
* 运行时隔离与共享：js 和 css 互相隔离不受影响，同时又有同新机制保证应用之间能够互相通信或数据共享
* 单页面应用的良好体验：不会 reload 整个页面，如同单页般站内路由切换

## React
在早期的 React Router 中，提供了开箱即用的滚动恢复的支持。

浏览器开始处理带有历史记录的滚动恢复。它已经在浏览器中工作的很好。

因为浏览器开始处理默认情况，而应用程序有不同的滚动需求。

比如滚动到顶部
```js
export default function ScrollToTop() {
  const { pathname } = useLocation();

  useEffect(() => {
    window.scrollTo(0, 0);
  }, [pathname]);

  return null;
}

function ScrollToTopOnMount() {
  useEffect(() => {
    window.scrollTo(0, 0);
  }, []);

  return null;
}
```

ScrollRestoration 的工作原理
* 操作 window 对象
* 使用 location.key 进行 window 滚动位置记录到 sessionStorage
* 当 ScrollRestoration 组件挂载时，从 sessionStorage 寻找滚动位置

## 架构
多应用项目开发架构

## 前端质量
质量保证措施
* 需求理解错误
  * 方案评审会议
  * 验收标准制定
* 程序编码错误
  * 静态检查
  * 代码审查
  * 自动化测试
* 罕见特殊状态
  * 大规模 Beta 测试
  * 监控机制
  * 回滚机制

方案设计要点
* 流程图
* 组件/类图
* 时序图
* 外部依赖
* 性能监控
* 功能影响
* 兼容性

静态检查配置
* 语言
  * eslint-plugin-sonarjs
  * @typescript-eslint/parser
  * eslint-config-airbnb-typescript
* 框架
  * eslint-plugin-react
  * eslint-plugin-react-hooks
  * eslint-plugin-jest
* 安全
  * eslint-plugin-security
* 无障碍
  * eslint-plugin-jsx-a11y
* 自定义
  * eslint-plugin-local-rules

监控机制
* 异常监控 - sentry.io
* 性能监控
* 安全监控 -checkmarx
* BUG 反馈系统

回滚机制
* 基于 LaunchDarkly 实验性功能开关控制
* 基于 Lambda@Edge 的整体回滚方案

团队成长
* 快速试错
  * 早期成本低
  * 快速成长
* 定期回顾
  * 流程回顾：有何问题？如何改进？
  * BUG 回顾：根源是啥？如何避免？

React 性能监控
* 配置 Profile - 开启组件更新高亮
* 配置 Profile - 开启组件渲染原因记录

单元测试实践
* 在日常开发中践行 TDD，把需求点转换为测试点，先测试后开发。
* 大粒度结合小粒度，大粒度测功能，小粒度测独立模块，大粒度测主干，小粒度测特殊情况。
* 可复用模块进行独立的小粒度测试
* 大粒度测试与 QA 的测试点对应：Given... When... Should...
* 避免直接测试私有方法/属性，因为它通常是非常不稳定的
* 减少重复代码
  * 善用 describe/beforeEach/beforeAll
  * 提取变量，创建工具方法，setUp/functions/mock utils

## 代码整洁
变量命名
* ……
* 避免使用智能统一词，统一团队用语
* 避免不必要的上下文：主要用在类或者包中变量名的定义上
* 避免使用魔法数字和魔法字符串：使用一个有语义的常量存储

关于函数
* 参数入参不易过多，在我看来 3 个已经是上限了，过多时考虑是否可以组合成一个对象
* 避免副作用
  * 全局变量
  * 对象变异
* 只做一件事
* 更多的使用函数式编程，而不是命令式

复杂判断
* 不要使用标记（flag）作为函数参数，会破坏函数功能的单一性。推荐创建两个函数实现各自对应的逻辑功能
* 封装判断条件，将条件封装在具有明确语义的函数或变量中，可以更直观的理解代码逻辑
* 使用卫语句：开发中不应该有嵌套的条件语句存在，卫语句是我们避免嵌套条件的主要技术之一，本质上就是提前结束
* 空对象模式：通过返回空串、空数组、甚至自定义的空对象行为的对象，来减少不需要的判断
* 通过多态删除条件判断
* 使用策略模式/命令模式移除条件

关于异常处理
* 优选选择异常，而不是错误码：如果语言本身有错误处理机制的前提
* 不要忘记捕获异常：进行错误上报和提示
* 不要忽略 promise reject 的情况
* 异常等级

## 基础

### 关于锁
* 原子操作：指不会被线程调度打断的操作，操作一旦开始，就会一直运行到结束，中间不会有上下文切换。数据库事务中的 ACID 中的 A 指的就是原子性。
* 原子操作可以分为软件层面和硬件层面，硬件层面的原子操作又分为单核 CPU 和多核 CPU，单核 CPU 中，能够在一个指令中完成的操作都可以看做原子操作，因为中断只发生在指令切换中。多核 CPU 情况下，runtime 运行着多个独立 CPU，即使单个指令的操作，也可能被干扰。原子操作在硬件层面有所实现，比如 x86 架构下，CPU 提供了 HLOCK pin 引线，允许 CPU 在执行某个指令时拉低 HLOCK pin 引线的电位，直到指令执行完毕才放开。锁住了总线其他核就无法继续执行指令，此时就可以保证多核处理器的原子性
* CAS 用来保证加锁过程中的原子性，会比较地址指针是否为 old，为 old 说明操作期间没有被打断，就地址值替换为 new，返回 true,不为 old, 代表操作期间被其他线程打断了，返回 false。

### 关于浮点数
计算机的本质决定了它是一个二进制的世界，人类熟悉的十进制数字需要转行成二进制才能被计算机处理。但是这个转化的过程却会遇到问题。从漫画中可以看出十进制整数都能精确地转化为二进制表示，但是十进制小数却并不一定。

对于工程计算和科学计算，一个非常近似的二进制小数是可以满足要求的，但是在商业计算尤其是金融领域，必须要精确地表示，精确地计算，这个时候就不能直接使用 float，double 等类型了，需要用一个工具类如 BigDecimal 来进行处理。

拼凑法进行转换
* 整数部分和小数部分，各自对应者一个工具箱，分别存储着 2^n 和 2^-n 方对应的二进制值。当十进制数进来时，查表看有没有，没有则查找最近的，然后不断进行拼凑
* 对于十进制整数，只要能表示层 2^n 次方的和，就能拼凑出来。十进制小数只要能表示成 2^-n 的和，也能拼凑，但有不少十进制小数不满足这个性质
* 解决不精准问题：把小数转换成整数，记录下小数点后面有几位小数，然后通过整数进行运算。这就是 BigDecimal 的原理

对于浮点数的存储制定了规范，比如 IEEE 754
* 定点数方案：比如针对 32 位的存储，首位（符号为）+ 8 位整数位 + 23 位小数位，小数点固定在了具体的位置，因此称为定点数。但对于整数部分和小数部分位数的分配是个问题，整数部分大，能表示的范围大，小数部分大，那数据就更精确。所以很难选择，不是完美的解决方案
* 科学记数法：368.79 表示为 3.6879 * 10^2
* 浮点数就是利用指数达到小数点浮动的效果，从而灵活的表达更大范围内的数。不过对于同一个浮点数，也有很多表达方式，取决于你的指数取多大，由于其多样性，因此我们需要特定的标准
* IEEE 754 标准，有单精度（32）和双精度（64）
  * 科学表示为：(+ or - ) 1.(mantissa) * 2 ^ exponent，比如 5.8 表示成 1.45 * 2 ^ 2
  * 针对 5.8：符号为 s = 0；指数部分需要注意，指数也有正负之分，既要用 8 为表示正数，又要能表示负数，因此分开使用 0-127 表示负数，128-255 表示正数。127 被称为偏置值。所以 exponent = 127 + 2 = 129。尾数 mantissa 是 0.45，需要转化成二进制，不断的乘 2，去结果的整数部分就行，有时候这一部会出现无限循环，这时候取到要求的 23 位就行，可见浮点数是不精确的

## CSS
[奇妙的 CSS MASK](https://mp.weixin.qq.com/s/XMiEBQT9MpV9pJyAWsb0qQ)，虽然兼容性不是很好，但真的很有趣。

有趣的 Tailwind CSS，自动根据规则生成使用的 CSS 样式

CSS 的层叠分为两部分
* 样式层叠
* 具体概念的层叠
  * 文档流
  * 格式上下文
  * 层叠上下文
  * 层叠顺序

CSS contain 属性
* 允许开发者声明当前元素和它的内容尽可能独立 DOM 树的其他部分，这使得浏览器在重新计算时，只影响到有限的 DOM 区域，而不是整个页面，有效的改善性能
* 主要目的是隔离指定内容的样式、布局和渲染，它能建立起一个边界，产生一个新的根布局，保证它和它的子元素的 DOM 变化不会触发父元素重新布局、渲染等
* 为什么浏览器不自动实现 contain 功能：浏览器已经尽可能做了优化，但每个浏览器的实现方式不尽相同，contain 提供一种标准的方式告诉浏览器，那些可以优化，哪些不能优化

CSS 使用 CSS 提高页面的渲染速度
* 新增特性 content-visibility：用于跳过屏幕外的内容渲染，可以接受 visible、auto、hidden 属性
  * 如果浏览器不渲染页面内的一些元素，滚动将是一场噩梦，因为无法正确计算页面高度。content-visibility 会将分配给它的元素的高度（height）视为 0，浏览器在渲染之前会将这个元素的高度变为 0，从而使我们的页面高度和滚动变得混乱。但如果已经为元素或其子元素显式设置了高度，那这种行为就会被覆盖。
  * 如果你的元素中没显式设置高度，并且因为显式设置 height 可能会带来一定的副作用而没设置，那么我们可以使用 contain-intrinsic-size 来确保元素的正确渲染，同时也保留延迟渲染的好处。
  * content-visibility 提供的另外两个值 visible 和 hidden 可以让我们实现像元素的显式和隐藏，类似于 display 的 none 和非 none 值的切换，在这种情况下，content-visibility 可以提高频繁显示或隐藏的元素的渲染性能，例如模态框的显示和隐藏。content-visibility 可以提供这种性能提升
* 新增特性 contain：控制页面的重绘与重排
  * layout ：该值表示元素的内部布局不受外部的任何影响，同时该元素以及其内容也不会影响以上级
  * paint ：该值表示元素的子级不能在该元素的范围外显示，该元素不会有任何内容溢出（或者即使溢出了，也不会被显示）
  * size ：该值表示元素盒子的大小是独立于其内容，也就是说在计算该元素盒子大小的时候是会忽略其子元素
  * content ：该值是contain: layout paint的简写
  * strict ：该值是contain: layout paint size的简写
* 合理使用 will-change：该属性可以表明元素将修改特定的属性，让浏览器事先进行必要的优化
  * 如果你的页面在性能方面没什么问题，则不要添加 will-change 属性来榨取一丁点的速度。
  * will-change 的设计初衷是作为最后的优化手段，用来尝试解决现有的性能问题。
* 使用 font-display 解决由于字体造成的布局偏移
* scroll-behavior 让滚动更流畅
* 开启 GPU 渲染动画
* 减少渲染阻止时间：响应式布局拆分样式表，在这种情况下，我们可以只让主 CSS 文件阻塞关键路径，并以高优先级下载它，而让其他样式表以低优先级方式下载。
* 避免 @import 包含多个样式表
  * 关于 @import 的关键事实是，它是一个阻塞调用，因为它必须通过网络请求来获取文件，解析文件，并将其包含在样式表中。如果我们在样式表中嵌套了 @import，就会妨碍渲染性能。
  * 与使用 @import 相比，我们可以通过多个 link 来实现同样的功能，但性能要好得多，因为它允许我们并行加载样式表。
* 注意动态修改自定义属性方式
  * CSS 自定义属性又名 CSS 变量，该特性已经是非常成熟的特性了，可以在 Web 的开发中大胆的使用该特性
  * 在使用 CSS 自定义属性时，时常在 root（根元素）上注册自定义属性，这种方式注册的自定义属性是个全局的自定义属性（全局变量），可以被所有嵌套的子元素继承
  * 可以使用 style.setProperty 来重新设置已注册好的自定义属性的值。但在修改根自定义属性时，需要注意，因为它会影响 Web 的性能

## 趋势
通过项目分布的情况，明显能看到 React 生态圈>> Vue 生态圈>> Angular 生态圈；

WebAssembly 核心规范成为浏览器的标准。

在多端复用模块代码中，以 TS+ Jest 为基本要求，保证公共代码的可维护性和可测试性：在 TS 编写中，我们更多地遵循面向对象设计原则（SOLID 原则、KISS 原则等），适当的运用设计模式，帮助更好地进行代码开发和维护。同时，在 TS 践行中，辅以单元测试覆盖，可以指导我们更好地拆分组织代码，编写可测试的模块，在公共核心业务模块中覆盖单测用例。

区分一下 no-code、low-code、pro-code
* no-code：自己编程给自己用，给用户的感觉就是一个软件。因此，平台不会给自己定位成一个“编程工具”。主要是通过图形化的操作来降低学习曲线，类似PPT、Excel等。在垂直领域的特定场景中，才能做到好用。
* low-code：编程给其他人用，通过降低专业难度，让运营人员（CitizenDeveloper）也参与进来。平台评估好预制的场景和需求，减少从头写代码的成本，一定程度上可以通过图形化的方式满足业务诉求。
* pro-code：日常软件开发过程中的手写代码，可以通过逻辑和模块复用来进行提效。

## 2021 前端技术发展
来源于一份榜单总结：[2021年JavaScript明星项目](https://mp.weixin.qq.com/s/f4Vo0WliR_ASGtwmxUeOQw)

值得把玩一下 google 出品的 zx，用 javascript 编写命令行脚本
* 你可以使用 bash 表达式，也可以使用 javascript 语法
* 包含几个流行包提供的使用工具
  * node-fetch 在浏览器中使用相同的 API 进行 HTTP 请求
  * fs-extra 来处理文件系统操作
  * globby 匹配给定用户友好模式的文件名

值得期待的 vite 就不多说啦。

我尝试给你介绍一下 next.js 是什么哈
* 创建完备的 React 项目，免于繁琐配置，类似 cra
* 基于约定而非代码的方式，封装了一下路由系统，应该是内化了 react-router
* 预渲染，也就是编译期间生成 html 代码，可以用于生成静态站点，比如解析 markdown，生成静态站点，类似 gatsby
* 服务端渲染，用于优化首屏加载与 SEO
* 可以用来写后端 api，类似 koa.js

主要的 UI 框架都有自己的"元框架"来构建现代和可扩展的应用程序，提供诸如路由、服务器端渲染、页面的静态生成、为生产优化构建等功能。
* React 有 Next.js
* Vue 有 Nuxt.js
* Svelte 有 SvelteKit

构建工具
* vite
* esbuild - go
* swc - rust
* lerna：仍然被广泛使用，但没有得到很好的维护
* nx：monorepo 工具，它可以大大缩短构建时间。**这个值得关注**

React 18 即将到来的新特性
* 自动批处理
* SSR 对于 Suspense 支持
* 并发模式

静态网站
* Next.js 嘿嘿，你又出现了
* Docusaurus
* Nuxt.js
* Gatsby

状态管理
* 我只能说 React 状态管理是真的多：Zustand/XState/Jotai/Recoil/Redux/Valtio/Mobox
* Vue 就正常很多：Pinia/Vuex

## 深入了解现代浏览器
了解一些计算机部件以及它们的作用。
* CPU：Central Processing Unit，可以用来处理各种各样的工作
* GPU：Graphics Processing Unit，不同于 CPU，CPU 擅长处理简单的任务，但同时跨越多个核
* Process and Thread
  * Process 进程：可以理解为一个正在执行的程序
  * Thread 线程：驻留在进程内部，执行其进程程序的任何部分
  * 程序启动时，进程就被创建了，进程可能创建线程帮助它工作，但这是可选的。操作系统为进程分配一块内存，所有的应用状态都保存在这块私有内存中，当您关闭应用程序时，该进程也会消失，操作系统也会释放内存

浏览器架构
* Web 浏览器是如何使用进程和线程构建的呢？可能是一个进程有很多不同的线程，也可能是很多不同的进程有几个线程通过 IPC 通信。
* Chrome 浏览器
  * Renderer Process：为每个选项卡创建一个渲染进程，这样的好处一个一个选项卡挂了，不会影响其他的。另一个好处就是安全和沙盒。由于每个进程有自己的私有内存空间，对于公共基础设施就会有多份拷贝，比如 V8，这意味着需要更多的内存，为了节省内存，Chrome 限制了它可以创建的进程数，这个限制取决于你设备的内存和 CPU 能力，当超过限制时，Chrome 会开始将多个选型卡运行在一个进程中。同样为了安全考虑，站点隔离是 Chrome 中最近引入的一个功能，它为每个跨站点的 iframe 运行一个单独的渲染进程
  * Browser Process
  * Utility Process
  * GPU Process
  * Plugin Process

> 你可以通过打开菜单 => 更多工具 => 任务管理器，查看当前进程列表，已经 CPU 和内存使用情况

一次简单的导航，浏览器是怎么处理的呢
* 处理输入：浏览器进程判断这是一个进程还是 URL
* 开始导航：用户回车时，UI 线程初始化一个网络请求，在 Tab 上显示 spinner，网络线程通过适当的协议，如 DNS 查找和建立 TLS 连接。如果收到重定向结果，则一个新的 URL 请求会被初始化
* 读取响应：当响应回来后，网络线程在必要时查看流的前几个字节，Content-Type 头会告诉 data 的数据类型，它可能丢失或错误。如果响应是 HTML 文件，将会把数据传给 Renderer Process，如果是 zip 或其他格式文件，意味着这是一个下载请求，需要将需求传给下载管理器。这也是安全检查发生的地方，如果域和响应数据似乎与已知的恶意站点相匹配，则网络线程发出警报，以显示警告页面。此外，为了确保敏感的跨站点数据不会进入渲染过程，还进行了跨源读取阻塞(CORB)检查。
* 找到一个渲染器进程：所有的检查完成时，网络线程确信浏览器应该导航到所请求的站点，网络线程告诉UI线程数据已经准备好了。UI 线程然后找到一个渲染进程进行渲染的网页。
* 提交导航：现在数据和渲染进程都准备好了，浏览器进程向渲染进程发送 IPC 以提交导航。当浏览器进程收到渲染进程中发生了提交的确认，导航就完成了，文档加载阶段就开始了。
* 加载完成：渲染进程加载资源、渲染页面，当完成渲染时（所有的 onload 事件都触发且完成了执行），发送一个 IPC 给浏览器进程，这时候 UI 线程关闭 Tab 上的 spinner
* 导航到其他站点：浏览器进程会再次执行之前的步骤，在这之前，它会检查当前的站点是否关心 beforeunload 事件

关于 Service worker
* Service worker 是一种在应用程序代码中编写网络代理的方法；允许 web 开发人员对本地缓存的内容和何时从网络获取新数据有更多的控制。如果 service worker 设置为从缓存中加载页面，则不需要从网络请求数据。
* Service worker 是 JavaScript 代码，运行在渲染进程中，那么当导航请求来时，浏览器进程如何知道站点有 Service worker 呢
* 当 Service worker 被注册时，Service worker 的范围保存称为i一个引用，当导航发生时，网络线程根据注册的 service worker 作用域检查域，如果 service worker 已经注册了那个 URL，则 UI 线程找到渲染器进程去执行 service worker 代码

导航预加载
* 如果 service worker 最终决定从网络上请求数据，那么这种浏览器进程和渲染进程的往返会导致延迟。
* navigation preload 是一种机制，通过在 service worker 启动时并行加载资源来加速这个过程，它用一个头标记这些请求，允许服务器决定为这些请求发送不同的内容；例如，只更新了数据而不是完整的文档


渲染进程
* 渲染进程负责 Tab 中所有的一切，主线程处理您发送给用户的大部分代码。如果使用了 web worker 或 service worker，则会交给 worker 线程处理
* 合成和光栅线程也运行在渲染器进程内，以高效和平稳地呈现页面。
* 解析阶段
  * 将 html 字符串解析成 DOM(Document Object Model)
  * 子资源加载：加载 image，css，js 等资源，主线程在解析 html 时，会请求相关的资源，但为了加速，预加载扫描器是并发运行的，如果发现有 img 或 link 标签，预加载扫描器查看 HTML 解析器生成的令牌，并将请求发送到浏览器进程中的网络线程。
  * javascript 会阻止解析：当发现 script 标签时，暂停解析 html 文档并加载，执行 javascript 代码，因为 javascript 可能改变文档的结构
* 资源加载控制：async、defer、`<link rel="preload">`
* 样式计算：主线程解析 CSS 并确定每个 DOM 节点的计算样式。
* 布局：布局是一个找到元素几何形状的过程。主线程遍历 DOM 和计算样式，并创建布局树，其中包含 x y 坐标和边界框大小等信息。布局树的结构可能与 DOM 树相似，但它只包含与页面上可见内容相关的信息。比如 display 为 none 则不在 layout tree 中，但 visibility 为 hidden 是在的。确定页面的布局是一项具有挑战性的任务。
* 绘制
  * 拥有 DOM、样式和布局还不足以呈现一个页面。假设你想要复制一幅画。您知道元素的大小、形状和位置，但您仍然需要判断绘制它们的顺序。
  * 在这个绘制步骤中，主线程遍历布局树以创建绘制记录。绘画记录是绘画过程中“先有背景，再有文本，再有矩形”的一种记录。
  * 在渲染流水线中需要掌握的最重要的一点是，在每一步中，前一个操作的结果都用于创建新数据
  * 即使您的渲染操作与屏幕刷新保持同步，这些计算也是在主线路上运行的，这意味着当您的应用程序运行JavaScript时，这些计算可能会被阻塞。你可以将 JavaScript 操作分割成小块，并使用 requestAnimationFrame() 计划在每一帧运行。或者使用 Web Worker 去避免阻塞主线程
* 合成
  * 将这些信息转化为屏幕上的像素称为光栅化。
  * 合成是一种技术，它将页面的各个部分分割成图层，分别栅格化，然后在称为合成线程的单独线程中合成为一个页面。
  * 如果发生滚动，因为图层已经栅格化，它所要做的就是合成一个新帧
  * 动画也可以通过移动图层和合成新帧来实现。
  * 划分层：为了找出哪些元素需要在哪些层中，主线程遍历布局树以创建层树，如果页面的某些部分应该是单独的层(如滑动侧菜单)，你可以通过 will-change 属性提示浏览器，您可能会想给每个元素都添加图层，但是跨过多的图层组合可能会导致比每帧栅格化页面的一小部分更慢的操作，因此测量应用程序的渲染性能是至关重要的。
  * 一旦 layer tree 和绘制顺序被确定，主线程将该信息提交给组合线程，然后合成线程光栅化每个层，一个层可以像整个页面的长度一样大，因此，合成线程将它们划分为瓦片，并将每个瓦片发送给光栅线程。栅格线程栅格化每个贴图，并将它们存储在 GPU 内存中。合成线程可以对不同的栅格线程进行优先级排序，以便视图内(或附近)的东西可以先进行栅格排序。一旦瓦片光栅化完成，合成线程收集瓦片信息称为绘制四边形，创建一个合成帧。
  * 合成的好处是它不涉及主线程。合成线程不需要等待样式计算或 JavaScript 执行。这就是为什么合成动画被认为是最好的平滑性能。

浏览器看输入事件
* 浏览器进程将事件类型(如touchstart)及其坐标发送给渲染进程。渲染进程通过找到事件目标并运行附加的事件监听器来适当的处理事件。
* 如果页面上没有任何输入事件监听器，那么合成线程完全可以独立于主线程去创建一个新的合成帧。但页面上要是添加了事件监听呢？合成线程是怎么知道事件需要处理的呢？
* 非快速滚动区：运行 JavaScript 代码是主线程的工作，所以在合成页面时，合成线程会将页面上具有事件处理程序的区域标记成“非快速滚动区域”。有了这个标记，合成线程就可以在该区域触发事件的时候将输入事件发送给主线程。如果输入事件不是这个区域的，那么合成线程就不会等待主线程，直接进行新帧的合成。
* 事件代理是 Web 开发中常见的事件处理模式。这是利用了事件冒泡的机制，可以在最顶层的元素上添加事件处理程序，再根据事件目标进行处理。如果从浏览器的角度来看这段代码，整个页面都被标记成了非快速滚动区域。这也意味着，即使事件发生在你并不关注的区域里，合成线程也要去和主线程沟通，并等待回应。这样合成线程平滑滚动的优势就没有了。
* 为了减轻这种情况的发生，你可以在事件监听里传递 passive: true。这表示你希望浏览器还是主线程来处理这个事件，并且合成线程同时可以继续合成新的帧。
* 寻找事件目标：合成线程把事件发送给主线程以后，要做的第一件事情就是命中测试找到事件目标。命中测试就是使用渲染过程中产生的绘制记录来找出事件发生的点坐标下的元素。
* 为了把对主线程的调用降到最低，Chrome 会合并连续触发的事件，比如 wheel、mousewheel、mousemove、pointermove、touchmove，并将它们延迟到下一次 requestAnimationFrame 之前发送。而所有的独立事件，比如 keydown, keyup, mouseup, mousedown, touchstart 以及 touchend 会立即发往主线程。
* 合并事件在大部分情况下是可以保证很好的用户体验的，但是，在一些特殊场景下，比如你要开发的是一个绘图类的应用，就需要基于 touchmove 事件的坐标进行绘制，这时候合并事件就可能把区间内的坐标点丢失掉。这时候，你就可以使用目标事件的 getCoalescedEvents 来获取事件合并后的信息。

优化 JavaScript 的执行
* 对于动画效果的实现，避免使用 setTimeout 或 setInterval，请使用 requestAnimationFrame。
* 将长时间运行的 JavaScript 从主线程移到 Web Worker。
  * 妥善处理 JavaScript 何时运行以及运行多久。例如，如果在滚动之类的动画中，最好是想办法使 JavaScript 保持在 3-4 毫秒的范围内。超过此范围，就可能要占用太多时间。如果在空闲期间，则可以不必那么斤斤计较所占的时间。
  * 在许多情况下，可以将纯计算工作移到 Web Worker
* 使用微任务来执行对多个帧的 DOM 更改。
* 使用 Chrome DevTools 的 Timeline 和 JavaScript 分析器来评估 JavaScript 的影响。

微任务简单示例
```js
var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);
requestAnimationFrame(processTaskList);

function processTaskList(taskStartTime) {
  var taskFinishTime;

  do {
    // Assume the next task is pushed onto a stack.
    var nextTask = taskList.pop();

    // Process nextTask.
    processTask(nextTask);

    // Go again if there’s enough time to do the next task.
    taskFinishTime = window.performance.now();
  } while (taskFinishTime - taskStartTime < 3);

  if (taskList.length > 0)
    requestAnimationFrame(processTaskList);

}
```

避免微优化 JavaScript：知道浏览器执行一个函数版本比另一个函数要快 100 倍可能会很酷，比如请求元素的 offsetTop 比计算getBoundingClientRect() 要快，但是，您在每帧调用这类函数的次数几乎总是很少，因此，把重点放在 JavaScript 性能的这个方面通常是白费劲。您一般只能节省零点几毫秒的时间。

坚持仅合成器的属性和管理层计数
* 坚持使用 transform 和 opacity 属性更改来实现动画
* 使用 will-change 或 translateZ 提升移动的元素：提前警示浏览器即将出现更改，根据您打算更改的元素，浏览器可能可以预先安排，如创建合成器层。
* 避免过度使用提升规则；各层都需要内存和管理开销：如无必要，请勿提升元素。

相关资料
* [Inside look at modern web browser (part 1) ](https://developers.google.com/web/updates/2018/09/inside-browser-part1)
* [Inside look at modern web browser (part 2) ](https://developers.google.com/web/updates/2018/09/inside-browser-part2)
* [Inside look at modern web browser (part 3) ](https://developers.google.com/web/updates/2018/09/inside-browser-part3)
* [Inside look at modern web browser (part 4) ](https://developers.google.com/web/updates/2018/09/inside-browser-part4)