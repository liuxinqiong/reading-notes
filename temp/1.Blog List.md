## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

如何判断循环引用
* Set WeakSet
* Map WeakMap

dva dispatch yield 生成器函数异常中断，无法继续调用
* 在生成器函数中，哪怕是一点报错。都会导致程序无法再次执行。这是 yield 的特性导致的
* 解决方式将所有报错回避，并做好错误交互，比如多判断变量合法性或使用 try-catch

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具
* spinner：命令行 loading
* npmlog：log 工具
* semver：版本合法性检查工具

书写模块时，关于模块是否应该依赖外部东西时决策
* 模块的封闭性大于冗余性
* 外部依赖模块内部的某些东西：模块暴露多少 API
* 如果必须要依赖，模块内部对外部依赖封装 wrapper

withCredentials 的作用
* 如果遵循同源策略，该属性不会造成任何影响，**永远不会影响到同源请求**
* 要使得该字段生效，服务端必须设置 Access-Control-Allow-Credentials 为 true
* 目的：跨域请求时，cookie 和认证的 HTTP 头信息是否会包含在请求当中，默认为 false，不仅会发送 cookie，还会设置远程主机指定的 Cookie

how to use webworker in cra：workerize-loader

k8s/jenkins/docker/heml

## React 17/18
React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 对于 SSR 非常友好
* 自动批量更新
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的 UI 更新。
  * 紧急更新：比如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹
* SuspenseList
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* useDeferredValue
  * defer 推迟

React 18 新特性
* automatic batching
* transition
* suspense
* hooks
  * useId
  * useTransition
  * useDeferredValue
  * useSyncExternalStore
  * useInsertionEffect

函数式组件与类组件有何不同
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

重点：**时间切片、Suspense、并发模式（Concurrent）**

Vue Hook 不同之处
* 对调用顺序没有要求，由于渲染机制的不同，不会反复调用 Hook 函数，产生的的 GC 压力较小。
* 不用总是考虑 useCallback 的问题，因为模板解析内部会新建 cache 缓存函数，缓存函数内部进行函数调用，因此写内联函数也没关系
* 没有闭包问题，Vue 内部自动依赖关系跟踪确保观察者和计算值始终正确无误

渲染性能优化上的不同
* Vue 抛弃 time slice，模板中区分动态节点和静态节点。事件监听缓存，从而避免不必要子组件更新。运行时特性支持 tree-shaking，没用到的特性代码会被移除
* React 走了另一条道路，既然是 diff 导致问题卡顿，从 CPU 调度的方式解决问题，利用浏览器的空闲时间来做 diff，如果超过了 16ms，有动画或者用户交互的任务，就把主进程控制权还给浏览器，等空闲了继续

## @ausz/editor
为什么要封装 3D 引擎
* 业务相关定制开发周期长
* 熟悉 WebGL 的开发工程师相对较少，培养耗时
* 展示项目相对容易，交互类项目开发相对比较复杂

希望达到的目的
* 场景支持配置化构建
* 降低开发难度

如何实现
* 封装语义化接口
* 引入外部库
* 扩展工具类、增加组件库
* 事件进行抽象和封装

为避免之前的弯路
* 事件机制统一管理，且 typing 完善
* 尽量少用 userData，如果要用，保证类型完全
* 顶部工具栏和特定功能工具状态管理问题：如果功能直接进入，要求不能选取，这时候点选取该如何处理呢
* Object3DFinder 值得好好关注一哈，做了很多 Editor 可直接对外输出的能力以及很多业务能力？？

> 插件化开发？

关于选取，我们应该有两套 api
* 一套直接设置选取对象的 api
* 一套根据鼠标事件交互选取的 api

three 源码阅读计划，从一些简单高阶封装开始
* ~~DragControls~~
* TransformControls
* OrbitControls
* SelectionBox：研究源码实现框选的逻辑

### 选中态研究
Three.js 官方的 BoxSelection 使用的 material.emissive 的方式来添加选择态
* emissive 默认为黑色，表示不发光
* 选中时设置为白色，取消选中时恢复为黑色，但这个不具备普适性

其他选中态方案
* 修改 material 改为修改 material 对应的颜色，然后 original color 存储在 material.userData 中
* 修改外边框的方式实现，使用 outline 后置处理器

outline 处理器会导致如下问题
* 场景变暗
* 抗锯齿失效

相关网站
* three/editor 包围盒
* vectary/tinkercad/autodesk 边框发亮特效

生态中常见实现方案
* OutlinePass
  * 效果很好，可设置边线大小，光晕，边缘浓度，呼吸闪烁等
  * 性能消耗
* EdgeGeometry
  * 效果还行，使用简单
  * 线宽始终为 1，可使用 LineSegments2 实现线宽大于 1
  * 不同于 wireframe 会将每个三角形通过 Line 绘制出来，EdgeGeometry 实现不显示立方体一个面的中间斜线（仅会渲染硬边缘）
* OutlineEffect
* 法线延伸
  * https://github.com/OmarShehata/webgl-outlines
* BoxHelper
  * 性能最好
  * 效果可能不满足设计要求
* Clone Material 进行材质替换和还原

实现物体描边效果
* 法线延展法
  * 当两个面的法线夹角差别较大时，两个面的描边无法完美连接
* 卷积法
  1. 正常绘制场景
  2. 创建着色器材质，隐藏所有不需要描边的物体。将需要描边的物体绘制成白色，其他地方绘制成黑色
  3. 创建着色器材质进行卷积计算，每四个颜色颜色求平均值得到一个像素。描边物体内部是白色，外部是黑色，物体边缘出会得到灰色，灰色就是所需要的边框
  4. 创建着色器材质，将边框叠加到原来的物体上

### 精准移动与绘制捕捉
捕捉支持自定义规则扩展？？？

Snapper 类
* register(geom: StickyGeom, override: boolean): boolean;
  * 更新 RTree
* snap(geom: StickyGeom): Vector2D[] | Vector3D[]

StickyGeom 类
* ref
* coords
  * 端点
  * 中点
* id
* type
* fromPoint(): StickyGeom[]
* fromLine(): StickyGeom[]
* fromPolygon(): StickyGeom[]

RTree 空间探索
* update(sg)
* query(sg)

## 项目工程遗留问题
更优雅的方式处理项目环境变量问题
* 不再新建 environments 文件夹，而是通过内置的 `.env` 文件的方式解决
* 研究下是否支持环境扩展，而不是仅限于 development、test、production 环境，通过 env-cmd 进行扩展
* 注意文件之间优先级

有必要在抽出一个 apps 目录将项目和包分离开吗？比如将项目方式在 src 目录下

## 请求封装
通常在发送请求，要保证正确性和交互和交互的合理性，需要考虑的东西非常的多，比如如下，**优先保证基础功能**
* 各种状态：loading、error、data(这个肯定会考虑到)，尤其是是否加载、是否报错导致我们定义非常多的变量
* 处理异常逻辑，通常我们只关心成功逻辑，而忘记了同样重要的异常逻辑
* 取消请求
  * 手动取消
  * 组件卸载取消：如果不取消通常会导致控制台报错
  * 竞态取消，当上一次请求还没返回时，又发起了下一次请求，则会取消上一次请求。如果不取消可能导致数据不对
* 进阶功能
  * loading delay：有效防止 loading 闪烁，在指定时间之后才把 loading 置为 true
  * 轮询
  * 依赖刷新：依赖发生变化时，自动触发请求
  * 节流与防抖
  * 缓存功能
  * 错误重试

## 产品思考
警惕 A/B 问题，一定要弄清楚组员问题的缘由和根本目的，而不是被带着走。

对应产品的思考也是一样的，一味的从具体细节出发，而忽略了宏观的思考，从而被动接受了产品的解决方案，从而导致引入没有必要的复杂度。

多了很多不是那么顺利成章，不易想到的逻辑，从而不容易写出正确的代码
```js
var condition1 = false;
var condition2 = false;
var condition3 = false;

var visible = condition1 || condition2 || condition3
```

为什么实现一个自动修复到上一次正确值的 InputNumber 组件是一件困难的事情
* 确保输入是数值
* 超过最大最小值的时候拒绝输入？首先任何时候都建议不要做拒绝输入的事情，会导致一个意料之外的事情，比如你可能无法清空输入框重新输入，推荐改为在失去焦点时进行修正
* 超过精度时自动修正？比如精度为 2，输入 12.345 是自动修正为 12.35。同样不建议做影响用户输入的事情，改为在失去焦点时修正
* 额外需求：失焦或回车时，触发 submit 事件，如果值没有发生变化（相比上次提交值），则不触发。如果当前没空值，则恢复到上一个非空值
* 可能存在的问题：组件被复用时，内部存储的上次值就是错的，导致还原时，不满足要求，而且你找不到重置时机。

## 研究专题
研究专题
* 会议目的
  * 同步进度
  * 加强讨论，避免走偏
* 响应式
  * 断点在哪里
  * 采用的媒体查询还是组件替换
  * 深入研究优秀案例分析与实现
  * Grid 布局、px2rem
  * React 相关生态调研与选择
  * 使用原则：CSS 优先
* 权限管理
  * 权限点如何设计
  * 产品角度的场景
    * 个人账号、企业账号
    * 平台管理端、企业管理端
  * 技术角度场景
    * 页面级
    * 组件级
    * 控制结构
  * 代码设计
    * React 如何封装，不够具体，可以进行相关代码演示，具体流程

## 前端研究
产品 ui 上的提示
* 比如断网提示用户，内容会在联网后自动保存到云端
* 保存中… OR 已经保存到云端等相关说明

Checklist
为避免重蹈覆辙，每次产品设计评审时，团队一起走查一遍整个系统的当前状态
* 看数据是不是跑的通
* 会不会和已有功能有状态冲突

加快传输速度：使用 GraphQL 让客户机只从服务器请求所需的数据

数据模型设计
* 有时候会纠结两个模型之间，谁关联谁的问题，此时可以回归到关系型数据库中外键如何设计
* 针对计算属性，是应该单独请求还是作为字段呢？
* 考虑引入空方案的设计，路由 `plan/0`

当前前端开发痛点
- 代码难以拆分，重新思考代码模块的组织问题
- 根组件状态过多，不同功能间状态很难维护对，需要消除功能之间对彼此的影响。
- 修改场景样式（normal/hover/active/error）状态很恶心
- 控制可选对象、可删对象、可编辑对象很恶心
- 前端状态库选择，明确全局状态有哪些
- 正确处理请求各种状态，比如请求竞态、请求取消、**编辑状态下前后端数据同步问题**
- 场景编辑的撤销重做

类设计类型
* Value Object
  * 纯数据结构，常用于底层数据结构
* Entity
  * 领域模型作为语言的扩展
  * 通常属性非常精简，大量使用接口约束其行为，偶尔使用继承封装更特异化领域对象
  * 警惕数据耦合、方法耦合、超级方法簇？？？
* Service
  * 业务逻辑的步骤，常用语模块入口、顶层模块
  * 类名基本上都是以计算过程或者计算者命名，尽可能的精简属性

使用 Router 更好的进行逻辑拆分
* Route 组件类似于 if 语句
  * element 属性默认值是 Outlet，意味着你可以不用显式声明 element
* 路由参数：useParams、useLocation、useSearchParams、useMatch、useNavigate、useOutletContext
  * useMatch 通过给定的路径匹配串和当前的 location 进行解析
  * useLocation 当你需要知道 location 变化时很有用
  * useOutletContext 父路由与子路由分享状态
* 嵌套路由：布局和 URL 片段耦合，Outlet 承载子组件的渲染
  * Outlet 可以放在任意地方，以适应你的布局
* 默认子路由、空路由
* 支持使用多个 Routes 组件，且支持嵌套
* 路由鉴权：AuthContext、AuthProvider、useAuth、RequireAuth 组件
  * AuthContext 验证信息的上下文（存储当前用户信息、登录、登出方法）
  * useAuth 和 AuthProvider 是 AuthContext 的封装
  * RequireAuth：未登录则跳转到登录页，或者正常渲染
* Modal 路由
* 进行代码设计时思考几个选型
  * 平级路由 OR 嵌套路由
  * 路由参数 OR 查询参数
  * 父子路由状态共享
* 可缺省路由设计
  * v6 版本移除了正则匹配规则，因此你可以通过定义多个 Route 解决

Router 核心概念
* Location State：未编码在 URL 中，而是无形地储存在浏览器的内存中。
  * 告诉下一页用户来自哪里，并分发 UI
  * 将列表中的部分记录发送到下一个屏幕，以便它可以立即呈现部分数据，然后在之后获取其余数据。
  * 可使用 useLocation().state 得到数据
* Nested Routes
* Relative links：不是使用 `/` 开头的路径表示相对路径，将会继承最近的路由
* Layout Route：布局路由，没有路径的父路由，专门用于在特定布局中分组子路由。用于减少重复的布局组件

路由设计实例
```jsx
<Routes>
  <Route path="/" element={<App />}>
    <Route index element={<Home />} />
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Routes path=":teamId/edit" element={<EditTeam />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
  </Route>
</Routes>
```

使用 React 实践
* 当组件状态和自定义 hooks 过多时，通过高阶函数创建组件控制器
* 只要有可能，就把组件分成更小的块。通常适用于使用条件呈现等情况
* 不要直接使用第三方库，而是在一个集中的地方重新导出它们
* 推荐声明性编程，而不是过程式

通过高阶函数创建组件控制器
```tsx
import { FC, createElement } from 'react';

export const wrap = <Props extends object, ViewProps extends object>(
  View: FC<Partial<ViewProps>>,
  controllers: Array<(props: Props) => Partial<ViewProps> | null | void>
) => (args: Props) =>
  createElement(
    View,
    ...controllers
      .map((useController) => useController(args) as Partial<ViewProps> | null)
      .filter(Boolean)
  );
```

通过嵌套路由，几乎可以消除所有加载状态
* 我们通常做的是在组件挂载时抓取数据（当数据第一次需要时）。这不是很好，因为它将导致在初始抓取期间用户可见的加载器
* remix 可以在用户单击链接之前并行预取所有内容

状态库选择
* recoil
* jotai：和 recoil 相似，基于原子状态管理，api 更简洁，更好的性能（使用 WeakMap 来跟踪原子。这意味着 JS 引擎会自动处理垃圾收集）
* redux
* rematch：建立在 Redux 核心之上，简化了设置过程，减少了样板文件
* zustand：体积最小的状态管理库
* XState
* Valtio
* Mobox
