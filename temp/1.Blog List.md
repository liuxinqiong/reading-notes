## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

如何判断循环引用
* Set WeakSet
* Map WeakMap

yield 报错后不再进入问题

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具
* spinner：命令行 loading
* npmlog：log 工具
* semver：版本合法性检查工具

书写模块时，关于模块是否应该依赖外部东西时决策
* 模块的封闭性大于冗余性
* 或外部依赖模块内部的某些东西
* 如果必须要依赖，模块内部对外部依赖封装 wrapper

## React 17/18
React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 对于 SSR 非常友好
* 自动批量更新
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的UI更新。
  * 紧急更新：比如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹
* SuspenseList
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* useDeferredValue
  * defer 推迟

函数式组件与类组件有何不通
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

> 时间切片、Suspense、并发模式

## three 源码阅读计划
从一些简单高阶封装开始
* ~~DragControls~~
* OrbitControls
* TransformControls
* SelectionBox：研究源码实现框选的逻辑

## three.js 选中态问题
Three.js 官方的 BoxSelection 使用的 material.emissive 的方式来添加选择态
* emissive 默认为黑色，表示不发光
* 选中时设置为白色，取消选中时恢复为黑色，但这个不具备普适性

其他选中态方案
* 修改 material 改为修改 material 对应的颜色，然后 original color 存储在 material.userData 中
* 修改外边框的方式实现，使用 outline 后置处理器

outline 处理器会导致如下问题
* 场景变暗
* 抗锯齿失效

## three.js 精准移动与绘制捕捉
捕捉支持自定义规则扩展？？？

Snapper 类
* register(geom: StickyGeom, override: boolean): boolean;
  * 更新 RTree
* snap(geom: StickyGeom): Vector2D[] | Vector3D[]

StickyGeom 类
* ref
* coords
  * 端点
  * 中点
* id
* type
* fromPoint(): StickyGeom[]
* fromLine(): StickyGeom[]
* fromPolygon(): StickyGeom[]

RTree 空间探索
* update(sg)
* query(sg)

## 编程语言
使用高级语言编写的业务逻辑，设计模式、函数式、响应式编程，都只是一层层抽象，帮助程序员更好地编写代码，在最底层，还是汇编语言。

从编译角度理解不同语言编程范式：面向对象 => 面向过程 => 汇编。

解释执行语言特点：源码 => parser => AST  => 解释执行。

编译执行语言特点：源码 => 编译&链接 => 机器指令 => 在硬件上直接执行

字节码语言（Java）：编译 + 解释
* 源码 => 编译 => 字节码
* 方式一：在虚拟机上执行
* 方式二：JIT => 机器执行 => 在硬件上直接执行

这种方式结合了解释执行和编译执行的优势，字节码平台中立，任何平台，只要有一个虚拟机就可以执行。

抽象函数的过程中，发现有些函数的参数太长，这时候就需要找个数据结构把参数组织起来，改为传递这个数据结构。程序 = 数据结构 + 算法。

对象 = 数据 + 操作。class 把重复的方法从对象中剥离出来，放到一个公共的 class 中。那函数中如何确定，该操作哪个实例呢，因此 this 也就出来了！解决 class 之间的重复，于是就出现了继承！面向接口编程，从而出现了多态！

继承其实破坏了封装性，因此记住两条准则
* 有效使用组合而不是继承
* 面向接口编程，而不是面向实现编程

随后出现了 23 种通用模式

编程的关键是抽象，你得把系统需求抽象成高层的概念，然后在概念层次进行编程。这句话本身非常抽象！

深入编程设计之前，更重要的是打好基础，多思考，没准哪天就自己悟了

我们可以先好基础，如果你能熟练的使用他们，模式就会自然地呈现出来
* 给方法，类，模块划分好职责
* 做好信息隐藏和封装
* 做好组合

掌握了基础后，可以进一步思考
* 从接口的角度考虑：人们如何使用我的组件
* 让代码易读、简单、可以自我描述，并尽可能避免明确使用模式
* 探索业务的本质模型
