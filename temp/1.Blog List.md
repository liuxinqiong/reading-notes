## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

如何判断循环引用
* Set WeakSet
* Map WeakMap

yield 报错后不再进入问题

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具
* spinner：命令行 loading
* npmlog：log 工具
* semver：版本合法性检查工具

书写模块时，关于模块是否应该依赖外部东西时决策
* 模块的封闭性大于冗余性
* 或外部依赖模块内部的某些东西
* 如果必须要依赖，模块内部对外部依赖封装 wrapper

## React 17/18
React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 对于 SSR 非常友好
* 自动批量更新
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的UI更新。
  * 紧急更新：比如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹
* SuspenseList
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* useDeferredValue
  * defer 推迟

函数式组件与类组件有何不通
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

重点：**时间切片、Suspense、并发模式（Concurrent）**

## three 源码阅读计划
从一些简单高阶封装开始
* ~~DragControls~~
* OrbitControls
* TransformControls
* SelectionBox：研究源码实现框选的逻辑

## three.js 选中态问题
Three.js 官方的 BoxSelection 使用的 material.emissive 的方式来添加选择态
* emissive 默认为黑色，表示不发光
* 选中时设置为白色，取消选中时恢复为黑色，但这个不具备普适性

其他选中态方案
* 修改 material 改为修改 material 对应的颜色，然后 original color 存储在 material.userData 中
* 修改外边框的方式实现，使用 outline 后置处理器

outline 处理器会导致如下问题
* 场景变暗
* 抗锯齿失效

## three.js 精准移动与绘制捕捉
捕捉支持自定义规则扩展？？？

Snapper 类
* register(geom: StickyGeom, override: boolean): boolean;
  * 更新 RTree
* snap(geom: StickyGeom): Vector2D[] | Vector3D[]

StickyGeom 类
* ref
* coords
  * 端点
  * 中点
* id
* type
* fromPoint(): StickyGeom[]
* fromLine(): StickyGeom[]
* fromPolygon(): StickyGeom[]

RTree 空间探索
* update(sg)
* query(sg)

## 编程语言
使用高级语言编写的业务逻辑，设计模式、函数式、响应式编程，都只是一层层抽象，帮助程序员更好地编写代码，在最底层，还是汇编语言。

从编译角度理解不同语言编程范式：面向对象 => 面向过程 => 汇编。

解释执行语言特点：源码 => parser => AST  => 解释执行。

编译执行语言特点：源码 => 编译&链接 => 机器指令 => 在硬件上直接执行

字节码语言（Java）：编译 + 解释
* 源码 => 编译 => 字节码
* 方式一：在虚拟机上执行
* 方式二：JIT => 机器执行 => 在硬件上直接执行

这种方式结合了解释执行和编译执行的优势，字节码平台中立，任何平台，只要有一个虚拟机就可以执行。

抽象函数的过程中，发现有些函数的参数太长，这时候就需要找个数据结构把参数组织起来，改为传递这个数据结构。程序 = 数据结构 + 算法。

对象 = 数据 + 操作。class 把重复的方法从对象中剥离出来，放到一个公共的 class 中。那函数中如何确定，该操作哪个实例呢，因此 this 也就出来了！解决 class 之间的重复，于是就出现了继承！面向接口编程，从而出现了多态！

继承其实破坏了封装性，因此记住两条准则
* 有效使用组合而不是继承
* 面向接口编程，而不是面向实现编程

随后出现了 23 种通用模式

编程的关键是抽象，你得把系统需求抽象成高层的概念，然后在概念层次进行编程。这句话本身非常抽象！

深入编程设计之前，更重要的是打好基础，多思考，没准哪天就自己悟了

我们可以先好基础，如果你能熟练的使用他们，模式就会自然地呈现出来
* 给方法，类，模块划分好职责
* 做好信息隐藏和封装
* 做好组合

掌握了基础后，可以进一步思考
* 从接口的角度考虑：人们如何使用我的组件
* 让代码易读、简单、可以自我描述，并尽可能避免明确使用模式
* 探索业务的本质模型

## React StrictMode
StrictMode 用来突出显示应用程序中潜在问题的工具，不会渲染任何可见的 UI，仅在开发模式运行，不会影响生产构建。

目标：为其后代元素触发额外的检查和警告
* 识别不安全的生命周期
* 关于过时字符串 ref API 的警告
* 关于使用废弃的 findDOMNode 方法的警告
* 检查意外的副作用
* 检查过时的 context API

> antd 目前就有使用 findDOMNode 的警告，翻阅最新的 release 日志，也没有说到解决了这个问题。

解决项目中严格模式所识别出来的问题，会使得在未来的 React 版本中使用 concurrent 渲染变得更容易。

### 关于检测意外的副作用
从概念上讲，React 分两个阶段工作
* 渲染阶段：确定需要进行哪些更改，比如 DOM，此阶段 React 调用 render 生成 DOM 树，然后将结果与上次渲染的结果进行比较。
  * 类组件会执行 constructor、render、shouldComponentUpdate、getDerivedStateFromProps、setState 更新函数（第一个参数）
  * 函数式组件会执行 useState、useMemo、useCallback 钩子
* 提交阶段：发生在 React 应用变化时，对于 DOM 而言，发生在 React 插入，更新及删除 DOM 节点的时候。
  * 类组件会调用 componentDidMount 和 componentDidUpdate 方法
  * 函数式组件会执行 useEffect 钩子

提交阶段通常会很快，但渲染过程可能很慢。因此即将推出的 concurrent 模式 (默认情况下未启用) 将渲染工作分解为多个部分，对任务进行暂停和恢复操作以避免阻塞浏览器。这意味着 React 可以在提交之前多次调用渲染阶段生命周期的方法，或者在不提交的情况下调用它们（由于出现错误或更高优先级的任务使其中断）。

由于渲染阶段的函数可能会被调用多次，所以不要在他们内部编写副作用相关的代码，这很重要，否者可能会导致各种问题的产生，包括内存泄露或出现无效的应用状态。这些问题很难被发现，因为它们具有非确定性。

**不要在渲染结果执行带有副作用的操作**，由于 React 无法感知是否执行了副作用，因此 React 在严格模式下，会故意重复执行渲染阶段的方法，使得我们在开发阶段能更容易发现这类 bug。（并不是所有渲染阶段的生命周期都会被执行）

严格模式并不能自动检测到你的副作用，但它可能帮助你发现它们，使得他们更具确定性，通过故意重复调用以下函数来实现该操作
* 类组件：constructor，render，shouldComponentUpdate、getDerivedStateFromProps 或者 setState 的第一个参数
* 函数组件：函数体、useState，useMemo 或者 useReducer

结论：**在严格模式下，useState、useMemo、useReducer 的第一个参数、Hook 函数体都会被执行两次，不要在这里执行带有副作用的操作**。

> 我的困惑找到了：在 React 17 开始，React 会自动修改 console 的方法，以在对生命周期函数的第二次调用中静默日志，难怪啊，我以为见鬼呢。你可以通过在模块顶部使用 log 记录 console.log，然后通过 log 方法打印日志的方式来避过。

关于这玩意网上的讨论是真的多
* [useRef does not persist value when used with createRoot](https://github.com/facebook/react/issues/17193)

### 一些思考
React 和 OOP 能很好的结合吗
* React 生态倾向于函数式编程：普通的 JS 对象和数组数据，不可变的更新，函数式操作符（map/filter/reduce）
* OOP 原则：模型数据类、继承和变异

关于使用 React 的一些思考
* 关于逻辑与 UI 解耦，以及数据与事件，层层传递问题
  * 情形一：对于某个复杂对象数据，存在很多的逻辑操作，比如增删某个元素，修改列表中某个对象的属性等，如果这些逻辑比较多，都放在组件中的话，就会显示的非常的丑陋，违背了逻辑与 UI 解耦的原则。
  * 如果组件层级比较深，比如超过了 3 层，会存在中间组件很多 props 仅仅是为了透传给更下一层，同样非常的丑陋

Redux/React-Redux/React-Saga 做的都是同一件事，把逻辑从组件中拿出来、以及解决层层传递问题。

同时 reducer 脱离组件后变成单独的逻辑，非常易于测试和扩展，以表达复杂的更新逻辑。

useEffect 依赖项目过多且频繁变化时，状态会变得非常不可控，也推荐使用 useReducer 将 state 更新逻辑移到 effect 之外呢，因为 useReducer 的 dispatch 身份永远是稳定的

如果不使用社区方案，仅使用 Context 和 useReducer 也可以达到同样的目的，只是会缺少一些高级特性，比如 Context 获取到一个新值时，所有消费它的组件都会被更新且必须被渲染，哪怕是只关心其中部分数据的函数组件，会带来潜在的性能问题，而 Redux 内部会帮你解决这个问题。

其实中重要的是组件设计和模块化划分要做好，这样依赖大部分情况，如何组件简单，很好理解，自然不需要引入其他解决方案。
* 让状态尽可能靠近它相关的地方，而不是在最上层的组件。简单来说：**自己能管理好的事情，就自己管理好，如无必要，不必上报**。
* 如果真的要工作在的深层次的树结构中，可以考虑使用 Context API。虽然上下文有点把我们带回到全局变量的时代。不同之处在于，由于API的设计方式，您仍然可以相对容易地静态地找到上下文的源以及任何消费者。
* 使用 Redux 要谨慎，即使要使用，也仅仅是真的需要。什么状态都往 Redux 中放会导致非常多的问题。比如当你在维护任何状态交互时，都会涉及到 reducer、action creator/types 以及 dispatch 调用，导致我们必须打开一堆文件，并在大脑中追溯代码，才能弄明白发生了什么，以及它对代码库其他部分产生了什么样的影响。

关于这个问题，社区的解决方案很多，比如最近发现的 [HookState](https://hookstate.js.org/)，就非常有意思。简单介绍如下
* State 类型
  * 全局 State：放在组件外通过 createState 创建的就是全局 State，组件内部通过 useState 即可使用
  * 本地 State：组件内直接使用 useState 即可
* State 不再是普通对象，而是具备 get/set 方法的对象
  * 意味着渲染值需要调用 get 获取值
  * 最有意思的 set 方法，将 state 向下传递时，以为你修改值，直接下层组件调用 set 即可，不在需要使用 event up 的方式了
  * 不仅仅是顶层 state 有 get/set，嵌套对象属性同样有，比如 state.name.set 同样是 OK 的
  * 高阶扩展：merge、keys、value
* 对于异步的支持：State 值可以是一个 Promise

为什么使用 Props Down
* 如果你使用过基于全局变量的设计，比如 AngularJS 的 `$scope`、`rootScope`、甚至基于单例的 Service 机制，社区拒绝该方案的原因是，它不可避免地会导致应用程序的数据模型非常混乱。任何人都很难找到数据在哪里初始化、在哪里更新和在哪里使用。比如你很难回答：我可以修改或删除这个代码吗？
* 基于 Props Down 的方式，简单的在整个应用中传递值，你可以简单的通过静态分析追踪到所有使用它的地方

通常使用 Context，建立简单的封装成一下对于 useContext 和 Provider 的使用，而不是直接暴露出去 Context 对象，这样会具有语义一些。比如
```js
function CountProvider(props) {
  const [state, dispatch] = useReducer(countReducer, {count: 0})
  // 推荐 memo 一下，减少不必要的更新
  const value = useMemo(() => [state, dispatch], [state])
  return <CountContext.Provider value={value} {...props} />
}
function useCount() {
  const context = useContext(CountContext)
  if (!context) {
    throw new Error(`useCount must be used within a CountProvider`)
  }
  const [state, dispatch] = context;
  const increment = () => dispatch({type: 'INCREMENT'})
  return {
    state,
    dispatch,
    increment,
  }
}
```

使用 Context 需要注意的点
* 不是应用中所有的状态都需要放在同一个状态对象中，保持它们从逻辑上分离。比如用户的设置不需要和提示信息放在一个 context 里，你可以创建多个 providers
* 不是所有的 context 都需要被全局访问，尽可能地把状态和需要它的地方放的近一些

了解一下 React Query 被强推。

### Recoil
了解到一个状态管理新工具 Recoil，目前还是实验性阶段。

其提供的 api 非常的简单，这让我很欢喜
* atom：用于存储状态，可更新、可订阅，多个组件使用相同的 atom 时，则共享状态
* useRecoilState：组件通过该 api 订阅 atom，用于读取和写入值
* selector：纯函数，入参为 atom 和 selector，当上有更新时，重新执行 selector，类似 memo，避免冗余 state
* 支持异步查询
* ……


React 哲学
* 组合、单向数据流、显示变异
* 根据单一功能原则判定组件的范围
* 保持 state 最小完整表示
  * 你可能不需要派生 state
  * 不会被更改的值、不会被模板渲染的值，不应该作为 state
  * 所有能够通过 state 或 props 计算而来的值，不应该作为 state
* state 位置：尽量在最小范围内自我管理

#### 关于派生 state
关于派生 state 让我联想起当初实现一个特定场景的 NumberInput 的噩梦，大致需求如下
* 显示服务端的数据值
* 子组件值更新时，需要做一些自动修正，比如超过最大最小值时拒绝输入、超过精度时自动修正，触发 change 事件
* 失焦或者回车时，触发提交 submit 事件，内部会存储上次提交值，如果和当前值相同，则不触发。如果当前是空值，则恢复到上一个非空值（内部存储），其他情况直接触发

版本迭代之路
* 受控组件，内部存储上次提交值和上次非空值。如果组件被复用了，也就是说数据源从 A 切换到 B，这时候组件内部的值上次提交值和上次非空值就是错的，用于还原时就是错的，而且我还找不到重置时机。想到最简单的方式就是组件使用是添加唯一 key，避免被复用，这时候组件直接销毁重建，也就不存在脏状态了。更恶心的是，由于会拒绝超过最大最小值的输入，会导致无法输入的情况，比如最小值是 5，我想输入 30，一开始数字 3 就输入不了，因为小于 5
* 改成非控组件，内部维护一个 innerValue 值，父组件使用时传入整个数据源 A，而不只是 value 值，内部监听 A，如果发生变化，则重置相关状态。与此同时 innerValue 可以显示任何值，包括非法状态，但只有在合法时，才会触发 change 事件

整个写下来就非常的恶心，非常的不放心，总觉得会存在各种问题。

大部分使用派生 state 导致的问题的场景
* 直接复制 props 到 state 上
* 如果 props 和 state 不一致就更新 state

定义组件是受控还是非受控：常用来指表单的输入，也可以用来描述数据频繁更新的组件。用 props 传入数据的话，被认为受控。数据只保存在组件内部的 state，则认为是非受控组件。

反面模式
* 直接复制 prop 到 state，这很容易发现问题，因为父组件已更新，内部 state 就被 prop 修改了，明显不符合预期，就不啰嗦了了
* 在 props 变化后修改 state，这种情况问题就比较难以发现，且很容易犯这样的错

我们很容易写出这样的代码，组件内部创建 state，初始值来源于 prop，且在 prop 更新时，重新设置 state 值，但组件内部会操作这个 state，看上去逻辑还挺严谨的，但如果组件被复用了，本身是给数据源 A 用，切换到 B 了，但 A、B 对应的值是一样的，这样依赖组件内部的 state 就被复用了，但很多时候这都是不合适的。解决的办法是：任何数据，都要保证只有一个数据来源。像这个好像来源 prop，有好像来源 state 的操作就很容易出现问题。

建议的模式
* 完全可控的组件：子组件删除 state，直接使用 props。如果仍然想要保存临时的值，则需要父组件手动执行保存的动作，类似于有一个 draftValue 的味道。让我猛然想起产品说的，自动保存正确值的需求！！！
* 有 key 的非可控组件：组件仍然可以从 prop 接受初始值，这时候我们通常使用 `default` 打头命名，表示为非控的，只有首次有效。
* 如果认为 key 值导致组件销毁重建开销大，还是想复用组件的话，那就只能接收一个类似唯一 id 的方式，内部判断 id 是否发生修改，来决定只有需要使用 props 更新 state
* 只用实例方法重置非受控组件：antd form 就是这么做的，虽然从声明式变成了命令式，但是复杂场景该用还得用

### 资料
* [React State Management](https://liyanlance.github.io/docs/react-state-management)
* [严格模式](https://zh-hans.reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects)