## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

如何判断循环引用
* Set WeakSet
* Map WeakMap

dva dispatch yield 生成器函数异常中断，无法继续调用
* 在生成器函数中，哪怕是一点报错。都会导致程序无法再次执行。这是 yield 的特性导致的
* 解决方式将所有报错回避，并做好错误交互，比如多判断变量合法性或使用 try-catch

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具
* spinner：命令行 loading
* npmlog：log 工具
* semver：版本合法性检查工具

书写模块时，关于模块是否应该依赖外部东西时决策
* 模块的封闭性大于冗余性
* 外部依赖模块内部的某些东西：模块暴露多少 API
* 如果必须要依赖，模块内部对外部依赖封装 wrapper

withCredentials 的作用
* 如果遵循同源策略，该属性不会造成任何影响，**永远不会影响到同源请求**
* 要使得该字段生效，服务端必须设置 Access-Control-Allow-Credentials 为 true
* 目的：跨域请求时，cookie 和认证的 HTTP 头信息是否会包含在请求当中，默认为 false，不仅会发送 cookie，还会设置远程主机指定的 Cookie

how to use webworker in cra：workerize-loader

k8s/jenkins/docker/heml

## React 17/18
React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 对于 SSR 非常友好
* 自动批量更新
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的 UI 更新。
  * 紧急更新：比如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹
* SuspenseList
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* useDeferredValue
  * defer 推迟

React 18 新特性
* automatic batching
* transition
* suspense
* hooks
  * useId
  * useTransition
  * useDeferredValue
  * useSyncExternalStore
  * useInsertionEffect

函数式组件与类组件有何不同
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

重点：**时间切片、Suspense、并发模式（Concurrent）**

Vue Hook 不同之处
* 对调用顺序没有要求，由于渲染机制的不同，不会反复调用 Hook 函数，产生的的 GC 压力较小。
* 不用总是考虑 useCallback 的问题，因为模板解析内部会新建 cache 缓存函数，缓存函数内部进行函数调用，因此写内联函数也没关系
* 没有闭包问题，Vue 内部自动依赖关系跟踪确保观察者和计算值始终正确无误

渲染性能优化上的不同
* Vue 抛弃 time slice，模板中区分动态节点和静态节点。事件监听缓存，从而避免不必要子组件更新。运行时特性支持 tree-shaking，没用到的特性代码会被移除
* React 走了另一条道路，既然是 diff 导致问题卡顿，从 CPU 调度的方式解决问题，利用浏览器的空闲时间来做 diff，如果超过了 16ms，有动画或者用户交互的任务，就把主进程控制权还给浏览器，等空闲了继续

## @ausz/editor
为什么要封装 3D 引擎
* 业务相关定制开发周期长
* 熟悉 WebGL 的开发工程师相对较少，培养耗时
* 展示项目相对容易，交互类项目开发相对比较复杂

希望达到的目的
* 场景支持配置化构建
* 降低开发难度

如何实现
* 封装语义化接口
* 引入外部库
* 扩展工具类、增加组件库
* 事件进行抽象和封装

为避免之前的弯路
* 事件机制统一管理，且 typing 完善
* 尽量少用 userData，如果要用，保证类型完全
* 顶部工具栏和特定功能工具状态管理问题：如果功能直接进入，要求不能选取，这时候点选取该如何处理呢
* Object3DFinder 值得好好关注一哈，做了很多 Editor 可直接对外输出的能力以及很多业务能力？？

> 插件化开发？

关于选取，我们应该有两套 api
* 一套直接设置选取对象的 api
* 一套根据鼠标事件交互选取的 api

three.js 细节
* Vector2.prototype.angle()
* Vector3.prototype.angleTo()

three 源码阅读计划，从一些简单高阶封装开始
* ~~DragControls~~
* TransformControls
* OrbitControls
* SelectionBox：研究源码实现框选的逻辑

### 选中态研究
Three.js 官方的 BoxSelection 使用的 material.emissive 的方式来添加选择态
* emissive 默认为黑色，表示不发光
* 选中时设置为白色，取消选中时恢复为黑色，但这个不具备普适性

其他选中态方案
* 修改 material 改为修改 material 对应的颜色，然后 original color 存储在 material.userData 中
* 修改外边框的方式实现，使用 outline 后置处理器

outline 处理器会导致如下问题
* 场景变暗
* 抗锯齿失效

相关网站
* three/editor 包围盒
* vectary/tinkercad/autodesk 边框发亮特效

生态中常见实现方案
* OutlinePass
  * 效果很好，可设置边线大小，光晕，边缘浓度，呼吸闪烁等
  * 性能消耗
* EdgeGeometry
  * 效果还行，使用简单
  * 线宽始终为 1，可使用 LineSegments2 实现线宽大于 1
  * 不同于 wireframe 会将每个三角形通过 Line 绘制出来，EdgeGeometry 实现不显示立方体一个面的中间斜线（仅会渲染硬边缘）
* OutlineEffect
* 法线延伸
  * https://github.com/OmarShehata/webgl-outlines
* BoxHelper
  * 性能最好
  * 效果可能不满足设计要求
* Clone Material 进行材质替换和还原

实现物体描边效果
* 法线延展法
  * 当两个面的法线夹角差别较大时，两个面的描边无法完美连接
* 卷积法
  1. 正常绘制场景
  2. 创建着色器材质，隐藏所有不需要描边的物体。将需要描边的物体绘制成白色，其他地方绘制成黑色
  3. 创建着色器材质进行卷积计算，每四个颜色颜色求平均值得到一个像素。描边物体内部是白色，外部是黑色，物体边缘出会得到灰色，灰色就是所需要的边框
  4. 创建着色器材质，将边框叠加到原来的物体上

### 精准移动与绘制捕捉
捕捉支持自定义规则扩展？？？

Snapper 类
* register(geom: StickyGeom, override: boolean): boolean;
  * 更新 RTree
* snap(geom: StickyGeom): Vector2D[] | Vector3D[]

StickyGeom 类
* ref
* coords
  * 端点
  * 中点
* id
* type
* fromPoint(): StickyGeom[]
* fromLine(): StickyGeom[]
* fromPolygon(): StickyGeom[]

RTree 空间探索
* update(sg)
* query(sg)

## 项目工程问题
更优雅的方式处理项目环境变量问题
* 不再新建 environments 文件夹，而是通过内置的 `.env` 文件的方式解决
* 研究下是否支持环境扩展，而不是仅限于 development、test、production 环境，通过 env-cmd 进行扩展
* 注意文件之间优先级

有必要在抽出一个 apps 目录将项目和包分离开吗？比如将项目方式在 src 目录下

## 请求封装
通常在发送请求，要保证正确性和交互和交互的合理性，需要考虑的东西非常的多，比如如下，**优先保证基础功能**
* 各种状态：loading、error、data(这个肯定会考虑到)，尤其是是否加载、是否报错导致我们定义非常多的变量
* 处理异常逻辑，通常我们只关心成功逻辑，而忘记了同样重要的异常逻辑
* 取消请求
  * 手动取消
  * 组件卸载取消：如果不取消通常会导致控制台报错
  * 竞态取消，当上一次请求还没返回时，又发起了下一次请求，则会取消上一次请求。如果不取消可能导致数据不对
* 进阶功能
  * loading delay：有效防止 loading 闪烁，在指定时间之后才把 loading 置为 true
  * 轮询
  * 依赖刷新：依赖发生变化时，自动触发请求
  * 节流与防抖
  * 缓存功能
  * 错误重试

## 前端研究
产品 ui 上的提示
* 比如断网提示用户，内容会在联网后自动保存到云端
* 保存中… OR 已经保存到云端等相关说明

加快传输速度：使用 GraphQL 让客户机只从服务器请求所需的数据

数据模型设计
* 有时候会纠结两个模型之间，谁关联谁的问题，此时可以回归到关系型数据库中外键如何设计
* 针对计算属性，是应该单独请求还是作为字段呢？
* 考虑引入空方案的设计，路由 `plan/0`

当前前端开发痛点
- 代码难以拆分，重新思考代码模块的组织问题
- 根组件状态过多，不同功能间状态很难维护对，需要消除功能之间对彼此的影响。
- 修改场景样式（normal/hover/active/error）状态很恶心
- 控制可选对象、可删对象、可编辑对象很恶心
- 前端状态库选择，明确全局状态有哪些
- 正确处理请求各种状态，比如请求竞态、请求取消、**编辑状态下前后端数据同步问题**
- 场景编辑的撤销重做

类设计类型
* Value Object
  * 纯数据结构，常用于底层数据结构
* Entity
  * 领域模型作为语言的扩展
  * 通常属性非常精简，大量使用接口约束其行为，偶尔使用继承封装更特异化领域对象
  * 警惕数据耦合、方法耦合、超级方法簇？？？
* Service/aggregate
  * 业务逻辑的步骤，常用语模块入口、顶层模块
  * 类名基本上都是以计算过程或者计算者命名，尽可能的精简属性

Shapely 分享
* 性能
  * STRTree
  * 桶方法
* 图形之间的 9 种关系
* 对象组合设计：类 进入某个模式
* 指定某个策略
* Predicator
* 职责链模式
* 柯立化类
* 找稳定的因素

暴露方法而不是属性的另一个优势：如果属性发生更改，通过方法总是能获取最新值，属性就做不到了

Rollup CSS 代码提取插件：rollup-plugin-postcss

当我们设计一个插件系统时，我们要考虑几个问题：
* 程序中哪些是易变的，哪些是相对稳定的。易变的部分应暴露出相应的能力由插件来完成。
* 插件如何影响程序。通常会以扩展行为，修改状态，变更展示的方式体现
* 案例分析
  * webpack：通过钩子机制完成扩展，核心是定义声明周期（或者叫事件流），并在各个声明周期中调用插件在对应声明周期注册的方法。

### CSS 规范
arco-design 样式方案
* 组件和样式分离
* 每个组件目录下定义 style 目录
  * index.less 文件编写样式
    * 引入全局 theme/default.less 文件，包含色板、间距、边框、圆角等通用全局配置
    * 引入自身 token.less 文件，定义自身支持修改的 token 变量，使用部分 CSS 变量，用于实现动态换肤
  * index.ts 供打包使用
    * 引入上述 index.less
    * 引入全局 style/index.less 文件，除 default.less 之外，包含 CSS 变量、CSS 常规化、mixin 和动画等
* 打包过程
  * 每个组件 style 目录会生成对应的 index.css 和 index.less，以供按需加载使用
  * 会 bundle 所有组件的 index.ts，打包一份整个组件库的 index.css 和 index.less
* 关于主题
  * 平台关于特定组件的样式修改会存在 components 中
  * 基于组件默认的 index.less + 自定义的 theme/variables/component 编译一份新的 arco.css 供使用
* 自己组件沿用 arco 基础样式已确保一致性
  * 是否有办法 figma 审查时直接看到使用了的变量名
  * 官方 Pro 的做法：直接 style 中直接引用 CSS 变量以及复用 themes/<name>/variables.less 定义的变量

CSS 编写存在的问题
* 存在两套 CSS 变量
  * 都回归到使用 arco 的变量
  * 如果需要新增，则平台新增后，更新包
* CSS 智能提示问题
* 主要基础样式种类
* 直接使用 CSS 变量还是有语义的 less 变量
* 是否允许局部定义：不允许

### arco-design-pro
路由鉴权：AuthContext、AuthProvider、useAuth、RequireAuth 组件
* AuthContext 验证信息的上下文（存储当前用户信息、登录、登出方法）
* useAuth 和 AuthProvider 是 AuthContext 的封装
* RequireAuth：未登录则跳转到登录页，或者正常渲染

基本流程参考
* 检查 userStatus cache，判断是否已经登录，如已登录，则查询用户信息，否则跳转登录页
* 注册根路由 `/` 组件 Layout 和登录路由 `/login` 组件 Login
* Layout 组件
  * 初始化导航栏
  * 根据路由初始化左侧菜单
  * 内容区域注册路由
  * 全局 setting 支持设置菜单是否显示、导航栏、底部是否显示
* 监听菜单点击事件，触发路由跳转

代码片段-arco-design-pro
```ts
const dv = new DataView().source(data);
// 通过链式调用的方式优化传参，或者说解耦函数
view
  .interval()
  .adjust('stack')
  .position('value')
  .color('type', [
    '#249eff',
    '#846BCE',
    '#21CCFF',
    ' #86DF6C',
    '#0E42D2',
  ])
  .label('value', {
    content: (content) => {
      return `${(content.value * 100).toFixed(2)} %`;
    },
  })
// 命名：XXXWrapper

// 巧用 cloneElement
{trigger ? (
  React.cloneElement(trigger as React.ReactElement, {
    onClick: () => setVisible(true),
  })
) : (
  <IconButton icon={<IconSettings />} onClick={() => setVisible(true)} />
)}

// 路由参数
export type IRoute = AuthParams & {
  name: string;
  key: string;
  // 当前页是否展示面包屑
  breadcrumb?: boolean;
  children?: IRoute[];
  // 当前路由是否渲染菜单项，为 true 的话不会在菜单中显示，但可通过路由地址访问。
  ignore?: boolean;
};

// PermissionWrapper，满足则渲染 children，否则渲染 backup || null

// useRequest
```

### State Manager
状态库选择
* recoil
* jotai：和 recoil 相似，基于原子状态管理，api 更简洁，更好的性能（使用 WeakMap 来跟踪原子。这意味着 JS 引擎会自动处理垃圾收集）
* redux
* rematch：建立在 Redux 核心之上，简化了设置过程，减少了样板文件
* zustand：体积最小的状态管理库
* XState
* Valtio
* Mobox

全局状态相关
* 可能的相关数据
  * 当前用户
  * 当前项目
  * 当前方案
  * 方案列表
* 命名推荐
  * GlobalContext
  * GlobalState

React-Query
* 为什么某些数据获取库会取代我们的全局状态管理器？这两者有什么关系呢？
* 客户端状态与服务器状态：不仅仅是描述你想要的数据和获取该数据的能力，它还为该服务器数据提供了缓存。这意味着你可以在多个组件中使用相同的（key 相同） useQuery 钩子，它只会获取一次数据，然后从缓存中返回它。
* stale-while-revalidate：重新请求的同时使用过期数据
* 默认配置
  * staleTime：表示查询从新鲜转换为陈旧的持续时间，即使默认为 0，也不会在每次重新渲染时调用 queryFn
  * cacheTime：从缓存中删除非活动查询的持续时间
* 使用 React Query DevTools
* 将查询键视为依赖数组：每当查询键更改时，React Query 都会触发重新获取。
* 启用选项非常强大
  * 相关查询：在一个查询中获取数据，只有在我们成功从第一个查询中获取数据后才运行第二个查询
  * 打开和关闭查询：refetchInterval
  * 等待用户输入：在查询键中有一些过滤条件，但只要用户没有应用他们的过滤器就禁用它
  * 在某些用户输入后禁用查询
  * 不要将 queryCache 用作本地状态管理器
* 创建自定义 Hook

React-Query 相关知识
* useQuery/useInfiniteQuery
* 相关配置：refetchOnMount, refetchOnWindowFocus, refetchOnReconnect, refetchInterval
* 失败的查询将会静默的重试 3 次，可通过 retry 和 retryDelay 修改
* 默认情况下如果数据没有改变，则会维持引用不变，如果你的响应数据很大，影响到应用的性能，可以通过 config.structuralSharing 关闭
* 您提供的惟一键在内部用于在整个应用程序中重新获取、缓存和共享查询
* 结果包含如下数据
  * status 表示状态
  * isLoading/isError/isSuccess/isIdle
  * error/data/isFetching
  * isFetching 常用来作为后台查询显示符，甚至提供 useIsFetching 钩子用于获取全局的状态
* 可以通过 Query Key 传递额外参数，queryKey 会作为参数传进 queryFn
* 并行查询
  * 非 suspense 模式下，直接写多个 useQuery 即可
  * suspense 模式下，推荐使用 useQueries
* 依赖查询：通过 config.enabled 控制查询
* 关闭自动运行，设置 config.enabled，返回的 refetch 函数可用于手动触发
* 针对分页数据查询，点击页码，ui 会处于 success 和 loading 之间反复变化，这不是很优化，提供了 config.keepPreviousData 参数优化该体验
* 提供 useInfiniteQuery 钩子用于无限滚动加载
* config.select 参数可用于对数据进行加工处理
* config.placeholderData 当你只有一个模型部分数据时，比如 list 的 item 可能只是 snippet，此时可以用做占位使用，当完成数据回来时再被替换。和 initialData 相似，但不会被当做缓存，有 Declaratively 和 Imperatively 两种方式
* initialData 通过 config.initialData 或 queryClient.prefetchQuery/setQueryData
* queryClient.prefetchQuery 预加载数据
* useMutation 用于更改数据
* Optimistic Update 乐观更新与数据回滚（提供一个上下文，可供你访问之前的数据）
* queryClient.invalidateQueries 过期某部分数据
* 查询取消机制
  * AbortController
  * CancelToken 不被推荐
  * queryClient.cancelQueries 手动取消
* 滚动恢复： 传统上，当你导航到一个访问过的页面，页面会滚动到你之前滚动到的页面，但自动应用开始从客户端查询数据时，情况又有些不一样了，但 React-Query 不存在这个问题
* 默认查询函数：定义默认的 queryFn，只使用查询键来确定它应该获取什么，可以使得整个应用可以共享查询
* 能否替换 Redux、Mobx 等
  * 服务端状态库 vs 客户端状态库
  * 对于绝大多数应用程序，在将所有异步代码迁移到React Query之后，剩下的真正全局可访问的客户端状态通常非常小
  * 在某些情况下，应用程序可能确实有大量的同步客户端状态(如**视觉设计器或音乐制作应用程序，客户端会生产数据**)，在这种情况下，您可能仍然需要一个客户端状态管理器
  * 角色很明确。它从您的应用程序中删除了异步连接和样板，并用几行代码替换它