## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

如何判断循环引用
* Set WeakSet
* Map WeakMap

dva dispatch yield 生成器函数异常中断，无法继续调用
* 在生成器函数中，哪怕是一点报错。都会导致程序无法再次执行。这是 yield 的特性导致的
* 解决方式将所有报错回避，并做好错误交互，比如多判断变量合法性或使用 try-catch

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具
* spinner：命令行 loading
* npmlog：log 工具
* semver：版本合法性检查工具

书写模块时，关于模块是否应该依赖外部东西时决策
* 模块的封闭性大于冗余性
* 外部依赖模块内部的某些东西：模块暴露多少 API
* 如果必须要依赖，模块内部对外部依赖封装 wrapper

withCredentials 的作用
* 如果遵循同源策略，该属性不会造成任何影响，**永远不会影响到同源请求**
* 要使得该字段生效，服务端必须设置 Access-Control-Allow-Credentials 为 true
* 目的：跨域请求时，cookie 和认证的 HTTP 头信息是否会包含在请求当中，默认为 false，不仅会发送 cookie，还会设置远程主机指定的 Cookie

how to use webworker in cra：workerize-loader

k8s/jenkins/docker/heml

## React 17/18
React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 对于 SSR 非常友好
* 自动批量更新
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的 UI 更新。
  * 紧急更新：比如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹
* SuspenseList
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* useDeferredValue
  * defer 推迟

React 18 新特性
* automatic batching
* transition
* suspense
* hooks
  * useId
  * useTransition
  * useDeferredValue
  * useSyncExternalStore
  * useInsertionEffect

函数式组件与类组件有何不同
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

重点：**时间切片、Suspense、并发模式（Concurrent）**

Vue Hook 不同之处
* 对调用顺序没有要求，由于渲染机制的不同，不会反复调用 Hook 函数，产生的的 GC 压力较小。
* 不用总是考虑 useCallback 的问题，因为模板解析内部会新建 cache 缓存函数，缓存函数内部进行函数调用，因此写内联函数也没关系
* 没有闭包问题，Vue 内部自动依赖关系跟踪确保观察者和计算值始终正确无误

渲染性能优化上的不同
* Vue 抛弃 time slice，模板中区分动态节点和静态节点。事件监听缓存，从而避免不必要子组件更新。运行时特性支持 tree-shaking，没用到的特性代码会被移除
* React 走了另一条道路，既然是 diff 导致问题卡顿，从 CPU 调度的方式解决问题，利用浏览器的空闲时间来做 diff，如果超过了 16ms，有动画或者用户交互的任务，就把主进程控制权还给浏览器，等空闲了继续

## 项目工程问题
更优雅的方式处理项目环境变量问题
* 不再新建 environments 文件夹，而是通过内置的 `.env` 文件的方式解决
* 研究下是否支持环境扩展，而不是仅限于 development、test、production 环境，通过 env-cmd 进行扩展
* 注意文件之间优先级

有必要在抽出一个 apps 目录将项目和包分离开吗？比如将项目方式在 src 目录下

## 前端研究
产品 ui 上的提示
* 比如断网提示用户，内容会在联网后自动保存到云端
* 保存中… OR 已经保存到云端等相关说明

设置一个 UI 提示该数据不是最新数据
* 比如使数据透明显示
* 一个正在拉取的 ui 提示

可能的全局状态
* 当前用户
* 当前项目
* 当前方案
* 方案列表

加快传输速度：使用 GraphQL 让客户机只从服务器请求所需的数据

数据模型设计
* 有时候会纠结两个模型之间，谁关联谁的问题，此时可以回归到关系型数据库中外键如何设计
* 针对计算属性，是应该单独请求还是作为字段呢？
* 考虑引入空方案的设计，路由 `plan/0`

类设计类型
* Value Object
  * 纯数据结构，常用于底层数据结构
* Entity
  * 领域模型作为语言的扩展
  * 通常属性非常精简，大量使用接口约束其行为，偶尔使用继承封装更特异化领域对象
  * 警惕数据耦合、方法耦合、超级方法簇？？？
* Service/aggregate
  * 业务逻辑的步骤，常用语模块入口、顶层模块
  * 类名基本上都是以计算过程或者计算者命名，尽可能的精简属性

Shapely 分享
* 性能
  * STRTree
  * 桶方法
* 图形之间的 9 种关系
* 对象组合设计：类 进入某个模式
* 指定某个策略
* Predicator？？
* 职责链模式
* 柯立化类
* 找稳定的因素

暴露方法而不是属性的另一个优势：如果属性发生更改，通过方法总是能获取最新值，属性就做不到了

路由授权
```ts
export function PrivateOutlet() {
  const auth = useAuth()
  const location = useLocation()

  return auth.user ? (
    <Outlet />
  ) : (
    <Navigate to="/login" state={{ from: location }} />
  )
}
```

### CSS 规范
arco-design 样式方案
* 组件和样式分离
* 每个组件目录下定义 style 目录
  * index.less 文件编写样式
    * 引入全局 theme/default.less 文件，包含色板、间距、边框、圆角等通用全局配置
    * 引入自身 token.less 文件，定义自身支持修改的 token 变量，使用部分 CSS 变量，用于实现动态换肤
  * index.ts 供打包使用
    * 引入上述 index.less
    * 引入全局 style/index.less 文件，除 default.less 之外，包含 CSS 变量、CSS 常规化、mixin 和动画等
* 打包过程
  * 每个组件 style 目录会生成对应的 index.css 和 index.less，以供按需加载使用
  * 会 bundle 所有组件的 index.ts，打包一份整个组件库的 index.css 和 index.less
* 关于主题
  * 平台关于特定组件的样式修改会存在 components 中
  * 基于组件默认的 index.less + 自定义的 theme/variables/component 编译一份新的 arco.css 供使用
* 自己组件沿用 arco 基础样式以确保一致性
  * 是否有办法 figma 审查时直接看到使用了的变量名
  * 官方 Pro 的做法：直接 style 中直接引用 CSS 变量以及复用 themes/<name>/variables.less 定义的变量

目前 CSS 编写存在的问题
* 存在两套 CSS 变量
  * 都回归到使用 arco 的变量
  * 如果需要新增，则平台新增后，更新包
* CSS 智能提示问题
* 主要基础样式种类
* 直接使用 CSS 变量还是有语义的 less 变量
* 是否允许局部定义：不允许

### arco-design-pro
路由鉴权：AuthContext、AuthProvider、useAuth、RequireAuth 组件
* AuthContext 验证信息的上下文（存储当前用户信息、登录、登出方法）
* useAuth 和 AuthProvider 是 AuthContext 的封装
* RequireAuth：未登录则跳转到登录页，或者正常渲染

基本流程参考
* 检查 userStatus cache，判断是否已经登录，如已登录，则查询用户信息，否则跳转登录页
* 注册根路由 `/` 组件 Layout 和登录路由 `/login` 组件 Login
* Layout 组件
  * 初始化导航栏
  * 根据路由初始化左侧菜单
  * 内容区域注册路由
  * 全局 setting 支持设置菜单是否显示、导航栏、底部是否显示
* 监听菜单点击事件，触发路由跳转

代码片段-arco-design-pro
```ts
const dv = new DataView().source(data);
// 通过链式调用的方式优化传参，或者说解耦函数
view
  .interval()
  .adjust('stack')
  .position('value')
  .color('type', [
    '#249eff',
    '#846BCE',
    '#21CCFF',
    ' #86DF6C',
    '#0E42D2',
  ])
  .label('value', {
    content: (content) => {
      return `${(content.value * 100).toFixed(2)} %`;
    },
  })
// 命名：XXXWrapper

// 巧用 cloneElement
{trigger ? (
  React.cloneElement(trigger as React.ReactElement, {
    onClick: () => setVisible(true),
  })
) : (
  <IconButton icon={<IconSettings />} onClick={() => setVisible(true)} />
)}

// 路由参数
export type IRoute = AuthParams & {
  name: string;
  key: string;
  // 当前页是否展示面包屑
  breadcrumb?: boolean;
  children?: IRoute[];
  // 当前路由是否渲染菜单项，为 true 的话不会在菜单中显示，但可通过路由地址访问。
  ignore?: boolean;
};

// PermissionWrapper，满足则渲染 children，否则渲染 backup || null

// useRequest
```

### RTK Query 学习
将状态从一个管理器复制到另一个管理器是糟糕的
* 将 props 复制到 state
* 将 cache 复制到 local state or global state

RTK Query 是一个完整的缓存方案，你通常不需要将状态 copy 出去，而是让它负责管理数据

RTK Query 支持传递 queryFn
* 使用 queryFn 时会忽略 baseQuery
* 通过设置 queryFn 为 noop，配合 invalidatesTag 实现重新获取其他数据
* 实现一次发送多个请求，这是 query 无法做到的
* transformResponse 不能作用于 queryFn

逻辑拆分：通常推荐仅调用一次 createApi，通过 apiSlice.injectEndPoints 组合多个模块

从 apiSlice 中获取与更新数据
* apiSlice.endPoints.select()
* apiSlice.util.updateQueryData()

extraReducers addMatcher vs addCase
* addCase 是 addMatcher 的特殊化，用于和指定 type 匹配
* addMatcher 传递一个函数作为匹配条件，返回 true 则进入 reducer 逻辑
* apiSlice.endpoints.xxx.matchFulfilled for add matcher
* xxxThunk.fulfilled for add case

useLazyQuery 实现手动派发请求
* 第二参数 preferCacheValue 表示是否使用缓存
* 如果走的缓存，则不会触发 matchFulfilled 动作

createEntityAdapter 复用 CRUD 逻辑
* upsert: update or insert if does not exist
* adapter select 出来的数据是 readonly object
* updateOne 和 updateMany 只能浅层合并更新，对于深层嵌套更新，推荐手动操作

createSelector 帮助优化性能

onQueryStarted
* query params
* dispatch/getState/queryFulfilled
* queryFulfilled 可以实现手动更新缓存，而不是重新拉取

根据 endpoints 断定 isLoading 字段，并不考虑到参数

自动切换方案逻辑
* 复制多层方案中的单层方案时，自动切换到新方案
* 生成新多层方案时，自动切换到新方案中的第一个方案
* 删除多层方案时，当前方案置空
* 删除单层方案时，自动切换到下一个