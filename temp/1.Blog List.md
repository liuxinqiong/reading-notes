## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

如何判断循环引用
* Set WeakSet
* Map WeakMap

dva dispatch yield 生成器函数异常中断，无法继续调用
* 在生成器函数中，哪怕是一点报错。都会导致程序无法再次执行。这是 yield 的特性导致的
* 解决方式将所有报错回避，并做好错误交互，比如多判断变量合法性或使用 try-catch

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具
* spinner：命令行 loading
* npmlog：log 工具
* semver：版本合法性检查工具

书写模块时，关于模块是否应该依赖外部东西时决策
* 模块的封闭性大于冗余性
* 外部依赖模块内部的某些东西：模块暴露多少 API
* 如果必须要依赖，模块内部对外部依赖封装 wrapper

withCredentials 的作用
* 如果遵循同源策略，该属性不会造成任何影响，**永远不会影响到同源请求**
* 要使得该字段生效，服务端必须设置 Access-Control-Allow-Credentials 为 true
* 目的：跨域请求时，cookie 和认证的 HTTP 头信息是否会包含在请求当中，默认为 false，不仅会发送 cookie，还会设置远程主机指定的 Cookie

how to use webworker in cra：workerize-loader

k8s/jenkins/docker/heml

## React 17/18
React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 对于 SSR 非常友好
* 自动批量更新
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的 UI 更新。
  * 紧急更新：比如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹
* SuspenseList
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* useDeferredValue
  * defer 推迟

React 18 新特性
* automatic batching
* transition
* suspense
* hooks
  * useId
  * useTransition
  * useDeferredValue
  * useSyncExternalStore
  * useInsertionEffect

函数式组件与类组件有何不同
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

重点：**时间切片、Suspense、并发模式（Concurrent）**

Vue Hook 不同之处
* 对调用顺序没有要求，由于渲染机制的不同，不会反复调用 Hook 函数，产生的的 GC 压力较小。
* 不用总是考虑 useCallback 的问题，因为模板解析内部会新建 cache 缓存函数，缓存函数内部进行函数调用，因此写内联函数也没关系
* 没有闭包问题，Vue 内部自动依赖关系跟踪确保观察者和计算值始终正确无误

渲染性能优化上的不同
* Vue 抛弃 time slice，模板中区分动态节点和静态节点。事件监听缓存，从而避免不必要子组件更新。运行时特性支持 tree-shaking，没用到的特性代码会被移除
* React 走了另一条道路，既然是 diff 导致问题卡顿，从 CPU 调度的方式解决问题，利用浏览器的空闲时间来做 diff，如果超过了 16ms，有动画或者用户交互的任务，就把主进程控制权还给浏览器，等空闲了继续

## @ausz/editor
为什么要封装 3D 引擎
* 业务相关定制开发周期长
* 熟悉 WebGL 的开发工程师相对较少，培养耗时
* 展示项目相对容易，交互类项目开发相对比较复杂

希望达到的目的
* 场景支持配置化构建
* 降低开发难度

如何实现
* 封装语义化接口
* 引入外部库
* 扩展工具类、增加组件库
* 事件进行抽象和封装

为避免之前的弯路
* 事件机制统一管理，且 typing 完善
* 尽量少用 userData，如果要用，保证类型完全
* 顶部工具栏和特定功能工具状态管理问题：如果功能直接进入，要求不能选取，这时候点选取该如何处理呢
* Object3DFinder 值得好好关注一哈，做了很多 Editor 可直接对外输出的能力以及很多业务能力？？

> 插件化开发？

关于选取，我们应该有两套 api
* 一套直接设置选取对象的 api
* 一套根据鼠标事件交互选取的 api

three.js 细节
* Vector2.prototype.angle()
* Vector3.prototype.angleTo()

three 源码阅读计划，从一些简单高阶封装开始
* ~~DragControls~~
* TransformControls
* OrbitControls
* SelectionBox：研究源码实现框选的逻辑

### 选中态研究
Three.js 官方的 BoxSelection 使用的 material.emissive 的方式来添加选择态
* emissive 默认为黑色，表示不发光
* 选中时设置为白色，取消选中时恢复为黑色，但这个不具备普适性

其他选中态方案
* 修改 material 改为修改 material 对应的颜色，然后 original color 存储在 material.userData 中
* 修改外边框的方式实现，使用 outline 后置处理器

outline 处理器会导致如下问题
* 场景变暗
* 抗锯齿失效

相关网站
* three/editor 包围盒
* vectary/tinkercad/autodesk 边框发亮特效

生态中常见实现方案
* OutlinePass
  * 效果很好，可设置边线大小，光晕，边缘浓度，呼吸闪烁等
  * 性能消耗
* EdgeGeometry
  * 效果还行，使用简单
  * 线宽始终为 1，可使用 LineSegments2 实现线宽大于 1
  * 不同于 wireframe 会将每个三角形通过 Line 绘制出来，EdgeGeometry 实现不显示立方体一个面的中间斜线（仅会渲染硬边缘）
* OutlineEffect
* 法线延伸
  * https://github.com/OmarShehata/webgl-outlines
* BoxHelper
  * 性能最好
  * 效果可能不满足设计要求
* Clone Material 进行材质替换和还原

实现物体描边效果
* 法线延展法
  * 当两个面的法线夹角差别较大时，两个面的描边无法完美连接
* 卷积法
  1. 正常绘制场景
  2. 创建着色器材质，隐藏所有不需要描边的物体。将需要描边的物体绘制成白色，其他地方绘制成黑色
  3. 创建着色器材质进行卷积计算，每四个颜色颜色求平均值得到一个像素。描边物体内部是白色，外部是黑色，物体边缘出会得到灰色，灰色就是所需要的边框
  4. 创建着色器材质，将边框叠加到原来的物体上

### 精准移动与绘制捕捉
捕捉支持自定义规则扩展？？？

Snapper 类
* register(geom: StickyGeom, override: boolean): boolean;
  * 更新 RTree
* snap(geom: StickyGeom): Vector2D[] | Vector3D[]

StickyGeom 类
* ref
* coords
  * 端点
  * 中点
* id
* type
* fromPoint(): StickyGeom[]
* fromLine(): StickyGeom[]
* fromPolygon(): StickyGeom[]

RTree 空间探索
* update(sg)
* query(sg)

## 项目工程问题
更优雅的方式处理项目环境变量问题
* 不再新建 environments 文件夹，而是通过内置的 `.env` 文件的方式解决
* 研究下是否支持环境扩展，而不是仅限于 development、test、production 环境，通过 env-cmd 进行扩展
* 注意文件之间优先级

有必要在抽出一个 apps 目录将项目和包分离开吗？比如将项目方式在 src 目录下

## 前端研究
产品 ui 上的提示
* 比如断网提示用户，内容会在联网后自动保存到云端
* 保存中… OR 已经保存到云端等相关说明

设置一个 UI 提示该数据不是最新数据
* 比如使数据透明显示
* 一个正在拉取的 ui 提示

可能的全局状态
* 当前用户
* 当前项目
* 当前方案
* 方案列表

加快传输速度：使用 GraphQL 让客户机只从服务器请求所需的数据

数据模型设计
* 有时候会纠结两个模型之间，谁关联谁的问题，此时可以回归到关系型数据库中外键如何设计
* 针对计算属性，是应该单独请求还是作为字段呢？
* 考虑引入空方案的设计，路由 `plan/0`

当前前端开发痛点
- 前端状态库选择，明确全局状态有哪些
- 代码难以拆分，重新思考代码模块的组织问题
- 根组件状态过多，不同功能间状态很难维护对，需要消除功能之间对彼此的影响
- 正确处理请求各种状态，比如请求竞态、请求取消、**编辑状态下前后端数据同步问题**
- 修改场景样式（normal/hover/active/error）状态很恶心
- 控制可选对象、可删对象、可编辑对象很恶心
- 场景编辑的撤销重做

类设计类型
* Value Object
  * 纯数据结构，常用于底层数据结构
* Entity
  * 领域模型作为语言的扩展
  * 通常属性非常精简，大量使用接口约束其行为，偶尔使用继承封装更特异化领域对象
  * 警惕数据耦合、方法耦合、超级方法簇？？？
* Service/aggregate
  * 业务逻辑的步骤，常用语模块入口、顶层模块
  * 类名基本上都是以计算过程或者计算者命名，尽可能的精简属性

Shapely 分享
* 性能
  * STRTree
  * 桶方法
* 图形之间的 9 种关系
* 对象组合设计：类 进入某个模式
* 指定某个策略
* Predicator
* 职责链模式
* 柯立化类
* 找稳定的因素

暴露方法而不是属性的另一个优势：如果属性发生更改，通过方法总是能获取最新值，属性就做不到了

Rollup CSS 代码提取插件：rollup-plugin-postcss

当我们设计一个插件系统时，我们要考虑几个问题：
* 程序中哪些是易变的，哪些是相对稳定的。易变的部分应暴露出相应的能力由插件来完成。
* 插件如何影响程序。通常会以扩展行为，修改状态，变更展示的方式体现
* 案例分析
  * webpack：通过钩子机制完成扩展，核心是定义声明周期（或者叫事件流），并在各个声明周期中调用插件在对应声明周期注册的方法。

### CSS 规范
arco-design 样式方案
* 组件和样式分离
* 每个组件目录下定义 style 目录
  * index.less 文件编写样式
    * 引入全局 theme/default.less 文件，包含色板、间距、边框、圆角等通用全局配置
    * 引入自身 token.less 文件，定义自身支持修改的 token 变量，使用部分 CSS 变量，用于实现动态换肤
  * index.ts 供打包使用
    * 引入上述 index.less
    * 引入全局 style/index.less 文件，除 default.less 之外，包含 CSS 变量、CSS 常规化、mixin 和动画等
* 打包过程
  * 每个组件 style 目录会生成对应的 index.css 和 index.less，以供按需加载使用
  * 会 bundle 所有组件的 index.ts，打包一份整个组件库的 index.css 和 index.less
* 关于主题
  * 平台关于特定组件的样式修改会存在 components 中
  * 基于组件默认的 index.less + 自定义的 theme/variables/component 编译一份新的 arco.css 供使用
* 自己组件沿用 arco 基础样式已确保一致性
  * 是否有办法 figma 审查时直接看到使用了的变量名
  * 官方 Pro 的做法：直接 style 中直接引用 CSS 变量以及复用 themes/<name>/variables.less 定义的变量

CSS 编写存在的问题
* 存在两套 CSS 变量
  * 都回归到使用 arco 的变量
  * 如果需要新增，则平台新增后，更新包
* CSS 智能提示问题
* 主要基础样式种类
* 直接使用 CSS 变量还是有语义的 less 变量
* 是否允许局部定义：不允许

### arco-design-pro
路由鉴权：AuthContext、AuthProvider、useAuth、RequireAuth 组件
* AuthContext 验证信息的上下文（存储当前用户信息、登录、登出方法）
* useAuth 和 AuthProvider 是 AuthContext 的封装
* RequireAuth：未登录则跳转到登录页，或者正常渲染

基本流程参考
* 检查 userStatus cache，判断是否已经登录，如已登录，则查询用户信息，否则跳转登录页
* 注册根路由 `/` 组件 Layout 和登录路由 `/login` 组件 Login
* Layout 组件
  * 初始化导航栏
  * 根据路由初始化左侧菜单
  * 内容区域注册路由
  * 全局 setting 支持设置菜单是否显示、导航栏、底部是否显示
* 监听菜单点击事件，触发路由跳转

代码片段-arco-design-pro
```ts
const dv = new DataView().source(data);
// 通过链式调用的方式优化传参，或者说解耦函数
view
  .interval()
  .adjust('stack')
  .position('value')
  .color('type', [
    '#249eff',
    '#846BCE',
    '#21CCFF',
    ' #86DF6C',
    '#0E42D2',
  ])
  .label('value', {
    content: (content) => {
      return `${(content.value * 100).toFixed(2)} %`;
    },
  })
// 命名：XXXWrapper

// 巧用 cloneElement
{trigger ? (
  React.cloneElement(trigger as React.ReactElement, {
    onClick: () => setVisible(true),
  })
) : (
  <IconButton icon={<IconSettings />} onClick={() => setVisible(true)} />
)}

// 路由参数
export type IRoute = AuthParams & {
  name: string;
  key: string;
  // 当前页是否展示面包屑
  breadcrumb?: boolean;
  children?: IRoute[];
  // 当前路由是否渲染菜单项，为 true 的话不会在菜单中显示，但可通过路由地址访问。
  ignore?: boolean;
};

// PermissionWrapper，满足则渲染 children，否则渲染 backup || null

// useRequest
```
