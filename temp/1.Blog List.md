## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

如何判断循环引用
* Set WeakSet
* Map WeakMap

yield 报错后不再进入问题

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具
* spinner：命令行 loading
* npmlog：log 工具
* semver：版本合法性检查工具

书写模块时，关于模块是否应该依赖外部东西时决策
* 模块的封闭性大于冗余性
* 或外部依赖模块内部的某些东西
* 如果必须要依赖，模块内部对外部依赖封装 wrapper

withCredentials 的作用
* 如果遵循同源策略，该属性不会造成任何影响，**永远不会影响到同源请求**
* 要使得该字段生效，服务端必须设置 Access-Control-Allow-Credentials 为 true
* 目的：跨域请求时，cookie 和认证的 HTTP 头信息是否会包含在请求当中，默认为 false，不仅会发送 cookie，还会设置远程主机指定的 Cookie

how to use webworker in cra：workerize-loader

## React 17/18
React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 对于 SSR 非常友好
* 自动批量更新
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的UI更新。
  * 紧急更新：比如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹
* SuspenseList
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* useDeferredValue
  * defer 推迟

函数式组件与类组件有何不同
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

重点：**时间切片、Suspense、并发模式（Concurrent）**

## @ausz/editor
为什么要封装 3D 引擎
* 业务相关定制开发周期长
* 熟悉 WebGL 的开发较少，培养耗时
* 展示项目相对容易，交互类项目开发相对比较复杂

希望达到的目的
* 场景支持配置化构建
* 降低开发难度

如何实现
* 封装语义化接口
* 引入外部库
* 扩展工具类、增加组件库
* 事件进行抽象和封装

为避免之前的弯路
* 事件机制统一管理，且 typing 完善
* 尽量少用 userData，如果要用，保证类型完全
* 顶部工具栏和特定功能工具状态管理问题：如果功能直接进入，要求不能选取，这时候点选取该如何处理呢
* Object3DFinder 值得好好关注一哈，做了很多 Editor 可直接对外输出的能力以及很多业务能力？？

> 插件化开发？

关于选取，我们应该有两套 api
* 一套直接设置选取对象的 api
* 一套根据鼠标事件交互选取的 api

## three 源码阅读计划
从一些简单高阶封装开始
* ~~DragControls~~
* OrbitControls
* TransformControls
* SelectionBox：研究源码实现框选的逻辑

## three.js 选中态问题
Three.js 官方的 BoxSelection 使用的 material.emissive 的方式来添加选择态
* emissive 默认为黑色，表示不发光
* 选中时设置为白色，取消选中时恢复为黑色，但这个不具备普适性

其他选中态方案
* 修改 material 改为修改 material 对应的颜色，然后 original color 存储在 material.userData 中
* 修改外边框的方式实现，使用 outline 后置处理器

outline 处理器会导致如下问题
* 场景变暗
* 抗锯齿失效

相关网站
* three/editor 包围盒
* vectary/tinkercad/autodesk 边框发亮特效

## three.js 精准移动与绘制捕捉
捕捉支持自定义规则扩展？？？

Snapper 类
* register(geom: StickyGeom, override: boolean): boolean;
  * 更新 RTree
* snap(geom: StickyGeom): Vector2D[] | Vector3D[]

StickyGeom 类
* ref
* coords
  * 端点
  * 中点
* id
* type
* fromPoint(): StickyGeom[]
* fromLine(): StickyGeom[]
* fromPolygon(): StickyGeom[]

RTree 空间探索
* update(sg)
* query(sg)

## 遗留问题
更优雅的方式处理项目环境变量问题
* 不再新建 environments 文件夹，而是通过内置的 `.env` 文件的方式解决
* 研究下是否支持环境扩展，而不是仅限于 development、test、production 环境，通过 env-cmd 进行扩展
* 注意文件之间优先级

有必要在抽出一个 apps 目录将项目和包分离开吗？

WireframeGeometry vs EdgesGeometry
* WireframeGeometry 呈现所有边缘
* EdgesGeometry 只会渲染硬边缘
* 还是不懂

## 其他
升级 react-router-dom to v6
* v6 版本依赖 React hooks 特性，因此需要 React 16.8 及以上
* 自带类型声明，不再需要 @types/react-router-dom
* component prop => element prop
  * element 更加便于给组件传参
  * 因为嵌套路由保留了 children 属性，所以只能新增 element 属性，新增 Outlet 组件为嵌套服务
* useHistory => useNavigate
* Redirect Comp => Navigate Comp
* Switch Comp => Routes Comp
  * 路由匹配基于最佳匹配，而不是顺序
* 移除 Route exact prop
* 简化路由格式，仅支持 :params 和 * 通配符
* 新增 useRoutes hooks 用于通过对象的方式定义路由，Routes 本质上就是 useRoutes 的 wrapper
* 移除 Link 组件的 component 属性
* NavLink exact props rename to end
* NavLink 移除 activeClassName 和 activeStyle 属性，而是提供一个 isActive 的 state
* useRouteMatch to useMatch

## 请求封装
通常在发送请求，要保证正确性和交互和交互的合理性，需要考虑的东西非常的多，比如如下，**优先保证基础功能**
* 各种状态：loading、error、data(这个肯定会考虑到)，尤其是是否加载、是否报错导致我们定义非常多的变量
* 处理异常逻辑，通常我们只关心成功逻辑，而忘记了同样重要的异常逻辑
* 取消请求
  * 手动取消
  * 组件卸载取消：如果不取消通常会导致控制台报错
  * 竞态取消，当上一次请求还没返回时，又发起了下一次请求，则会取消上一次请求。如果不取消可能导致数据不对
* 进阶功能
  * loading delay：有效防止 loading 闪烁，在指定事件之后才把 loading 置为 true
  * 轮询
  * 依赖刷新：依赖发生变化时，自动触发请求
  * 节流与防抖
  * 缓存功能
  * 错误重试

## 后端服务
Celery
* 专注于实时处理和任务调度的分布式任务队列
* 多种并发模式
  * 多进程
  * Eventlet
  * Gevent

依赖安装与启动
```shell
pip3 install celery

pip3 install -r requirements.txt -i http://47.107.240.240:30888 --trusted-host 47.107.240.240 --user -U
REDIS_SERVICE_HOST=localhost python3 -m celery -A task worker -l INFO
REDIS_SERVICE_HOST=localhost python3 main.py

brew services start redis
```

## socket
HTTP VS WebSocket
* 可能通用的原则
  * 默认情况下应该使用传统的 HTTP
  * 根据具体情况，说服自己的 API 应该是用 WebSocket
* 相关对比
  * 双工：HTTP 半双工，同时只能向一个方向传输。websocket 全双工，双方都能同时发送和接受数据
  * 消息模式：Request-response 与 Bi-directional（双向）
  * websocket 支持消息推送
  * 开销：HTTP 每个请求都会一定开销，websocket 主要在建立和维持连接上，每个消息的开销较小
  * 边缘缓存：HTTP 支持缓存，websocket 则没有
* 适用 HTTP 的场景
  * 检索资源：查看比赛结果（HTTP） vs 查看比赛实时比分（websocket）
  * 高度可缓存资源
  * 幂等性和安全性：能更好的适应通信失败。因为 HTTP 具有广泛的安全性和幂等性期望。WebSocket 协议将这些问题留给了消息层设计(这意味着没有广泛的行业标准)。
  * 错误场景：HTTP 允许响应去描述错误信息，比如请求、资源，或者提供状态信息来区分不同的成功场景。WebSocket 协议只对影响连接建立的错误场景提供支持，一旦请求建立和消息交换，任何额外的错误场景必须在消息传递层设计中解决。
  * 同步事件
* 使用 websocket 场景
  * 快速的反应时间：比如实时聊天
  * 实时更新：实时更新资源的状态
  * 点对点消息
  * 高频消息传递：websocket 只在建立连接时有较大开销，后续消息传递没有额外开销。虽然 HTTP 1.0 允许多个请求复用一个连接，通常会有小的超时时间用于控制资源消耗。websocket 避免了建立了解和发送 HTTP 头部信息的开销，带来大的性能提升，但这不一样走极端哇。

socket.io 特性
* 自动降级 HTTP 长轮询
* 自动重连
* 包缓冲区
* 确认机制，支持 timeout 设置
  * emit 函数最后传递一个回调，服务端确认收到后，回调用它
  * on 函数回调函数 payload 中最后是一个函数，可手动调用它表示确认收到，支持传参，默认会自动无参调用（maybe）
* 广播
* 多路复用：支持多 namespaces

关于断开连接
* 即使是在一个稳定的互联网连接上，断开连接也是常见的和预期的

sessionId and socketId，连接建立具体步骤
1. 握手成功后，服务端会返回 sessionId，这在后面并发的 http 交流都会被用到
2. 使用 sessionId 请求建立连接，这里可提交需要 auth 信息
3. 通过后，请求获取 socketId
4. 建立 websocket 连接
5. 第一个 HTTP 长轮询请求，一旦建立 WebSocket 连接就关闭

socket.io redis adapter
* 服务于多个 servers 场景，负责将事件广播给所有或一部分客户端
* 即使有了 adapter，当使用多节点服务以及 HTTP 长轮询机制时，sticky sessions 仍然需要

资料
* [When to use a HTTP call instead of a WebSocket (or HTTP 2.0)](https://blogs.windows.com/windowsdeveloper/2016/03/14/when-to-use-a-http-call-instead-of-a-websocket-or-http-2-0/)
