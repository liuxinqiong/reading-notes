Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

如何判断循环引用
* Set WeakSet
* Map WeakMap

yield 报错后不再进入问题

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具

书写模块时，关于模块是否应该依赖外部东西时决策
* 模块的封闭性大于冗余性
* 或外部依赖模块内部的某些东西
* 如果必须要依赖，模块内部对外部依赖封装 wrapper

## 前端代码共享方案
如何在多个仓库间复用代码，关于这个话题讨论越来越多。

这里介绍复用代码的 5 种方案，代码复用归根到底是一个关于人际沟通的文化问题，最重要的是不忘模块化这一初心
* Bit
* NPM with/without Lerna
  * 为多个软件包配置和维护多个仓库可能很困难，因此有些项目采用多软件包仓库（monorepo），Lerna 之类的工具可以帮助我们将项目转换为软件包仓库
  * 不同的包放不同的仓库，这样做很快就会超出掌控范围，很难在项目间更新变更。Lerna 可以帮助你在单个仓库中管理、配置多个软件包，统一构建和测试流程，从而减少不同的包放不同的仓库带来的麻烦。这样你就不用为不同的软件包配置、维护不同的仓库了。
  * 独立发布
* 公共库
  * 优势在于可以把所有需要复用的代码放在一个仓库里，这样比采用多个小软件包更容易维护和分发。和 Lerna monorepo 的区别在于，公共库会作为一个软件包使用。
  * 把所有需要复用的代码放在一个仓库里有一个问题，使用时需要将整个公共库引入项目，会引入冗余的代码、依赖，也会增加项目的大小和复杂度。这也导致更新和修改非常笨拙，任何变更都需要项目所有者更新整个软件包。
  * 公共库内组件的可发现性也不好。这些问题导致 Lodash 之类的社区花了很长时间和很多精力将组件拆成单独软件包发布到 NPM 上。
  * Lerna 可以将公共库仓库中的组件拆成多个软件包。Bit 可以用来分发公共库中的组件。
* Git sub-module
  * sub-module 不会管理模块间的依赖关系
  * 父目录 pull 不会自动更新 sub-module
  * 如果 sub-module 不稳定，更改时多次提交会很繁琐
  * 有各种工具为 sub-module 添加了额外的自动化，比如 git-subtree
* 复制粘贴代码

使用 Bit 可以轻松将 multi-repo 切换成 multi-package monorepo
* 你不需要更改仓库中的任何代码
* 所有的内部依赖会被 Bit 自动管理
* 不需要为每个 package 配置 build/test 环境
* 增加复用代码的可发现性
* 支持 monorepos 之间的双向共享和协作

multi-repo 的优势
* 清晰的所有权：小团体可以独立的开发和部署
* 更好的伸缩性：小仓库可以更好的被管理，更少的合并地狱，团队不需要与其他团队协调，从而更快地执行
* 窄克隆：大部分版本控制工具，比如 Git 不支持部分克隆，对于大型的代码库，clones、pulls、pushes 会花费更多的时间

multi-repo 的劣势
* 实施代码标准化是一项挑战
* 导致代码评审困难，因为缺失上下文

monorepo：服务可以独立开发和部署，所有服务代码在同一个仓库中，带来的好处有
* 更好的开发体验：开发者可以轻松的在本地运行整个平台，可以帮助开发者更好的理解服务之间是如何一起工作的，开发者可以更好的在本地发现 bug
* 减少代码复杂度：高级开发者可以很容易的在所有服务之间推行标准化，因为可以很容易的跟踪到所有的请求和更改
* 更有效的代码评审
* 更容易重构：重构工具更好的发挥作用

> 我们转向 monorepo 的最大好处是我们没有放弃微服务架构的任何优势。

Lerna 的问题
* 现有代码仓库的重组
* 手动维护多个 packages 的配置和依赖树

为解决代码复用而衍生出来的一系列工具
* Bit：方便共享和管理组件
* Lerna：管理和发布从一个仓库中发布多个包
* StoryBook：可视化组件

### 资料
* [Our journey to microservices: mono repo vs multiple repositories](http://blog.shippable.com/our-journey-to-microservices-and-a-mono-repository)

## 关于选择态
Three.js 官方的 BoxSelection 使用的 material.emissive 的方式来添加选择态
* emissive 默认为黑色，表示不发光
* 选中时设置为白色，取消选中时恢复为黑色，但这个不具备普适性

其他选中态方案
* 修改 material 改为修改 material 对应的颜色，然后 original color 存储在 material.userData 中
* 修改外边框的方式实现，使用 outline 后置处理器

## React 17/18
React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 对于 SSR 非常友好
* 自动批量更新
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的UI更新。
  * 紧急更新：比如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹
* SuspenseList
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* useDeferredValue
  * defer 推迟

函数式组件与类组件有何不通
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

> 时间切片、Suspense、并发模式
