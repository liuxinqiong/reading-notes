## misc
Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

dva dispatch yield 生成器函数异常中断，无法继续调用
* 在生成器函数中，哪怕是一点报错。都会导致程序无法再次执行。这是 yield 的特性导致的
* 解决方式将所有报错回避，并做好错误交互，比如多判断变量合法性或使用 try-catch

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具
* spinner：命令行 loading
* npmlog：log 工具
* semver：版本合法性检查工具

书写模块时，关于模块是否应该依赖外部东西时决策
* 模块的封闭性大于冗余性
* 外部依赖模块内部的某些东西：模块暴露多少 API
* 如果必须要依赖，模块内部对外部依赖封装 wrapper

withCredentials 的作用
* 如果遵循同源策略，该属性不会造成任何影响，**永远不会影响到同源请求**
* 要使得该字段生效，服务端必须设置 Access-Control-Allow-Credentials 为 true
* 目的：跨域请求时，cookie 和认证的 HTTP 头信息是否会包含在请求当中，默认为 false，不仅会发送 cookie，还会设置远程主机指定的 Cookie

how to use webworker in cra：workerize-loader

k8s/jenkins/docker/heml

## React 17/18
React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 对于 SSR 非常友好
* 自动批量更新
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的 UI 更新。
  * 紧急更新：比如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹
* SuspenseList
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* useDeferredValue
  * defer 推迟

React 18 新特性
* automatic batching
* transition
* suspense
* hooks
  * useId
  * useTransition
  * useDeferredValue
  * useSyncExternalStore
  * useInsertionEffect

函数式组件与类组件有何不同
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

重点：**时间切片、Suspense、并发模式（Concurrent）**

Vue Hook 不同之处
* 对调用顺序没有要求，由于渲染机制的不同，不会反复调用 Hook 函数，产生的的 GC 压力较小。
* 不用总是考虑 useCallback 的问题，因为模板解析内部会新建 cache 缓存函数，缓存函数内部进行函数调用，因此写内联函数也没关系
* 没有闭包问题，Vue 内部自动依赖关系跟踪确保观察者和计算值始终正确无误

渲染性能优化上的不同
* Vue 抛弃 time slice，模板中区分动态节点和静态节点。事件监听缓存，从而避免不必要子组件更新。运行时特性支持 tree-shaking，没用到的特性代码会被移除
* React 走了另一条道路，既然是 diff 导致问题卡顿，从 CPU 调度的方式解决问题，利用浏览器的空闲时间来做 diff，如果超过了 16ms，有动画或者用户交互的任务，就把主进程控制权还给浏览器，等空闲了继续

支持 SSR 常见问题
* DOM/BOM 确实
  * 将 DOM/BOM 的访问放在 useEffect/useLayoutEffect 中运行
  * 通过 isBrowser 判断
* useLayoutEffect Warning
  * 根据环境动态指定使用 useLayoutEffect 还是 useEffect
* 对于接收 DOM/BOM 属性，使用函数形式传参

React-Refresh 导致的热更新问题
* 热更新机制
  * 在热更新时为了保持状态，useState 和 useRef 的值不会更新
  * 热更新时，useEffect、useCallback、useMemo 等会重新执行
* 如何避免
  * 时刻想起 react-refresh 的怪异行为，想办法避免
  * 添加 `@refresh reset` 注释，但这会导致每次 remount，此时 useState 和 useRef 会被重置


## 项目工程问题
更优雅的方式处理项目环境变量问题
* 不再新建 environments 文件夹，而是通过内置的 `.env` 文件的方式解决
* 研究下是否支持环境扩展，而不是仅限于 development、test、production 环境，通过 env-cmd 进行扩展
* 注意文件之间优先级

有必要在抽出一个 apps 目录将项目和包分离开吗？比如将项目方式在 src 目录下

## 前端研究
### misc
产品 ui 上的提示
* 比如断网提示用户，内容会在联网后自动保存到云端
* 保存中… OR 已经保存到云端等相关说明

设置一个 UI 提示该数据不是最新数据
* 比如使数据透明显示
* 一个正在拉取的 ui 提示

可能的全局状态
* 当前用户
* 当前项目
* 当前方案
* 方案列表

加快传输速度：使用 GraphQL 让客户机只从服务器请求所需的数据

数据模型设计
* 有时候会纠结两个模型之间，谁关联谁的问题，此时可以回归到关系型数据库中外键如何设计
* 针对计算属性，是应该单独请求还是作为字段呢？
* 考虑引入空方案的设计，路由 `plan/0`

类设计类型
* Value Object
  * 纯数据结构，常用于底层数据结构
* Entity
  * 领域模型作为语言的扩展
  * 通常属性非常精简，大量使用接口约束其行为，偶尔使用继承封装更特异化领域对象
  * 警惕数据耦合、方法耦合、超级方法簇？？？
* Service/aggregate
  * 业务逻辑的步骤，常用语模块入口、顶层模块
  * 类名基本上都是以计算过程或者计算者命名，尽可能的精简属性

Shapely 分享
* 性能
  * STRTree
  * 桶方法
* 图形之间的 9 种关系
* 对象组合设计：类 进入某个模式
* 指定某个策略
* Predicator？？
* 职责链模式
* 柯立化类
* 找稳定的因素

路由授权
```ts
export function PrivateOutlet() {
  const auth = useAuth()
  const location = useLocation()

  return auth.user ? (
    <Outlet />
  ) : (
    <Navigate to="/login" state={{ from: location }} />
  )
}
```

### CSS 规范
arco-design 样式方案
* 组件和样式分离
* 每个组件目录下定义 style 目录
  * index.less 文件编写样式
    * 引入全局 theme/default.less 文件，包含色板、间距、边框、圆角等通用全局配置
    * 引入自身 token.less 文件，定义自身支持修改的 token 变量，使用部分 CSS 变量，用于实现动态换肤
  * index.ts 供打包使用
    * 引入上述 index.less
    * 引入全局 style/index.less 文件，除 default.less 之外，包含 CSS 变量、CSS 常规化、mixin 和动画等
* 打包过程
  * 每个组件 style 目录会生成对应的 index.css 和 index.less，以供按需加载使用
  * 会 bundle 所有组件的 index.ts，打包一份整个组件库的 index.css 和 index.less
* 关于主题
  * 平台关于特定组件的样式修改会存在 components 中
  * 基于组件默认的 index.less + 自定义的 theme/variables/component 编译一份新的 arco.css 供使用
* 自己组件沿用 arco 基础样式以确保一致性
  * 是否有办法 figma 审查时直接看到使用了的变量名
  * 官方 Pro 的做法：直接 style 中直接引用 CSS 变量以及复用 themes/<name>/variables.less 定义的变量

目前 CSS 编写存在的问题
* 存在两套 CSS 变量
  * 都回归到使用 arco 的变量
  * 如果需要新增，则平台新增后，更新包
* CSS 智能提示问题
* 主要基础样式种类
* 直接使用 CSS 变量还是有语义的 less 变量
* 是否允许局部定义：不允许

### arco-design-pro
路由鉴权：AuthContext、AuthProvider、useAuth、RequireAuth 组件
* AuthContext 验证信息的上下文（存储当前用户信息、登录、登出方法）
* useAuth 和 AuthProvider 是 AuthContext 的封装
* RequireAuth：未登录则跳转到登录页，或者正常渲染

基本流程参考
* 检查 userStatus cache，判断是否已经登录，如已登录，则查询用户信息，否则跳转登录页
* 注册根路由 `/` 组件 Layout 和登录路由 `/login` 组件 Login
* Layout 组件
  * 初始化导航栏
  * 根据路由初始化左侧菜单
  * 内容区域注册路由
  * 全局 setting 支持设置菜单是否显示、导航栏、底部是否显示
* 监听菜单点击事件，触发路由跳转

代码片段-arco-design-pro
```ts
const dv = new DataView().source(data);
// interval 返回一个 Interval 对象，然后通过链式调用的方式优化传参
view
  .interval()
  .adjust('stack')
  .position('value')
  .color('type', [
    '#249eff',
    '#846BCE',
    '#21CCFF',
    ' #86DF6C',
    '#0E42D2',
  ])
  .label('value', {
    content: (content) => {
      return `${(content.value * 100).toFixed(2)} %`;
    },
  })

// 巧用 cloneElement
{trigger ? (
  React.cloneElement(trigger as React.ReactElement, {
    onClick: () => setVisible(true),
  })
) : (
  <IconButton icon={<IconSettings />} onClick={() => setVisible(true)} />
)}

// 路由参数
export type IRoute = AuthParams & {
  name: string;
  key: string;
  // 当前页是否展示面包屑
  breadcrumb?: boolean;
  children?: IRoute[];
  // 当前路由是否渲染菜单项，为 true 的话不会在菜单中显示，但可通过路由地址访问。
  ignore?: boolean;
};

// 命名：XXXWrapper，PermissionWrapper，满足则渲染 children，否则渲染 backup || null，用于根据权限控制元素的显隐
export default (params: AuthParams, userPermission: UserPermission) => {
  const { requiredPermissions, oneOfPerm } = params;
  if (Array.isArray(requiredPermissions) && requiredPermissions.length) {
    let count = 0;
    for (const rp of requiredPermissions) {
      if (auth(rp, userPermission)) {
        count++;
      }
    }
    return oneOfPerm ? count > 0 : count === requiredPermissions.length;
  }
  return true;
};

type PermissionWrapperProps = AuthParams & {
  backup?: React.ReactNode;
};

const PermissionWrapper = (
  props: React.PropsWithChildren<PermissionWrapperProps>
) => {
  const { backup, requiredPermissions, oneOfPerm } = props;
  const userInfo = useSelector((state: GlobalState) => state.userInfo);

  const hasPermission = useMemo(() => {
    return authentication(
        {requiredPermissions, oneOfPerm},
        userInfo.permissions
    );
  },[oneOfPerm, requiredPermissions, userInfo.permissions]);

  if (hasPermission) {
    return <>{convertReactElement(props.children)}</>;
  }
  if (backup) {
    return <>{convertReactElement(backup)}</>;
  }
  return null;
};

function convertReactElement(node: React.ReactNode): React.ReactElement {
  if (!React.isValidElement(node)) {
    return <>{node}</>;
  }
  return node;
}

export default PermissionWrapper;

// useRequest
export default <T>(url: string, defaultValue: T[]): [boolean, T[]] => {
  const [loading, setLoading] = useState(false);
  const [data, setData] = useState<T[]>(defaultValue);

  useEffect(() => {
    setLoading(true);
    axios
      .get(url)
      .then((res) => {
        setData(res.data);
      })
      .finally(() => {
        setLoading(false);
      });
  }, [url]);

  return [loading, data];
};
```

### RTK Query 学习
将状态从一个管理器复制到另一个管理器是糟糕的
* 将 props 复制到 state
* 将 cache 复制到 local state 或者 global state

RTK Query 是一个完整的缓存方案，你通常不需要将状态 copy 出去，而是让它负责管理数据

RTK Query 支持传递 queryFn
* 使用 queryFn 时会忽略 baseQuery
* 通过设置 queryFn 为 noop，配合 invalidatesTag 实现重新获取其他数据
* 实现一次发送多个请求，这是 query 无法做到的
* transformResponse 不能作用于 queryFn

逻辑拆分：通常推荐仅调用一次 createApi，通过 apiSlice.injectEndPoints 组合多个模块

从 apiSlice 中获取与更新数据
* apiSlice.endPoints.select()
* apiSlice.util.updateQueryData()

extraReducers addMatcher vs addCase
* addCase 是 addMatcher 的特殊化，用于和指定 type 匹配
* addMatcher 传递一个函数作为匹配条件，返回 true 则进入 reducer 逻辑
* apiSlice.endpoints.xxx.matchFulfilled for add matcher
* xxxThunk.fulfilled for add case

useLazyQuery 实现手动派发请求
* 第二参数 preferCacheValue 表示是否使用缓存
* 如果走的缓存，则不会触发 matchFulfilled 动作

createEntityAdapter 复用 CRUD 逻辑
* upsert: update or insert if does not exist
* adapter select 出来的数据是 readonly object
* updateOne 和 updateMany 只能浅层合并更新，对于深层嵌套更新，推荐手动操作

createSelector 帮助优化性能

onQueryStarted
* queryParams
* dispatch/getState/queryFulfilled
* queryFulfilled 可以实现手动更新缓存，而不是重新拉取

根据 endpoints 断定 isLoading 字段，并不考虑到参数

自动切换方案逻辑
* 复制多层方案中的单层方案时，自动切换到新方案
* 生成新多层方案时，自动切换到新方案中的第一个方案
* 删除多层方案时，当前方案置空
* 删除单层方案时，自动切换到下一个

### konvajs
konvajs api guide
* stage.getPointerPosition() 得到当前光标所在坐标
* layer.getIntersection(pos) 得到点相交的图形
* shape.hitFunc 用于自定义命中区域，常用于增加点击区域或自定义区域，以及性能优化
* drop 实现逻辑
  * previousShape 存储之前 shape
  * 移动过程中，当新的 shape 和 previousShape 不同时，previousShape 派发 dragleave 事件，shape 派发 dragenter 事件
  * 值得借鉴的点：并不是在事件过程中去改变物体的样式，而只是手动派发事件，样式修改放在事件中去处理
* 提供 Transformer 类用于实现 scale 和 rotate 的调整
  * enabledAnchors 数组，用于激活哪些锚点
  * rotationSnaps 数组，用户设置捕捉那些角度
  * forceUpdate
* 提供 Tween 用于实现对对象过渡动画
* 提供 Animation 类实现帧动画

性能优化建议
* 优化目标
  * 计算尽可能少
  * 绘制尽可能少
* 相关手段
  * 优化舞台大小
  * 移动端设置 viewport，因为缩放非常影响性能
  * 设置 pixelRatio 为 1，即使在 retina 屏
  * 通过 layer 机制，将对象动静分离
  * 如果 layer 中的对象不需要响应时，则设置 listening(false)
  * 优化移动开销，拖动时将形状移动到专用层，完成时再移回原来的层
  * 使用 shape.cache()，将对象转换为图像，通过绘制图像的方式避免了根据其绘图指令组合形状的开销，对于复杂对象或组时尤为有效
  * 保持对象的顺序，通过设置 shape 的 visible 或 opacity 替换 hide 或 remove 方法
  * 设置 shape.listening(false)
  * 关闭 autoDrawEnabled，手动调用 batchDraw

列表数据存储挺有趣的
* 模板数据：存一个 json 用于访问实际数据，存储一个 preview img 用于预览
* story.history
  * canUndo
  * undo()
  * canRedo
  * redo()
* 使用 timer 定时保存
* lock 机制：关闭 draggable、contentEditable、styleEditable
* 内置使用了 mobx
* 替换内置 api
  * setAPI(key, func)
* 场景设置浮层元素
  * 组件支持设置 position 绝对定位
  * 场景计算当前需要显示的屏幕坐标
* PixiJS 默认使用 WebGL 进行渲染（如果不支持则降级使用 Canvas），在复杂动画方面性能更好
* 字体加载：https://fonts.googleapis.com/css?family=Kavivanar
* 使用原生 html 加载右键菜单
* 使用 web worker 配合 offscreen canvas
* 实现小预览窗口
  * 方式一：克隆后作为图片使用
  * 方式二：从最新状态生成
* buildAnchor
  * 新建 Circle
  * 监听移入，移出事件，更新交互样式
  * 监听移动事件，更新坐标

定时保存示例
```js
// write a function for throttle saving
let timeout = null;
const requestSave = () => {
  // if save is already requested - do nothing
  if (timeout) {
    return;
  }
  // schedule saving to the backend
  timeout = setTimeout(() => {
    // reset timeout
    timeout = null;
    // export the design
    const json = store.toJSON();
    // save it to the backend
    fetch('https://example.com/designs', {
      method: 'POST',
      body: JSON.stringify(json),
    });
  }, 1000);
};

// request saving operation on any changes
store.on('change', () => {
  requestSave();
});
```

MBR，Minimun Bounding Rectangle：MBR 本身通过 x、y 坐标容易计算，计算 MBR 相交也十分简单高效，适用于应用在索引结构中

R-Tree 特点（R 表示 Rectangle）
* 由单个根、内部节点和叶节点组成，所有叶子节点都位于同一层，因此 R 树为平衡树
* 根包含指向空间域中的最大区域的指针
* 父节点包含指向子节点的指针，其中子节点的区域与父节点的区域完全重叠
* 叶节点包含到当前对象的 MBR 数据
* MBR 最小边界区域是指围绕所考虑的区域/对象的最小边界框参数
* 子节点数量有限制即存在节点分裂和合并

R 树与 B 树最显著的区别在于 R 树在非一维空间使用 MBR 描述节点的上下界，无法像 B 树节点一样准确适应子节点的分布。虽然通过通过 MBR 提高了计算和求交的效率，不过这也势必牺牲了空间利用率（父节点包含了空白区域）及查询效率（兄弟节点 MBR 可能会重叠）

B 树是一棵平衡树，它是把一维直线分为若干段线段，当我们查找满足某个要求的点的时候，只要去查找它所属的线段即可。这种思想其实就是先找一个大的空间，再逐步缩小所要查找的空间，最终在一个自己设定的最小不可分空间内找出满足要求的解。

常用空间查询方式
* 窗口查询：给定一个查询窗口（通常是一个矩形），返回与查询窗口相重叠的物体
* 点查询：给定一个点，返回包含这个点的所有几何图形

R-Tree 与四叉树（Quad-trees）比较
* 四叉树需要平铺层优化，而 R-Tree 不需要任何此类优化
* 四叉树可以在现有的 B-Tree 上实现，而 R-Tree 遵循与 B-Tree 不同的结构
* 四叉树空间索引创建速度比 R-Tree 快
* 对于最近邻居查询，R-Tree 比四叉树快，而对于窗口查询，四叉树比 R-Tree 快

通用规则
* 点索引可以使用网格索引 KDTree（k-dimensional tree)）
  * tree 的每一层，依次选一个维度把空间二分
  * 仅限点，不支持矩形
  * 静态的，不支持增删元素
  * 索引快 5-8 倍
* 线面索引使用 STRTree（Sort-Tile-Recursive Tree 递归网格排序） 或者 QuadTree
  * QuadTree 依次将每个子空间分层 4 份，直到不需要再分位置
  * 支持点，也支持矩形，用于表示任何几何对象

Grid Index：将要考虑的空间铺好网格，一遍快速锁定区间。适合做近邻搜索

当面对大规模的空间数据时，一个最有效也是最重要的方法就是空间索引（Spatial Index）。

空间索引一系列可以通过排列几何数据来进行高效索引的算法，例如查询本区域所有的建筑，距此点最近的1000个加油站等问题，要求结果能在几毫秒内返回，即使所要查询的目标由几百万个。

空间数据有两种基础查询类型：最相邻查询和范围查询

最原始的处理方式
* 最朴素的方法：遍历计算再排序
* 针对复杂图形，如不规则多边形，则先转换为简单的包围盒判断，再进一步做复杂判断
* 网格查表法
* 建立空间索引

大规模地解决这两种问题时就需要将数据点转换到空间索引中。由于数据转变的频率会远远少于查询的频率，因此将数据转变到空间索引的花销对于之后的快速搜索是非常值得的。

几乎所有的空间数据结构都具有相同的原理，以实现有效的搜索：分支和绑定（https://en.wikipedia.org/wiki/Branch_and_bound）。数据被排列在一个树状结构中，因此当在某一节点的某一分支不符合查询条件时，该分支之下的所有的节点都可被略过。

K 相邻查询
* 对于特点查询点，如何判断哪棵子树上的节点与该节点最相邻呢？最相邻的点可能在树中里查询点很远的位置
* 优先队列：维护一个有序列表，将最小的元素以很快的速度提取出来
  * 与查询点更临近的矩形框可能有我们想要搜索的点，按从近到远的顺序将最大的矩形框排在队列中，从顶层开始进行搜索
  * 打开相邻的矩形框，从队列中移除，并将它的孩子节点放到队列中与其相邻的位置上
  * 重复上述步骤，当从队列中移除的相邻项是真正的点，而不是矩形框时，这就是我们要查找的点，队列顶部的第二个点就是第二个最相邻的点，依次类推
  * 扩展：不仅实现点对点，也可以扩展到线对点等

GIS 所表现的地理数据多维性使得传统的 B 树索引并不适用，因为 B 树所针对的字符、数字等传统数据类型是在一个良序集之中，即都是在一个维度上，集合中任给两个元素，都可以在这个维度上确定其关系只可能是大于、小于、等于三种，若对多个字段进行索引，必须指定各个字段的优先级形成一个组合字段，而地理数据的多维性，在任何方向上并不存在优先级问题，因此B树并不能对地理数据进行有效的索引，所以需要研究特殊的能适应多维特性的空间索引方式。

记录每次建立 tree 和查询节点的耗时日志。

空间筛选的大致流程基本都是
1. 矩形框初筛，通过待查询矩形框与数据外包矩形相交快速判断
2. 对筛选后缩小了的数据集进行相交、包含、相切、相离等精准判断

空间索引的算法优劣，主要在于如何减少无关数据的访问次数

空间数据至少是二维数据，常用的一维索引（如 BTree/Bitmap 索引等）无法满足需求，常用的空间索引算法有 BSP树、KD树、R树、R+树、四叉树和 CELL树。

资料集合
* [深入理解空间搜索算法 ——数百万数据中的瞬时搜索](https://www.cnblogs.com/arxive/p/8138586.html)
* [A dive into spatial search algorithms](https://blog.mapbox.com/a-dive-into-spatial-search-algorithms-ebd0c5e39d2a)