Diff 算法
* React 技术揭秘：https://react.iamkasong.com/
* https://zhuanlan.zhihu.com/p/20346379
* https://github.com/aooy/blog/issues/2
* http://blog.vjeux.com/2013/javascript/react-performance.html

响应式设计 - 小狄

如何判断循环引用
* Set WeakSet
* Map WeakMap

yield 报错后不再进入问题

node 书写命令行工具
* commander：命令行开发工具
* chalk：命令行样式风格控制器
* inquirer：交互式命令行工具

## 前端代码共享方案
如何在多个仓库间复用代码，关于这个话题讨论越来越多。

这里介绍复用代码的 5 种方案，代码复用归根到底是一个关于人际沟通的文化问题，最重要的是不忘模块化这一初心
* Bit
* NPM with/without Lerna
  * 为多个软件包配置和维护多个仓库可能很困难，因此有些项目采用多软件包仓库（monorepo），Lerna 之类的工具可以帮助我们将项目转换为软件包仓库
  * 不同的包放不同的仓库，这样做很快就会超出掌控范围，很难在项目间更新变更。Lerna 可以帮助你在单个仓库中管理、配置多个软件包，统一构建和测试流程，从而减少不同的包放不同的仓库带来的麻烦。这样你就不用为不同的软件包配置、维护不同的仓库了。
  * 独立发布
* 公共库
  * 优势在于可以把所有需要复用的代码放在一个仓库里，这样比采用多个小软件包更容易维护和分发。和 Lerna monorepo 的区别在于，公共库会作为一个软件包使用。
  * 把所有需要复用的代码放在一个仓库里有一个问题，使用时需要将整个公共库引入项目，会引入冗余的代码、依赖，也会增加项目的大小和复杂度。这也导致更新和修改非常笨拙，任何变更都需要项目所有者更新整个软件包。
  * 公共库内组件的可发现性也不好。这些问题导致 Lodash 之类的社区花了很长时间和很多精力将组件拆成单独软件包发布到 NPM 上。
  * Lerna 可以将公共库仓库中的组件拆成多个软件包。Bit 可以用来分发公共库中的组件。
* Git sub-module
  * sub-module 不会管理模块间的依赖关系
  * 父目录 pull 不会自动更新 sub-module
  * 如果 sub-module 不稳定，更改时多次提交会很繁琐
  * 有各种工具为 sub-module 添加了额外的自动化，比如 git-subtree
* 复制粘贴代码

使用 Bit 可以轻松将 multi-repo 切换成 multi-package monorepo
* 你不需要更改仓库中的任何代码
* 所有的内部依赖会被 Bit 自动管理
* 不需要为每个 package 配置 build/test 环境
* 增加复用代码的可发现性
* 支持 monorepos 之间的双向共享和协作

multi-repo 的优势
* 清晰的所有权：小团体可以独立的开发和部署
* 更好的伸缩性：小仓库可以更好的被管理，更少的合并地狱，团队不需要与其他团队协调，从而更快地执行
* 窄克隆：大部分版本控制工具，比如 Git 不支持部分克隆，对于大型的代码库，clones、pulls、pushes 会花费更多的时间

multi-repo 的劣势
* 实施代码标准化是一项挑战
* 导致代码评审困难，因为缺失上下文

monorepo：服务可以独立开发和部署，所有服务代码在同一个仓库中，带来的好处有
* 更好的开发体验：开发者可以轻松的在本地运行整个平台，可以帮助开发者更好的理解服务之间是如何一起工作的，开发者可以更好的在本地发现 bug
* 减少代码复杂度：高级开发者可以很容易的在所有服务之间推行标准化，因为可以很容易的跟踪到所有的请求和更改
* 更有效的代码评审
* 更容易重构：重构工具更好的发挥作用

> 我们转向 monorepo 的最大好处是我们没有放弃微服务架构的任何优势。

Lerna 的问题
* 现有代码仓库的重组
* 手动维护多个 packages 的配置和依赖树

为解决代码复用而衍生出来的一系列工具
* Bit：方便共享和管理组件
* Lerna：管理和发布从一个仓库中发布多个包
* StoryBook：可视化组件

### 资料
* [Our journey to microservices: mono repo vs multiple repositories](http://blog.shippable.com/our-journey-to-microservices-and-a-mono-repository)

## 原生 Canvas API
CanvasRenderingContext2D 原生 API
* 描边类绘制
  * strokeStyle
  * stroke(path2D?)：描边当前子路径或指定 path2D
  * strokeXXX
* 填充类绘制
  * fillStyle
  * fill(path2D?)：填充当前子路径或指定 path2D
  * fillXXX
* 路径
  * beginPath：清空子路径列表开始一个新的路径
  * moveTo
  * lineTo/rect/arc/arcTo/……
  * closePath：尝试闭合图形，如果已经封闭或者只有一个点，则不作任何操作
* 线型
  * lineWidth
  * lineCap
  * lineJoin
  * setLineDash
* 文本样式
  * font
  * textAlign
  * textBaseline
  * direction
* 阴影
  * shadowBlur
  * shadowColor
  * shadowOffsetX
  * shadowOffsetY
* 合成
  * globalAlpha
  * globalCompositeOperation
* 像素控制
  * createImageData
  * getImageData
  * putImageData
* 状态：线的样式、填充样式、阴影样式、文本样式
  * save
  * restore
* 变换
  * rotate
  * scale
  * translate
  * transform 叠加变换
  * setTransform 设置变换矩阵
  * **特别注意：多次调用 rotate、scale、translate 是对当前状态的叠加效果**
* 其他
  * clearRect
  * clip

使用 clearRect 清空画布的场景
* 没有使用 transform 的 context
* 如果使用了 transform 的 context，则需要跟踪实际边界

或者使用如下方式
```js
// Store the current transformation matrix
context.save();

// Use the identity matrix while clearing the canvas
context.setTransform(1, 0, 0, 1, 0, 0);
context.clearRect(0, 0, canvas.width, canvas.height);

// Restore the transform
context.restore();
```

每次调用 getContext('2d') 获取 context，会是一个全新的 context

重设 canvas 的 width、height 会重置 canvas 的状态，比如 transformations、lineWidth、strokeStyle 等。注意：不要使用这种方式去清空画布，因为相比 clearRect 而言，非常低效

> 当 canvas 容器 display 为 none 时，render 通常会导致异常

请求时序控制
```tsx
function App() {
  const [fetching, setFetching] = React.useState(false);
  const [options, setOptions] = React.useState<ValueType[]>([]);
  const fetchRef = React.useRef(0);

  const debounceFetcher = React.useMemo(() => {
    const loadOptions = (value: string) => {
      fetchRef.current += 1;
      const fetchId = fetchRef.current;
      setOptions([]);
      setFetching(true);

      fetchOptions(value).then(newOptions => {
        if (fetchId !== fetchRef.current) {
          // for fetch callback order
          return;
        }

        setOptions(newOptions);
        setFetching(false);
      });
    };

    return debounce(loadOptions, debounceTimeout);
  }, [fetchOptions, debounceTimeout]);
}
```

noUncheckedIndexedAccess -- TS

NumericInput 处理工作流：https://codesandbox.io/s/numericinputdemo-os3rr

书写模块时，关于模块是否应该依赖外部东西时决策
* 模块的封闭性大于冗余性
* 或外部依赖模块内部的某些东西
* 如果必须要依赖，模块内部对外部依赖封装 wrapper

Proxy
```js
// src/setupProxy.js
// eslint-disable-next-line import/no-extraneous-dependencies
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = (app) => {
  app.use(
    '/api',
    createProxyMiddleware({
      target: 'https://hotfix.xkool.org',
      changeOrigin: true,
      headers: { authorization: 'Basic eGtvb2w6eGtvb2xAMDQxNQ==' },
    }),
  );
};
```

标注需求
* component
  * ElementPropertyPanel
  * NoteSymbolPanel
  * ObjectOperateBar
* commands
  * CommandManager
* drawXXX
* eventDispatcher
* handler
  * deleteHandler hard code
  * canvasManager
    * init CopyPasteHandler EventHandler CommandManager
    * duplicate event emitter

组件拖拽
* 有很多不同的事件可以帮助我们实现，比如
  * Drag 事件
  * Mouse 事件
  * Pointer 事件
* 注意细节：自身的 down 事件，搭配全局，比如 mask 或 window 的 up 和 move 事件，因为拖动过程中会离开元素，全局作用在自身的话，会中断
* Drag 事件
  * 典型场景：拖动一个元素到特定区域时，毫无疑问只用 drag 事件，通常用于实现数据的移动，而不是元素，比如可拖动列表
  * onDrag
  * onDragStart
  * onDragEnd
  * onDragEnter：当拖动一个元素进入一个有效的 drop 目标
  * onDragLeave：当拖动一个元素离开一个有效的 drop 目标
  * onDragOver：在被拖动元素在一个有效的 drop 目标拖动时
  * onDrop：拖动过程中，释放鼠标键时触发此事件
* Mouse 事件
  * 典型场景：实际移动或转换元素到一个新的位置
  * onMouseDown
  * onMouseUp
  * onMouseMove
* Pointer 事件
  * 本质上和 Mouse 类型，但他是跨硬件的，也就是说不仅 mouse 交互触发，还包括其他指针设备，比如手指触摸或笔触摸
  * onPointerDown
  * onPointerUp
  * onPointerMove
* 通过 CSS 属性达到修改位置的目的
  * transform > translate
  * top/left

## SU 模型
导出 skp 格式模型并可以自行控制范围
* SketchUp 不支持打开 obj 格式文件 - 这就很迷

导入 skp 模型并参与日照计算
* SketchUp 支持导出 obj 格式
* 模型的准确定位问题

有无其他解决方案
* 必须是 skp 格式吗，有没有其他可能呢

问题：
* SU 模型中只有周边数据吗？

条件准备：
* 提供一个有周边建筑的 skp 文件用于测试

## 对象组件面板
1. 组件关系、目录整理
2. 任务清单
  * 组件之间可能的优化点

## 穿透问题
Three.js 渲染大致分为如下几部
1. 清空当前帧缓冲区，更新MVP矩阵；
2. 将物体分为透明和不透明两类，按照离摄像机从近到远排序（也可在 Object3D 单独设置renderOrder）；
3. 根据灯光信息，阴影计算，如果有开启平面裁剪就对进行剪裁；
4. 开始逐个渲染物体，按以下顺序，背景、不透明物体、透明物体；
5. 渲染前后还有两个类似于生命周期的回调函数，onBeforeRender 和 onAfterRender；
6. 最后将深度、模版测试、多边形偏移恢复默认。

在 three.js 中，使用深度缓冲（Z-Buffer）来完成场景可见性计算，即确定场景哪部分可见，哪部分不可见。深度缓冲（Z-Buffer）是一个二维数组，其中的每一个元素对应屏幕上的一个像素，如果场景中的两个模型在同一个像素生成渲染结果，那么图形处理卡就会比较二者的深度，并且保留距离观察者较近的物体在该像素点的渲染结果，这样就形成了近的模型遮挡远的模型的结果。

深度缓冲（Z-Buffer）是一个二维数组，但是数组的元素类型却可以不同，不同的元素类型代表着不同的精度。这和颜色的精度很像，比如 GIF 图像最多用 8bit 保存一个颜色，也即 GIF 最多支持 256 种色彩。以此类推，如果深度缓冲的也用 8bit 来保存一个像素的深度，那就是说该深度缓存只有 256 个深度级别。在 three.js 中只实现了一种深度缓冲，但是在例子中，又实现了一个精度更高的深度缓冲（logarithmicdepthbuffer），可以看[示例 webgl_camera_logarithmicdepthbuffer](https://threejs.org/examples/?q=webgl_camera_logarithmicdepthbuffer#webgl_camera_logarithmicdepthbuffer)

Z-Fighting 问题：当场景中的两个模型在同一个像素生成的渲染结果对应到一个相同的深度值时，渲染器就不知道该使用哪个模型的渲染结果了，或者说，不知道哪个面在前，哪个面在后，于是便开始“胡作非为”，这次让这个面在前面，下次让那个面在前面，于是模型的重叠部位便不停的闪烁起来。

解决 Z-Fighting 有两个思路
* 让各模型渲染结果不要在同一个像素出现相同深度值
* 人为设置渲染顺序，这样即使出现相同深度值，也能正确渲染

大致有如下解决办法
* 别让模型靠的那么近，手动设置一定的偏移
* 设置合适的 near 和 far 值，在创建相机的时候，会有 near 和 far 两个参数，用来设置相机的近平面和远平面。这个两个参数其实和深度缓冲（Z-Buffer）也密切相关，深度缓冲其实是非线性的，靠近相机的地方精度更高
* 设置多边形偏移，在 material 定义了三个多边形偏移相关的属性
  * polygonOffset 是否开启多边形偏移
  * polygonOffsetFactor 多边形偏移因子
  * polygonOffsetUnits 多边形偏移单位
  * 当发生两个面深度值相同时，设置了 polygonOffset 的面便会向前或向后偏移一小段距离，这样就能区分谁前谁后了
  * 当 polygonOffsetFactor 和 polygonOffsetUnits 的都是正值时，向远离相机的方向偏移，当两者都是负值时，向靠近相机的地方偏移
  * 细节解释参考：[Z fighting & polygon offset](https://sites.google.com/site/threejstuts/home/polygon_offset)
* 设置 renderOrder
  * Object3D 对象定义一个 renderOrder 属性，指定对象的渲染顺序，小的先渲染，大的后渲染
  * 设置完 renderOrder 之后，就算两个面有同样的深度，但是因为有渲染顺序，后渲染的面会覆盖掉先渲染的面。也因为这样，设置正确的渲染顺序很重要。
* 使用 logarithmicDepthBuffer 缓冲（自己项目中开启后，还是会存在问题）

在 three.js 中设置 renderOrder 不会导致可渲染对象处于“顶部”。它只是控制呈现顺序。如果某些对象是透明的，它可能是一个有用的工具。如果场景中的所有对象都是不透明的，那么改变渲染顺序(在典型的用例中)将不会影响渲染输出。

其实上面的话，还是没明白 renderOrder 的作用。经查阅由发现和 sortObjects 属性相关
* sortObjects 设置 false 物体的渲染顺序将会由他们添加到场景中的顺序所决定，适合大部分场景
* 给特定的物体设置 object.renderOrder 指定它的渲染顺序，默认 renderOrder 为 0

不好意思，我设置后还是没啥用，这里有个例子[transparent-objects-in-threejs](https://stackoverflow.com/questions/15994944/transparent-objects-in-threejs/15995475#15995475)，有空在理解一下

还有地方提到了，material.depthWrite 属性？？？我试用好像没啥效果呀
* 渲染此材质是否对深度缓冲区有任何影响，默认为 true
* 在绘制 2D 叠加时，将多个事物分层在一起而不创建 z-index 时，禁用深度写入会很有用

解决方式：通过 clearDepth 清除深度缓存
```js
object3D.onBeforeRender = (renderer) => {
  renderer.clearDepth();
};
```

## 关于选择态
Three.js 官方的 BoxSelection 使用的 material.emissive 的方式来添加选择态
* emissive 默认为黑色，表示不发光
* 选中时设置为白色，取消选中时恢复为黑色，但这个不具备普适性

可能性：选取态通过添加外边框的方式实现

## typescript
入参类型声明：this 的作用