## 大纲
前端性能优化大纲
* 资源的合并与压缩
* 图片解编码原理和类型选择
* 浏览器渲染机制
* 懒加载预加载
* 浏览器存储
* 缓存机制
* PWA
* SSR

## 原理
Web前端性能优化的关键就是理解浏览器的一个请求从发送到返回都经历了什么。从而得出潜在的优化点
* dns 是否可以通过缓存减少 dns 查询时间
* 网络请求的过程走最近的网络环境
* 相同的静态资源是否可以缓存
* 能否减少 http 请求大小
* 减少 http 请求
* 服务端渲染

## 资源的合并与压缩
目的是减少 http 请求数量和减少请求资源的大小。
* html 压缩
* css 压缩
* js 压缩
* 文件合并
* 开启 gzip

> 不要觉得压缩下空格、换行、注释等效果不明显，但对于流量大的公司而言，每一点优化都是有意义的，节省巨大的流量费用。

合并文件可能存在的问题
* 首屏渲染问题
* 缓存失效问题

因此合并文件更推荐
* 公共库合并
* 不同页面的合并
* 具体情况具体分析

## 图片相关
图片格式
* JPG：有损压缩，压缩率高，不支持透明
* PNG8/PNG24/PNG32：支持透明
  * PNG8：256色+支持透明
  * PNG24：2^24色+不支持透明
  * PNG32：2^24色+支持透明
* webp：压缩程度更好、支持透明
* svg：代码内嵌、相对较小、图片样式相对简单

相关方式
* 图片压缩
* CSS雪碧图：需要关注文件大小，不要太大
* image inline：base64
* 使用矢量图：减少请求

## js与css装载与执行
HTML 渲染过程的特点
* 顺序执行、并发加载
  * 可以将 HTML 文件理解为函数的入口，HTML 的词法分析是从上到下顺序执行的
  * HTML 中引入的外部资源是并发请求的，但对单个域名会存在并发上限
* 是否阻塞
  * CSS head 中阻塞页面的渲染
  * CSS 不阻塞外部脚本的加载，但会阻塞js的执行
  * 直接引入的 js 阻塞页面的渲染
  * js 不阻塞资源的加载
  * js 顺序执行，阻塞后续 js 逻辑的执行
* 依赖关系
  * 页面渲染依赖 CSS 加载
  * js 执行顺序的依赖关系
  * js 逻辑对于 dom 节点的依赖关系
* 引入方式
  * 直接引入：阻塞
  * defer：dom 已经构建完成，且顺序执行
  * async
  * 异步动态引入 js

加载和执行的一些优化点
* css样式表置顶
* 用 link 代替 css @import：新版本浏览器已不存在相关性能问题
* js 脚本置底
* 合理使用 js 的异步加载能力

## 懒加载与预加载
懒加载：很多时候都是针对图片而言的，尤其是电商网站。

预加载：和懒加载相反，在使用之前提前请求，提升用户体验。
* 使用 img src+display none 的方式
* 使用 js Image 对象
* 使用 XMLHttpRequest，但会存在跨域问题
* 使用 PreloadJS 库

## 回流和重绘
回流
* 当 render tree 中的一部分因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就称为回流 reflow
* 当页面布局或几何属性改变时就需要回流

重绘： 当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color，则称为重绘

触发页面重布局
* 盒子模型相关属性
* 定位属性及浮动
* 改变节点内部文字

新建 DOM 的过程
* 获取 DOM 后分隔为多个图层
* 为每个图层的节点计算样式结果
* 为每个节点生成图形和位置
* 将每个节点绘制填充到图层位图中
* 图层作为纹理上传到GPU
* 符合多个图层的页面上生成最终屏幕像素

> 将频繁重绘回流的元素单独作为一个独立图层，那么这个 DOM 元素的重绘回流的影响只会在这个图层之中。开发者工具 Layers 可以查看当前页面所有图层情况，Rendering 查看正在重绘的元素

创建图层的方式
* 3D 或透视变换的 CSS 属性
* video 节点
* canvas 节点
* 对自己的 opacity 做 CSS 动画或使用一个动画变换的元素
* 拥有加速 CSS 过滤器的元素
* 元素有一个包含复合层的后代节点
* 元素有一个 z-index 较低且包含一个复合层的兄弟元素

常用的手动新建图层方式
* transform
* will-change

实战优化点
* 使用 translate 代替 top
* 使用 opacity 代替 visibility
* 不要一条一跳修改 DOM 的样式，预先定义好 class，然后修改 DOM 的 className
* 把 DOM 离线后修改，比如先 display 为 none，然后在修改 100 次，最后再把它显示出来
* 不要把 DOM 节点的属性值放在一个循环里当成循环里的变量，如 offsetHeight、offsetWidth
* 不要使用 table 布局，可能一个很小的改动会造成整个 table 重新布局
* 动画实现的速度的选择
* 对于动画新建图层
* 启动 GPU 硬件加速

## 浏览器存储
cookie 需要设置过期时间，大小 4kb 左右，支持设置 httponly 限制 js 读写。关键点：对于静态资源，通常是不需要 cookie 信息的，会造成 cdn 流量损耗。解决办法：cdn 的域名和主站的域名分开。

LocalStorage 大小为 5 mb 左右。SessionStorage 同样大小为 5mb 左右，是会话级别的浏览器存储。

IndexDB
* 用于客户端存储大量结构化数据
* 使用索引来实现对该数据的高性能搜索

pwa
* 可靠性：在没有网络的环境下也能提供基本的页面访问，而不会出现未连接到互联网的页面
* 快速：针对网页渲染及网络数据访问有较好优化
* 融入（Engaging）：应用可以被增加到手机桌面，并且有普通应用一样有全屏、推送等特性

service worker
* 一个脚本，浏览器独立于当前网页，将其在后台运行，为实现一些不依赖页面或用户交互的特性打开一扇大门
* 在未来这些特性将包括推送消息、背景后台同步、地理围栏定位
* 推出的第一首要特性：拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应
* 事件驱动：install、fetch
* 相关 api：postMessage

## 缓存优化
基于 HTTP 的强缓存和协商缓存。

## SSR
利用服务端渲染优化首屏渲染速度。

## HTTP2
