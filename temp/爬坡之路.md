## 个人计划
迎来一段空闲时间，除了整理下自己的心情之外，更重要的是对接下来个人发展有一个完整的规划，大致分为如下几个方面
* 专业能力
* 团队能力

## 专业能力
专业能力的提高
* the usage of jsts
* the usage of three
* editor pro
  * 从 fabric.js、three/editor 总结设计思想
  * 结合项目中的实际痛点
  * 插件化开发
* React
  * 拉勾教育 - React 源码分析
  * 极客时间 - ToyReact
  * 开课吧 - React 源码
* 可视化
  * Three.js 跳一跳
  * 极客时间 - 可视化
* 设计模式
  * geek tutorial
  * mooc video
* 工程化
  * axios
  * antd

## 团队能力
爬坡之路 - 从解决单点问题变成系统性方法，从服务自己变成服务团队，从一次性开发变成持续性输出
* 从前局限在专业解决问题
  * 性能优化、框架理解、专业领域（Node.js/Canvas/WebGL……）
  * 跨界与尝鲜（跨后端、跨客户端、尝试 WebAssembly……）
* 现在应该更多的考虑如何更好的帮助团队，如何提高团队协作效率
  * 工具和平台化建设（order matters）
    * 代码管理、开发测试、代码编译、项目构建
    * 模块管理、部署管理、测试支持
    * 性能检测、性能分析、安全扫描、规范约束
    * 统计分析、运营支撑
  * 流程和规范化
    * 结构的规范：合理的分层和组件化是非常必要的
    * 编码的规范：Code Review + 自动化工具 + 文档工具
    * 流程的规范：项目的评审、研发、测试与发布
    * 规范的落地：不时回顾是否切实的落地
  * 安全意识
    * 不能有低级代码安全问题：比如 xss 和 csrf
    * 大型运营活动需求，要有容灾意识和备份，要有可选备用方案
    * 尝试使用工具化来解决和预防安全问题
  * 工程实施有不同的程度，**从低到高分成三个阶段**
    * 纯管理：容易执行不到位
    * 制度化：规则代替人的命令，CheckList，定期 Review
    * 自动化：重要的操作路径上设计规则
  * 团队合作

对需求的思考
* 首先了解为什么要做这个需求，它的背景是什么，能带来多大的价值？
* 这个功能在当前的系统是否已经实现了？如果实现了，是否可以复用，如果不能复用，差别在哪里？
* 这个功能除了满足当前的需求，还可以举一反三用到别处吗，是否可以抽出公用业务组件？
* 这个需求是一次性的需求还是长期的，后期会怎么发展？
* 技术上实现的成本高不高，如果高的话，是不是可以选最痛的、优先级最高的做，然后小步迭代？

UML（统一建模语言），有三个主要的模型
* 功能模型：从用户的角度展示系统的功能，包括用例图
* 对象模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图
* 动态模型：展示系统的内部行为。包括序列图、活动图、状态图

## 技术细节 fabric
fabric
* 分析一个库时，应该抓住其解决的最核心的问题进行迅速理解和学习
* core element
  * canvas
  * group
  * object
  * event
* fabric caching and matrix
  * noScaleCache/objectCaching/statefullCache
  * matrixCache/ownMatrixCache
  * calcOwnMatrix()/calcTransformMatrix(skipGroup)
* canvas
  * 选取相关：skipTargetFind/targetFindTolerance/perPixelTargetFind/targets/findTarget(e, skipGroup)
  * 组选相关
    * 是否开启组选：selection
    * 组选样式：selectionColor/selectionBorderColor/selectionDashArray/selectionLineWidth/……
  * 捕捉相关：snapAngle/snapThreshold
  * 对象管理：add(...objects)/remove(...objects)/contains(object)/clear()/dispose()
  * 对象选取：setActiveObject/getActiveObject/discardActiveObject
  * getObjects(type?)
  * toGroup
  * skipOffscreen
  * stopContextMenu
  * setCursor
  * zoomToPoint
* fabric.Image
  * filters
  * clipPath
* fabric.Object
  * intersectsWithObject/intersectsWithRect
  * selectable
  * evented：当设置为 false，对象无法成为事件的目标对象，而是直接穿过
  * lockMovementX/lockMovementY/lockRoatation/lockScalingFlip/lockScalingX/lockScalingY/lockSkewingX/lockSkewingY
  * controls 优秀的扩展点：用于实现删除、复制、编辑的贼酷
  * onSelect、onDeselect
  * hoverCursor/moveCursor
  * perPixelTargetFind
  * strokeUniform 用于控制缩放是否影响线框，设置为 true 表示永远维持特定的像素大小
  * subTargetCheck
  * isOnScreen/isPartiallyOnScreen
  * render(ctx)/transform(ctx) hh，竟然和我意外的设计一模一样
  * ungroupOnCanvas()
  * lineCoords/aCoords/aCoords
* event
  * 基础事件：mouse:down/mouse:move/mouse:up/mouse:over/mouse:out/mouse:dblclick
  * click/mouseover/mouseout 通过 e.target 可以得到响应事件的对象，这个属性很方便的，比如进行 hover 上色等等，可以作为一个最底层的能力
  * 清晰且有语义的事件名，比如 object:rotated/object:scaled/object:moved/……

## 技术细节 editor
editor 介绍（做了什么）
* commands：编辑命令（移动、删除、绘制、复制、阵列、测距、镜像、旋转等）
* controls：控制器（选择、平移、特效等）
* object3Ds：三维对象封装（建筑、灯光、相机等）
* editCommand：撤销回退
* snap 捕捉相关
* 功能开关：选择、移动、删除、复制、修改
* 获取相交元素
* 是否可选、是否锁定
* 渲染内置的大地天空场景
* 设置可选对象
* 鼠标相关事件代理
  * mousemove、mouseleave、mousedown、mouseup
  * drop
  * click、dblclick

> Object3DFinder 值得好好关注一哈，做了很多 Editor 可直接对外输出的能力以及很多业务能力

参考 oda 设计
* Viewer 对象
  * 关于渲染：update()
  * 对象管理：clear()/regenAll()
  * 关于选取：getSelected()/setSelected()/select()/unselect()/hideSelectedObjects()
  * 高级选取：selectXXX() 多点选、多边形选、框选、多线段选
  * 关于捕捉：getSnapPoint()
  * 关于坐标：screenToWorld()/toEyeToWorld(x, y, z)
  * 关于高亮：setHighlightColor(r, g, b, a)
* Object：Model、Entity、Block
  * getSelectability()/setSelectability()

### 当前可优化点
任务清单如下
* 提供 selection 相关 api
  * MaterialHelper => StateToggle，新增 BuildingComplexStateToggle
  * SelectionHelper => StateControl
  * 考虑每个对象可能存在不同 highlight 颜色需求
* typing 完善
  * 优化 Object3D 对象的 userData，第一导致重构麻烦，第二成为 any 逃生舱，不安全（已完成）
  * editor 事件类型和 Event 对象类型管理，看能否提供一个日志功能（已完成）
* 顶部工具栏
  * 顶部工具栏状态与具体业务中工具调用，非常混乱，提供隐式（implicit）和显式（explicit）api（已完成）
* 通用化 editor
  * 区分非业务对象 Object3D 对象和通用对象
  * 顶部工具栏更通用化
  * 提供通用的 CommonObject3D 对象，通用化移动、锁定、复制、选择等能力
* 其他优化点
  * 优化选取操作，每次选取同样元素时会重复触发事件问题
  * 提供获取相交对象与最近相交对象，而不是交给调用方通过 Finder 去解决
  * 优化关于添加对象 api 的第三参数是否旋转让人困惑问题

### 工具栏优化
老实说，不太知道这几个 enabled 是干嘛的去了。

优化工具状态栏切换
* setEnabled
* setSelectionEnabled
* setObjectsForRaycasting

editor.enabled 扮演的角色
* 链条：editor.enabled、setEnabled、editorEnabledChange
* 用于某些场合关闭，可复制、可移动、可删除、可移动
* 会影响到撤销重做
* setEnabled
  * 进入关闭，退出时如果是中途没有被操作，则开启
* editorEnabledChange
  * LayerContext 获取状态变化
  * 撤销重做的禁用与否

editor.selectionEnabled 扮演的角色
* 显示和隐藏红线？？？
* 用于控制选取功能
* setSelectionEnabled
  * 进入关闭，退出时如果是中途没有被操作，则开启

可能存在的问题
* 如果功能直接进入，要求不能选取，这时候点选取该如何处理呢

### 反思总结
关于此次重构任务，对于组员任务安排以及自己的任务拆分，碰到一些问题导致任务出现一些阻塞甚至返工
* 客观问题：自己重新接手项目，本身也需要时间去了解和熟悉
* 针对组员：一开始没有列出具体的任务清单，只给出一个大致的方向，但这会导致组员缺失目标，从而导致不知道要做什么
  * 给出方向可以，接下来应该挖掘该方向可能的重构点，集中在一起收集成一个任务清单
* 针对自身：自己想做的事情很多，反而导致不知道如何下手，与工时的矛盾很纠结，一开始估时就差很远
  * 除了任务清单之外，更重要的是对任务进行紧急与重要程度四象限划分，抓住主要矛盾行动，其他的来日方长
  * 自身无法将全部时间投入到开发中，比如进行代码的审查、日常会议等会花费不少时间

任务管理三要素
* 事前：做什么（排优先级很重要）
  1. 列出任务清单
  2. 列出每一个任务对结果的核心期待（进度、质量、效果）
  3. 对照目标评估任务
  4. 通过成果收益来看重要程度（和目标的匹配度）
  5. 通过后果损失来看紧急程度
* 事中：怎么做
  * 保证有效执行
* 事后：怎么做更好
  * 完善流程机制

> 任务来源自上而下，还是自下而上是一个值得思考的问题

由于一开始没有明确具体的任务列表，从而导致重构变成
* 目录移动大会
* 僵尸代码清理大会

## 其他
更优雅的方式处理项目环境变量问题
* 不再新建 environments 文件夹，而是通过内置的 `.env` 文件的方式解决
* 研究下是否支持环境扩展，而不是仅限于 development、test、production 环境，通过 env-cmd 进行扩展
* 注意文件之间优先级

## 开发规范
优化一版规则
* 文件命名
  * 如果是导出一个类，使用大写驼峰，推荐一个文件仅导出一个默认类
  * 如果时导出一系列普通的方法，使用小写驼峰
* 文件夹
  * 名称尽量使用单个单词
  * 对于模块，推荐创建 index 文件进行 re-export，有利于提高对外输出的稳定性