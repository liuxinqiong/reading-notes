## 个人计划
迎来一段空闲时间，除了整理下自己的心情之外，更重要的是对接下来个人发展有一个完整的规划，大致分为如下几个方面
* 专业能力
* 团队能力

## 专业能力
专业能力的提高
* the usage of jsts
* editor pro
  * 从 fabric.js、three/editor 总结设计思想
  * 结合项目中的实际痛点
  * 插件化开发
* React
  * 拉勾教育 - React 源码分析
  * 极客时间 - ToyReact
  * 开课吧 - React 源码
* 可视化
  * ~~Three.js 跳一跳~~
  * 极客时间 - 可视化
* 设计与工程化
  * geek tutorial
  * mooc video
  * axios & antd

## 团队能力
爬坡之路 - 从解决单点问题变成系统性方法，从服务自己变成服务团队，从一次性开发变成持续性输出
* 从前局限在专业解决问题
  * 性能优化、框架理解、专业领域（Node.js/Canvas/WebGL……）
  * 跨界与尝鲜（跨后端、跨客户端、尝试 WebAssembly……）
* 现在应该更多的考虑如何更好的帮助团队，如何提高团队协作效率
  * 工具和平台化建设（order matters）
    * 代码管理、开发测试、代码编译、项目构建
    * 模块管理、部署管理、测试支持
    * 性能检测、性能分析、安全扫描、规范约束
    * 统计分析、运营支撑
  * 流程和规范化
    * 结构的规范：合理的分层和组件化是非常必要的
    * 编码的规范：Code Review + 自动化工具 + 文档工具
    * 流程的规范：项目的评审、研发、测试与发布
    * 规范的落地：不时回顾是否切实的落地
  * 安全意识
    * 不能有低级代码安全问题：比如 xss 和 csrf
    * 大型运营活动需求，要有容灾意识和备份，要有可选备用方案
    * 尝试使用工具化来解决和预防安全问题
  * 工程实施有不同的程度，**从低到高分成三个阶段**
    * 纯管理：容易执行不到位
    * 制度化：规则代替人的命令，CheckList，定期 Review
    * 自动化：重要的操作路径上设计规则
  * 团队合作

对需求的思考
* 首先了解为什么要做这个需求，它的背景是什么，能带来多大的价值？
* 这个功能在当前的系统是否已经实现了？如果实现了，是否可以复用，如果不能复用，差别在哪里？
* 这个功能除了满足当前的需求，还可以举一反三用到别处吗，是否可以抽出公用业务组件？
* 这个需求是一次性的需求还是长期的，后期会怎么发展？
* 技术上实现的成本高不高，如果高的话，是不是可以选最痛的、优先级最高的做，然后小步迭代？

UML（统一建模语言），有三个主要的模型
* 功能模型：从用户的角度展示系统的功能，包括用例图
* 对象模型：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图
* 动态模型：展示系统的内部行为。包括序列图、活动图、状态图

## 工程
更优雅的方式处理项目环境变量问题
* 不再新建 environments 文件夹，而是通过内置的 `.env` 文件的方式解决
* 研究下是否支持环境扩展，而不是仅限于 development、test、production 环境，通过 env-cmd 进行扩展
* 注意文件之间优先级

## 前端领域模型设计
MVC 分层开发模式
* 基于贫血模型的 MVC 三层架构开发模式，但它却违反了面向对象编程风格，是彻彻底底的面向过程的编程风格（模型只定义数据，具体的逻辑对应层中，和定义数据 + utils 是一样的处理方式，将数据和操作分离，破坏了面向对象的封装特性）
* 基于贫血模型的开发模式被人诟病，而基于充血模型的 DDD 开发模式开始越来越被人提倡

> 基于充血模型的开发模式也是按照 MVC 架构封层的，跟基于贫血模型的传统开发模式的区别主要在 Service 层。贫血模型：重 Service 轻 BO，充血模型：轻 Service 重 Domain

DO、BO、VO 很多时候都是一样的，该如何考虑呢
* 推荐每层都定义各自的数据对象，原因如下
  * 并非完全一样
  * 代码虽然重复，但语义不重复。如果合并为同一个类，那也会存在后期因为需求的变化而需在拆分的问题
  * 减少每层之间的耦合。层与层之间通过接口交互。数据从下一层到上一层的时候，将下层的数据对象转化成上一层的数据对象，再继续处理。虽然繁琐，但分层清晰。
* 解决重复
  * 继承
  * 组合
* 转换优化：DO 到 BO、BO 到 VO 的转化
  * 方法一：手动手动复制
  * 方法二：对象转换工具，比如相关 copyProperties utils 工具

Domain-Driven Design
* 通过将底层数据模型与领域逻辑关联起来，管理软件应用程序的复杂性
* 通常两种方法来分离关注点和从组件模板中提取逻辑
  * presenters：将所有的可视化表达逻辑从模板中抽离出来，从而使表示层尽可能干净简单
  * utilities：为所有的前端逻辑收集共用的函数，和模板没那么相关

不使用领域模型存在的问题
* 视图层过厚
  * 存在的问题：视图层原本只需要展示 DOM 的结构，但这里却承担了各种逻辑判断、数据筛选、数据转换等“杂活”
  * 导致的后果：难以直观地理解视图结构
  * 优化思路：视图层最好单一，数据展示到视图层之前，做好数据的筛选、转换，判断逻辑抽象成公用函数放入 util 中。
* 判断或计算逻辑重复
  * 例子：判断是不是管理员、计算面积、高度
  * 存在的问题：同样的逻辑在多个视图层中重复出现，如果逻辑比较复杂，甚至各成员实现方式不一致，在后期维护将会造成许多问题
  * 导致的后果：违反代码重复原则，后期维护成本高。团队中各成员知识不同步，同样的功能 A B 都实现了，但彼此不知道，甚至可能因实现方案不同导致的结果不一致的问题
  * 优化思路：将某个实体抽象成一个类，在类中封装对应的方法供视图层调用
* 忽略业务整体
  * 存在的问题：在一个庞大、多人协作的项目，作为其中一员很可能出现对整个系统理解不够，只知道自己负责的那几个页面
  * 导致的后果：代码重复性问题。没有整体的了解，会缺乏“可拓展性”与“预判未来性”的考虑。接手其他成员负责的领域时会不好上手。需求评审时，缺乏更深入的思考，被产品经理无脑驱动
  * 优化思路：将每一块业务划分成不同的领域，各领域下包含哪些服务，提高内聚性，加强成员对业务的理解，让团队成员力量进行聚焦，共同思考业务

前端设计的目标
* 视图层尽可能薄：获得的数据能够直接使用到视图层中，禁止在视图层中对数据进行转换、筛选、计算等逻辑操作。
* 不写重复逻辑
* 不同职责的代码合理分层
* 可纵观全局领域

具体设计
* 领域模型层
* 领域服务层 service：调用 api 与 model，返回模型数据

> 额外收获：新人入职时，可以先分享项目下的领域模型，再分享我们的项目架构与分层

具体思考
* 如果对象逻辑比较复杂，比如会有很多计算属性，且为不可变对象，则可以构建一个涵盖 95% 常用场景的领域对象类。其他情况通过构造 Wrapper 解决。
* 面向接口编程，创造一个对象，要以能定义出接口为出发点，而不是根据类反推接口。接口通常都是比较稳定的，依赖具体的实现，动不动的就要扩充，这样接口的设计就没有意义了。
* utils 中一定是通用的业务逻辑，如果业务对象中需要某个会被复用的业务函数，建议根据具体目的，抽象出对应的 er/or 对象，语义更明确
  * Builder.build
  * Filter.filter
  * Finder.find
  * Creator.create
  * Optimizer.optimize
  * Strategy
  * Validator
  * Translator
  * Interpreter
  * Parser

如下情况就推荐有领域对象
```ts
interface UserDO {
  firstName: string;
  lastName: string;
  age: number;
  male: 0 | 1 | 2;
}

class User {
  firstName: string;
  lastName: string;
  age: number;
  male: 0 | 1 | 2;
  constructor(user: UserDO) {
    this.firstName = user.firstName;
    this.lastName = user.lastName;
    this.age = user.age;
    this.male = user.male;
  }
  static fromDO(user: UserDO) {
    return new User(user);
  }

  getName() {
    return this.lastName + this.firstName;
  }

  getMaleString() {
    if (this.male === 0) {
      return '未知';
    }
    return this.male === 1 ? '男' : '女';
  }
}
```

## 开发流程
开发流程
* 需求分析，技术文档编写
* 代码质量引导，lint 规则
* 什么时候需要重构
* 如何编写单测
* 版本管理策略：thunk-based vs feature branching
* 测试工程师介入

feature branching 适合的场景
* 开源项目
* 你有很多初级开发者
* 你已经有一个成熟的产品，此时你关注的是性能或负载，这种优化需要非常精准的改变，时间不是问题

feature branching 不适合的场景
* 当你项目刚刚开始时
* 你需要快速迭代时
* 当你有很多高级工程师时，你相信你的开发者，它们是专业且负责的

feature branching 存在的问题
* 一个功能，会存在多个分支上，如果要修改点东西，需要知道这个 feature 存在哪几个分支上
* 合并困难，那么多分支，分支到主干、主干到分支，多路双向合并，非常的麻烦
* 单独开发的特性可能会创建长期存在的分支，而这些分支可能很难与主项目结合起来。

thunk-based 开发模式
* 所有开发者直接工作在 master 分支上，可以直接提交代码
* 有些场景，会创建短生命的特性分支，当代码编译和测试通过时，他们可以直接合并到 master，它确保开发是持续的，并防止开发人员创建难以解决的合并冲突
* 在这种方式想要审查代码，那就只能进行完整代码检查，进行需要有些保证代码质量的策略
  * 严格的代码风格
  * 严格的 lint 校验

thunk-based 适合的场景
* 当你项目刚刚开始，比如需要快速开发一个 mvp 版本
* 你需要快速迭代
* 当你与有经验的工程师合作时，这种模式体验会很棒

thunk-based 不适合的场景
* 开源项目
* 当你有很多初级工程师
* 当你有成熟的场景，或庞大的团队时

## @ausz/editor
为避免之前的弯路
* 事件机制统一管理，且 typing 完善
* 尽量少用 userData，如果要用，保证类型完全
* 顶部工具栏和特定功能工具状态管理问题：如果功能直接进入，要求不能选取，这时候点选取该如何处理呢
* Object3DFinder 值得好好关注一哈，做了很多 Editor 可直接对外输出的能力以及很多业务能力？？

> 插件化开发？

关于选取，我们应该有两套 api
* 一套直接设置选取对象的 api
* 一套根据鼠标事件交互选取的 api