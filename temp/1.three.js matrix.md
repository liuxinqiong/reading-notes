Three.js 矩阵变换

为什么需要矩阵
* 理论上讲我们的确可以只通过数学公式就能实现变换，但实际的情况却是在变换十分复杂时，直接使用数学表达式来进行运算也是相当繁复的
* 在现实中常常使用矩阵（由 m×n 个标量组成的长方形数组）来表示诸如平移、旋转以及缩放等线性变换
* 一个更有趣的事实是，当两个变换矩阵 A 和 B 的积为 P=AB 时，则变换矩阵 P 相当于 A 和 B 所代表的变换。矩阵乘法不符合交换律，因此 AB 和 BA 并不相等

> 矩阵与向量的乘法：横 * 竖

为什么 Three.js 使用 4*4 矩阵
* 使用 3*3 矩阵可以搞定旋转变换，但却解决不了平移问题
* 因为平移表达式中带有一个常量，没有办法使用 `3*3` 的矩阵来表示平移。解决办法就是使用 `4*4` 矩阵实现，随之而来的问题就是如何让三维坐标和 4*4 矩阵相乘呢
* 为了解决三维矢量和 4*4 矩阵相乘的问题，我们为三维矢量添加了第四个分量，这样之前的三维矢量 (x,y,z) 就变成了四维的 (x,y,z,w)，这样由 4 个分量组成的矢量便被称为齐次坐标。需要说明的是，齐次坐标 (x,y,z,w) 等价于三维坐标 (x/w,y/w,z/w)，因此只要 w 分量的值是 1，那么这个齐次坐标就可以被当作三维坐标来使用，而且所表示的坐标就是以 x，y，z 这 3 个值为坐标值的点。

Object3D 矩阵相关属性
* matrix 局部变换矩阵
* matrixAutoUpdate 将计算每一帧的位移、旋转和缩放矩阵，并重新计算 matrixWorld 属性，如果你希望在重新计算时手动控制，则可以通过将属性设置为 false 来获得更好的性能，更改任何属性后，调用 updateMatrix 手动更新矩阵
* matrixWorld 物体的世界变换，如果没有父级，则它和局部变换矩阵 matrix 相同
* matrixWorldNeedsUpdate 当这个属性设置了之后，它将计算在那一帧中的 matrixWorld，并将这个值重置为 false
* quaternion 表示对象局部旋转的四元数
* rotation 物体的局部旋转，以弧度来表示
* applyMatrix4(matrix: Matrix4) 对当前物体应用变换矩阵，并更新物体的位置、选择和缩放
* applyQuaternion(quaternion: Quaternion) 对当前物体应用由四元数所表示的变换
* localToWorld(vector: Vector3) 将向量从物体的局部空间转换到世界空间
* worldToLocal(vector: Vector3) 将该向量从世界空间转换到物体的局部空间
* setRotationFromEuler(euler: Euler)
* getWorldPosition(target: Vector3)
* getWorldQuaternion(target: Quaternion)
* getWorldScale(target: Vector3)
* updateMatrix()
* updateMatrixWorld()
* updateWorldMatrix()

欧拉角：Euler(x, y, z, order)，x/y/z 分别表示在对应轴上的旋转量，用弧度表示。order 表示顺序，默认为 XYZ

> 欧拉角存在万向锁问题：当三个万向节其中两个的轴发生重合时，会失去一个自由度的情形。

四元数的出现就可以解决欧拉角的万向锁问题和万向锁带来的插值不是线性的问题。同时比起三维正交矩阵表示，四元数表示能够更方便地给出旋转的转轴与旋转角。

Three.js 中的矩阵
* 模型变换矩阵、投影变换矩阵、视图变换矩阵：https://blog.csdn.net/charlee44/article/details/105925497
* 为什么使用 4*4 矩阵：https://www.cnblogs.com/murongxiaopifu/p/5149908.html
* 向量：https://blog.csdn.net/pangshaohua/article/details/87915950
* 四元素
  * https://eater.net/quaternions/video/intro
  * https://www.bilibili.com/video/av33385105

3D 世界中比较重要的五个坐标系统
* 局部空间（Local Space，或称为物体空间（Object Space））
* 世界空间（World Space）
* 观察空间（View Space，或称为眼空间（Eye Space））
* 裁剪空间（Clip Space）
* 屏幕空间（Screen Space）

为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是模型（Model）矩阵、观察 (（View）矩阵和投影（Projection）矩阵。
* 模型矩阵（Model Matrix）：用于将物体的坐标从局部变换到世界空间
* 观察矩阵（View Matrix）：用来将世界坐标变换到观察空间，观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。
* 投影矩阵（Projection Matrix）：将顶点坐标从观察变换到裁剪空间，它指定了一个范围的坐标，比如在每个维度上的 -1000 到 1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在 -1.0到 1.0 的范围之间，所以会被裁剪掉。

整个变换流程
1. 局部坐标是对象相对于局部原点的坐标，也是物体起始的坐标。
2. 下一步是将局部坐标变换为世界空间坐标，世界空间坐标是处于一个更大的空间范围的。这些坐标相对于世界的全局原点，它们会和其它物体一起相对于世界的原点进行摆放。
3. 接下来我们将世界坐标变换为观察空间坐标，的角度进行观察的。使得每个坐标都是从摄像机或者说观察者
4. 坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至 -1.0 到 1.0 的范围内，并判断哪些顶点将会出现在屏幕上。
5. 最后，我们将裁剪坐标变换为屏幕坐标，我们将使用一个叫做视口变换(Viewport Transform)的过程。视口变换将位于 -1.0 到 1.0 范围的坐标变换到由 glViewport 函数所定义的坐标范围内。

之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。
* 当需要对物体进行修改的时候，在局部空间中来操作会更说得通；
* 如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通；

> 将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到 2D 观察空间坐标）被称之为投影（Projection），因为使用投影矩阵能将3D坐标投影（Project）到很容易映射到 2D 的标准化设备坐标系中。

将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。主要有：正交投影矩阵（Orthographic Projection Matrix）和透视投影矩阵（Perspective Projection Matrix）。

> 在 ThreeJS 中，矩阵是以列主序的方式存储的。也就是说通过数组绘制矩阵时，需要竖向书写。

向量：具有大小和方向，由于向量表示的是方向，起始于何处并不会改变它的值。数学家喜欢在字母上面加一横表示向量。当用作公式时，常用矩阵表示

标量：scalar，three Vector3 的 api 中很多与 `scalar` 相关的函数，就是与标量进行运算的意思

> 由于向量是一个方向，所以有些时候会很难形象地将它们用位置（Position）表示出来。为了让其更为直观，我们通常设定这个方向的原点为(0, 0, 0)，然后指向一个方向，对应一个点，使其变为位置向量（Position Vector）

向量取反：一个向量的每个分量前加负号就可以实现取反了（或者说用-1数乘该向量）

向量加减
* 加：向量的加法可以被定义为是分量的（Component-wise）相加，即将一个向量中的每一个分量加上另一个向量的对应分量
* 减：像普通数字的加减一样，向量的减法等于加上第二个向量的相反向量。**两个向量的相减会得到这两个向量指向位置的差。这在我们想要获取两点的差会非常有用。**

向量的模（长度）：ｎ维向量的各个分量的平方和再开方，在三维中表示向量的空间长度。常用 `||v||` 或 `|v|` 表示。

单位向量（Unit Vector）：单位向量有一个特别的性质——它的长度是 1。我们可以用任意向量的每个分量除以向量的长度得到它的单位向量。**通常单位向量会变得很有用，特别是在我们只关心方向不关心长度的时候（如果改变向量的长度，它的方向并不会改变）**

向量点乘
* 几何意义：向量 a 在向量 b 方向上的投影与向量 b 的模的乘积，因此等于它们的数乘结果乘以两个向量之间夹角的余弦值 `a·b=|a||b|·cosθ`
* 夹角 θ 很有用，因为当 a 和 b 均为单位向量时，表达式也就直接变成了 cosθ，因此
  * 90 度的余弦角是 0，因此点乘能够测试出两个向量是否正交
  * 0 度的余弦角是 1，因此点乘能够用来测试两个向量是否平行
  * 反过来看，也可以通过点乘的结果计算两个非单位向量的夹角，点乘的结果除以两个向量的长度之积，得到的结果就是夹角的余弦值
* Dot Product：点乘是通过将对应分量逐个相乘，然后再把所得积相加来计算的，若 `a=(x1,y1),b=(x2,y2)`，则 `a·b=x1·x2+y1·y2`

向量叉乘
* Cross Product：叉乘只在 3D 空间中有定义，它需要两个不平行向量作为输入，生成一个正交于两个输入向量的第三个向量
* 几何意义：c 是垂直 a、b 所在平面，且以 `|b|·sinθ` 为高、`|a|` 为底的平行四边形的面积
* 若坐标系是满足右手定则的，当右手的四指从 a 以不超过 180 度的转角转向 b 时，竖起的大拇指指向是 c 的方向
* 不同于其他运算，如果你没有钻研过线性代数，可能会觉得叉乘很反直觉，暂时直接记住公式即可（需要通过行列式去理解）

矩阵定义
* 矩阵就是一个矩形的数字、符号或表达式数组。矩阵中每一项叫做矩阵的元素（Element）
* 矩阵可以通过 (i, j) 进行索引，i是行，j是列，因此 ixj 矩阵表示的是 i 行 j 列的矩阵
* 和向量一样，矩阵也有非常漂亮的数学属性。

矩阵的加减
* 矩阵与标量之间的加减：矩阵每个元素均加减变量
* 矩阵之间的加减：两个矩阵对应元素的加减运算，因此加法和减法只对同维度的矩阵才是有定义的

矩阵的数乘：和矩阵与标量的加减一样，矩阵与标量之间的乘法也是矩阵的每一个元素分别乘以该标量

矩阵相乘
* 只有当左侧矩阵的列数与右侧矩阵的行数相等，两个矩阵才能相乘。**阵的乘法是一系列乘法和加法组合的结果，它使用到了左侧矩阵的行和右侧矩阵的列。矩阵相乘是左边矩阵行乘右边矩阵的列**
* 矩阵相乘不遵守交换律(Commutative)，也就是说A⋅B≠B⋅A。

矩阵与向量相乘
* 向量：它其实就是一个 N×1 矩阵，N 表示向量分量的个数
* 矩阵和向量的乘法很关键：**因为很多有趣的 2D/3D 变换都可以放在一个矩阵中，用这个矩阵乘以我们的向量将变换（Transform）这个向量**。

单位矩阵
* Identity Matrix
* 单位矩阵是一个除了对角线以外都是 0 的 N×N 矩阵。
* 单位矩阵和向量相乘，不会改变原向量

图形变换：使用矩阵可以很轻松的表示缩放、平移、旋转。

> 注意：上面提到的变化中，第四个缩放向量仍然是 1，因为在 3D 空间中缩放 w 分量是无意义的。w 分量另有其他用途。同时 3D 世界使用 4x4 矩阵的一个重要原因就是平移分量，使用 3x3 无法表达

齐次坐标
* 向量的 w 分量也叫齐次坐标。想要从齐次向量得到 3D 向量，我们可以把 x、y 和 z 坐标分别除以 w 坐标。我们通常不会注意这个问题，因为 w 分量通常是 1.0。
* 使用齐次坐标有几点好处
  * 它允许我们在 3D 向量上进行位移（如果没有 w 分量我们是不能位移向量的）
  * 如果一个向量的齐次坐标是 0，这个坐标就是方向向量(Direction Vector)，因为 w 坐标是 0，这个向量就不能位移

> 避免万向节死锁的真正解决方案是使用四元数（Quaternion），它不仅更安全，而且计算会更有效率。

矩阵组合
* 使用矩阵进行变换的真正力量在于，根据矩阵之间的乘法，我们可以把多个变换组合到一个矩阵中。
* 矩阵乘法是不遵守交换律的，这意味着它们的顺序很重要。
* 当矩阵相乘时，在最右边的矩阵是第一个与向量相乘的，所以你应该从右向左读这个乘法。
* 建议您在组合矩阵时，先进行缩放操作，然后是旋转，最后才是位移，否则它们会（消极地）互相影响。

逆矩阵

优秀的资料
* 欧拉旋转视频教程：https://v.youku.com/v_show/id_XNzkyOTIyMTI=.html
* [Learn OpenGL CN](https://learnopengl-cn.github.io/)
* [OpenGL 学习入门-变换](https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/)
* [OpenGL 学习入门-坐标系](https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/)

Three.js 矩阵相关知识

THREE 中定义了下述三个矩阵：
* 相机投影类型：投影矩阵（ProjectMatrix），通过 `camera.projectionMatrix` 获得
* 相机的位置和方向：视图矩阵 (CameraMatrixWorldInverse 或 ViewMatrix)，通过 `camera.matrixWorldInverse` 获得，注意，`camera.matrixWorld` 是相机在三维空间中的位置矩阵，不要搞混啦
* 物体的位置和形变：物体位置矩阵(ObjectWorldMatrix)，通过 `object.matrixWorld` 获得，注意，THREE 中的物体是有层级关系的，所以 THREE 中物体的 `matrixWorld` 是通过 local matrix（`object.matrix`）与父亲的`matrixWorld` 递归相乘得到的

三维投影矩阵计算公式如下
```js
// 乘以该矩阵后得到了标准设备坐标
const uMatrix = ProjectMatrix * CameraMatrixWorldInverse * ObjectMatrixWorld
```

Three.js 屏幕坐标和世界坐标互转

世界坐标转换为屏幕坐标
1. 调用 Vector3 的 project 函数，传入 camera，返回设备标准坐标
2. 设备标准坐标转屏幕坐标

屏幕坐标转世界坐标
1. 屏幕坐标转设备标准坐标
2. 调用 Vector3 的 unproject 函数，传入 camera，得到世界坐标

假设 canvas 中有一点 (x,y)，这个点在空间坐标系中为 (x1,y1)，那么这个转换公式是：
```js
var x1 = (x / w) * 2 - 1
x1 =( x / w) * 2 − 1

var y1 = -(y / h) * 2 + 1
y1 = −(y / h) * 2 + 1
```

有了 ndc 坐标后，转换为世界坐标就比较简单了，three 还很友好的给我们封装了方法
```js
const worldVector = stdVector.unproject(camera);
```

世界坐标转屏幕坐标
1. 通过 Vector3对象的方法 project(camera)，返回的结果是世界坐标 worldVector 在 camera相机对象矩阵变化下对应的标准设备坐标， 标准设备坐标 xyz 的范围是 `[-1,1]`。
2. 计算 canvas 中心点坐标，做简单计算即可

具体代码如下
```js
// 假定画布满屏
const centerX = window.innerWidth / 2;
const centerY = window.innerHeight / 2;
const standardVec = worldVector.project(camera);
const screenX = Math.round(centerX * standardVec.x + centerX);
const screenY = Math.round(-centerY * standardVec.y + centerY);
```


Three.js 中 Vector3 相关函数，几个重要或不好理解的记录一下
* applyEuler(euler: Euler)：通过将 Euler（欧拉）对象转换为 Quaternion（四元数）并应用， 将欧拉变换应用到这一向量上。
* applyAxisAngle(axis: Vector3, angle: number)：将轴和角度所指定的旋转应用到该向量上。同样是将旋转应用到 Vector3 上。
* applyMatrix3(m: Matrix3)
* applyMatrix4(m: Matrix4)
* applyQuaternion(q: Quaternion)
* project(camera: Camera)：使用所传入的摄像机来投影（projects）该向量。
  ```js
  //three.js源码为
  new THREE.Vector3().applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  ```
* unproject(camera: Camera)：使用所传入的摄像机来反投影（projects）该向量
  ```js
  //three.js源码为
  new THREE.Vector3().applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  ```
* clamp(min: Vector3, max: Vector3)：clamp 系列用于限制最大最小值
* negate()：向量取反
* dot(v: Vector3)：点积
* normalize()：转为单位向量
* cross(a: Vector3, w?: Vector3)：叉积
* angleTo(v: Vector3)
* distanceTo(v: Vector3)
* distanceToSquared(v: Vector3)：计算该向量到传入的v的平方距离。 如果你只是将该距离和另一个距离进行比较，则应当比较的是距离的平方， 因为它的计算效率会更高一些。**因为开方比较耗时**

Matrix3 方法
* setFromMatrix4(m: Matrix4)
* getInverse(matrix: Matrix3, throwOnDegenerate?: boolean): Matrix3
  * 求传入矩阵m的逆矩阵，使用解析法将该矩阵设置为传递矩阵 m 的逆矩阵。
  * 行列式为零的矩阵不能求逆。如果尝试这样做，该方法将返回一个零矩阵。
* multiply(m: Matrix3)
* premultiply(m: Matrix3): Matrix3