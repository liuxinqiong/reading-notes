React 18
* 新的 Root API
  * 旧 API 默认使用 legacy 传统模式
  * 新 API 使用 concurrent 并发模式
* Suspense 完整支持
  * 对于 SSR 非常友好
* 自动批量更新
  * 在 React 17 和更早版本中，封装了事件响应的批量更新，但这在异步中是不生效的
  * 在 React 18 中，如果你使用的是新版 Root API，所有的更新都会被自动批量更新
  * 如果在一些挑剔的情况，你不希望批量更新，你可以使用 ReactDOM.flushSync()
* startTransition API
  * 区分紧急更新和非紧急但重更新，有助于保持当前网页的响应性，并能够在同一时间做大量非阻塞的UI更新。
  * 紧急更新：比如输入、悬停、点击
  * 非紧急更新，可以使用 startTransition 包裹
* SuspenseList
  * 通过 revealOrder prop 为 forwards、backwards、together 控制内部 Suspense 加载顺序
* useDeferredValue
  * defer 推迟

函数式组件与类组件有何不通
* 函数式组件捕获了渲染所用的值。但提供了类似 this 机制，ref 是一种“选择退出”渲染一致性的方法
* 类组件通过 this 读取 props 或 state 值，与那次渲染时所有的 props 和 state 是脱钩的。解决办法还是通过创建闭包的方式

> 时间切片、Suspense、并发模式

API 设计
* 简单原则：持久性和稳定性是已发布 API 的重要特征
* 如果 API 的接口无论如何都改变了，API 提供者不可能改变所有使用该API的应用程序，而强制所有消费者调整或更新他们的应用程序也是同样不切实际的。
* API 需要保持向后兼容，这样老客户端就不会崩溃，新客户端就可以使用新的和改进的特性。

API 潜在的修改及分类
* 向后兼容的修改
  * 增加查询参数，他们总是可选的
  * 增加请求头或表单参数，如果是可选的话
  * 增加 JSON 数据结构字段，如果是可选的话
  * 新增资源地址
  * 已有资源新增动作
  * 将现有 API 中的强制字段更改为可选字段
* 不兼容修改：如果需要进行更改，则必须创建 API 的新附加版本，该版本与现有 API 版本并行存在。**建议只执行非破坏性的更改，即添加性更改。**
  * 删除或修改数据结构
  * 请求或响应移除了字段
  * 将主体或参数中以前可选的请求字段更改为强制字段
  * 将主体或参数中以前必需的响应字段更改为可选字段
  * 修改资源 uri 地址
  * 向数据结构添加新的强制字段
* 版本控制 - Accept Header
  * 可以在 Accept Header 中显式地指示 API 的版本，API 的 URI 不包含任何版本信息，对于新版而已，URL 并没有发生改变
  * 建议不要引入默认版本，客户端必须总是指明版本。这种强制性版本控制要求从发布 API 的第一个版本开始就引入版本控制。
* 版本控制 - URI Path Parameter
  * 在 URI 路径中引入版本参数
  * 优点是广泛使用和浏览器兼容性。不同的版本可以通过浏览器探索。
* 版本控制 - Custom HTTP Header
  * 这种方法可能会导致缓存问题。不推荐使用此方法。
* 版本控制 - 查询参数
  * 不推荐使用
* 版本控制 - 新的子域名
  * 比如 v1.domain.com
  * 不推荐使用