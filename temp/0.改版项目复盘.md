项目结果方面问题
1. FP 风格的代码还是有点多，具体表现在散函数多
2. 缺少自己服务于 view 的 service 层，当初觉得 service 层可能没太多必要，跳过了 service 层直接将 api 层作用于 view 了
3. 类型定义
  * Object3D 的 userData 类型 - 由于 userData 本身在 Object3D 中本身是 any 类型，Three 的一些 getXXX api 返回的均是 Object3D，是不可能返回你想要的实现子类的。因此自己如果想要有类型，你可以封装自己的和业务对象相关的 getXXX 相关函数
  * axios 返回值类型定义 - 由于使用拦截器动态修改了返回值类型，因此建议在 api 函数中显示声明返回类型，但是新人很容易犯这个错误，有没有办法通过高级 typing 的方式解决呢
  * Redux Action payload 类型定义 - 只能在特定 action 中自行 as 成一个类型，而且这是必须的操作，否则你在使用的时候会导致类型是 any
4. useSelector 性能相关 - reselect 库存在的意义
5. useEffect dep 中对象的局部选择
  * usePrevious 自行缩小需要关心的变量范围
  * ref
6. redux-saga 错误导致应用奔溃
7. dispatch 是同步的吗？怎么知道已经完成
  * dispatch 本身是同步修改 store 中的值
8. 与 OOP 冲突吗
  * 值得好好思考
  * 利用 setXXX 和 dispatch 的稳定性，在 oop 中进行反向操作，或者 oop 对象发射事件
9. 刷新整个 plan 导致组件不必要的刷新
10. 缺少 plan 关键数据结构的领域模型

Review List
* Cad
* Info
* Site

项目复盘
* Three
  * renderOrder 属性的作用和效果
  * ShapeGeometry vs ExtrudeGeometry
  * GridObjectSnap
  * depthWrite 属性的作用和效果
  * 球坐标
  * three 设置对象不能被拾取，对象 visible 为 false 时依然会响应拾取，如果想关闭拾取，则需要调用如下
    ```js
    object.traverse(child => {
        child.layers.disableAll()
        // child.layers.enableAll() // 恢复
    })
    ```
* jsts
  * jsts.geom
    * Geometry
      * getCentroid 获取中心点
      * getEnvelope 获取外接矩形
        * computeEnvelopeInternal 获取图形的最大最小的 x/y 值
      * buffer 指定形状向内外 buffer 出一个新形状
      * union 并集
      * difference 差集
      * intersection 交集
      * equalsExact 是否完全相等
      * contains 某图形是否包含指定图形
      * getNumGeometries|getGeometryN
      * isCCW：判断图形是不是逆时针
    * GeometryFactory
    * Point
      * isWithinDistance
  * LineSegment
    * distance
    * distancePerpendicular 垂线距离
    * midPoint
    * closestPoint
    * project 投影点
  * jsts.io
    * GeoJSONReader vs GeoJSONWriter
  * jsts.algorithm
    * Angle
    * Orientation
  * jsts.operation
    * distance
      * DistanceOp
  * jsts.simplify
    * DouglasPeuckerSimplifier：曲线近似表示为一系列点，并减少点的数量的一种算法。它的优点是具有平移和旋转不变性，给定曲线与阈值后，抽样结果一定
* frontend
  * atob btoa
  * Uint8Array
  * window.Blob
  * URL.createObjectURL

## 偏前端的一些问题
我为什么推荐使用 setXXX 的方式
* 相比直接通过赋值的方式，值被修改的方式可溯源，使用函数的方式，一方面可以通过 log 的方式，查看值被修改是否符合预期，也可以通过 trace 打印出整个调用堆栈。直接通过赋值的方式，如果存在值被同时多次修改，将会导致非常难以排查
* 优秀实践：如果存在多个地方修改同一个值的情况，如果出现问题会导致不易排查，不知道被谁意外修改。建议给每个派发事件的地方，增加一个 target 属性，方便排查

## 其他
判断一个图形是顺时针还是逆时针的意义

getEnvelopeInternal：返回图形在坐标轴上的最大最小值
getEnvelope：返回最小外接矩形

## info & site
公共 utils
* 地图相关
  * 经纬度转换的 utils
  * 米字坐标与经纬度转换
* 图形算法
  * 自相交图形拆散 utils
  * 获取内部点 utils
* 处理 date、time 相关的 library
* 动画相关 tween
* UrlUtils
  * 处理 url 相关
  * 依赖 qs 模块
* 观察者模式
* FileUtils
  * 下载相关
* GeomUtils
  * translate
  * rotate
  * isPointOnLine
* keyboard
  * 快捷键
* 函数式编程
  * merge
  * deepClone
  * memoize
  * curry
  * 防抖节流
* MathUtils
* PlatformUtils
* TypeUtils
* React Hooks
  * 处理取消请求
  * usePersistFn
  * useStateRef
  * usePrevious
  * useMounted
  * useHistoryStack
  * useLocalStorage
  * useWindowClientSize
  * useScrollIntoView
* React utils
  * Children
  * isValidElement
  * map
  * cloneElement
* Array
  * difference
  * intersection
* jsts 图形相关
  * buffer
  * centroid
  * simplify
  * union
  * intersection 获取相交部分
  * intersects 是否相交
  * equalsExact
  * contains
  * isWithinDistance 是否在指定距离内
  * Orientation.isCCW
  * getEnvelope
  * getEnvelopeInternal

site
* MockProgress
* GuidePopover
* 命名新世界：cleanAndAdd、renderOnAddRemove、recordMousePosition
* centeredScaling 可以研究下 fabric scale 参照点不同是怎么计算的
* StompClient
* 传递构造函数 typing 举例: new (elem: Polygon, options?: fabric.IPolylineOptions) => T
* fillRule：'evenodd' | 'nonzero'

visual
* calculateRotateDegree 计算视图旋转角度
* all/remove/getAll/clear
* orbitControls.update()
  * maxDistance/minDistance PerspectiveCamera only
  * maxZoom/minZoom OrthographicCamera only
* getIntersects
* lockView/unLockView
* fitExtent
* PCFSoftShadowMap
* ColorLut
* BufferGeometryUtils.mergeBufferGeometries
* BufferGeometryLoader

ui
* CadMap
  * StyleApply
  * ignoreScale 是否响应视图缩放
  * useReducer => redux like
  * Drawer
    * snapStartPoint
    * 绘制能力 mousemove click
    * 快捷键能力 keydown
  * Editor
    * add/remove 注册编辑图形
    * snapVertex
  * map.getResolution
  * ctx.save/ctx.restore
  * screenToWorld/worldToScreen
* CadRecognizer
  * 颜色修改：byLayer、byBlock、bySelf
  * viewer.zoomExtents/screenToWorld/getSnapPoint/getActiveExtents
    * selectionPlugin -> Drawer、Picker
  * HoverHelper/Picker/Drawer
  * MouseTrackerTooltip
  * Color
  * fillZeroIf2D
  * Elements：LineElement、OverlayElement、RectElement、PointElement、TooltipElement
  * clearEffectWhenFinished
  * Plugin 机制
  * axios.responseType = arraybuffer
* Debugger
* LocaleWrapper
* PanelLayer
* TagSelect 这个还挺典型的，可以作为面试题，难度也不复杂
* Toggle
* Tool
* 组件派生属性再 hooks 中如何实现，下面 class 组件实现
  * 构造函数适用 props 值作为 state 创建时初始值
  * 使用 getDerivedStateFromProps 钩子进行更新