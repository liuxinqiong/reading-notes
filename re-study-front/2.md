## JS 运行机制

### 为什么 Promise 里代码比 setTimeout 先执行？
当拿到一段 JS 代码时，浏览器或者 Node 环境首先要做的就是：传递给 JS 引擎，并且要求他去执行。

我们首先应该形成一个感性的认知：一个 JS 引擎会常驻于内存中，它等待我们（宿主）把 JS 代码或者函数传递给它执行。

在 ES3 和更早的版本中，JS 本身还没有异步执行代码的能力，这也就意味着宿主环境传递给 JS 引擎一段代码。引擎就把代码直接顺序执行。但在 ES5 之后，JS 引入了 Promise，这样不需要浏览器安排，JS 引擎本身也可以发起任务了。

> 我们把宿主发起的任务成为宏观任务，把 JS 引擎发起的任务成为微观任务。

JS 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。

在底层 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，用伪代码表示如下
```js
while(true) {
    r = wait()
    execute(r)
}
```

当然实际代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑。

在宏观任务中，JS 的 Promise 还会产生异步代码，JS 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务队列中又包含了一个微观任务队列。

如何分析异步执行的顺序
* 首先分析有多少个宏观任务
* 每个宏观任务中，分析有多少个微观任务
* 根据调用次序，确定宏观任务中的微任务执行次序
* 根据宏观任务的触发规则和调用次序，确定宏任务的执行次序

Promise 是 JS 中的一个定义，但是实际编写代码时，我们可以发现，它似乎并不比回调的方式书写更简单，但是用 ES6 开始，有了 async/await，这个语法改进跟 Promise 配合，能够有效地改善代码结构。

async/await 是 ES2016 新加入的特性，它的运行时基础是 Promise。

async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。

async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。

async 的强大之处在于，它是可以嵌套的，我们在定义了一批原子操作的情况下，可以利用 async 函数组合出新的 async 函数。

### 闭包和执行上下文
可以这样简单理解一下，闭包其实只是一个绑定了执行环境的函数，闭包和普通函数的区别是，它携带了执行的环境。

这个古典的闭包定义中，闭包包含两个部分
* 环境部分
  * 环境：函数的词法环境
  * 标识符列表：函数中用到的未声明的变量
* 表达式部分：函数体

> 这里有个常见的概念误区，有些人会把 JS 执行上下文，或者作用域这个概念当作闭包。实际上 JS 中跟闭包对应的概念就是“函数”，可能这个概念太过于普通，跟闭包看起来又没什么联系，所以才会形成这个误区吧。

执行上下文在 ES3 中包含三个部分
* scope：作用域，也叫做作用域链
* variable object：变量对象，用于存储变量的对象
* this value 值

在 ES5 中，改进了命名方式
* lexical environment：词法环境，当获取变量时使用
* variable environment：变量环境，当生命变量时使用
* this value：this 值

> 在 ES2018 中，执行上下文中增加了不少内容，为避免复杂度，这里不讨论

### 函数种类
函数种类
* 普通函数：用 function 关键字定义的函数
* 箭头函数：用 => 运算符定义的函数
* 方法：在 class 中定义的函数
* 生成器函数：用 function * 定义的函数
* 类：用 class 定义的类，实际上也是函数

普通函数的 this 值由“调用它所使用的引用”决定，其实奥秘就在于：我们获取函数的表达式，实际上返回的并非函数本身，而是一个 Reference 类型。Reference 由两部分组成：一个对象和一个属性值。当做一些算数运算（或者其他运算时），Reference 类型会被解引用，即获取真正的值（被引用的内容）来参与运算，而类似函数调用、delete 等操作，都需要用到 Reference 类型中的对象。

> 调用函数时使用的引用，决定了函数执行时刻的 this 值

在 JS 标准中，为函数规定了用来保存定义时上下文的私有属性 [[Environment]]。当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的 [[Environment]]。

this 则是一个更为复杂的机制，JS 标准定义了 [[thisMode]] 私有属性，私有属性有三个取值
* lexical：表示从上下文中找 this，这对应了箭头函数
* global：表示当 this 为 undefined 时，取全局对象，对应了普通函数
* strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined

> 非常有意思的是，方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行。

call/apply/bind 用于不接受 this 的函数类型如箭头、class 都不会报错，这时候，它们无法改变 this 的能力，但是可以实现传参。