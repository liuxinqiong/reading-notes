## 脚本、模块、函数体
脚本和模块：在 JS 中有两种源文件，一种叫做脚本，一种叫做模块，这个区分实在 ES6 引入了模块机制开始的，在 ES5 和之前的版本中，就只有一种源文件类型，那就是脚本
* 脚本是可以由浏览器或者 node 环境引入执行的
* 模块只能由 JS 代码用 import 引入执行

从语法产生式做对比，模块和脚本之间的区别仅仅在于是否包含 import 和 export。

现在浏览器可以支持用 script 标签引入模块或脚本，如果要引入模块，必须给 script 标签添加 type="module"，如果引入脚本则不需要 type。

script 标签如果不加 type="module"，默认认为加载的文件是脚本而非模块，如果我们在脚本中写了 export，当然会报错。

脚本可以包含语句，模块中可以包含三种类型
* import 声明
* export 声明
* 语句

import 有两种用法
* 直接 import 一个模块，import 'mod'
* 带 from 的 import，引入模块里的一些信息

> 直接 import 一个模块，知识保证了这个模块代码被执行，引用它的模块是无法获得它的任何信息的，带 from 的 import 意思是引入模块中的一部分信息，可以把它们变成本地的变量

假设有两个模块 a 和 b，在模块 a 中声明了一个变量和一个修改变量的函数，并且把它们导出，用 b 模块导入了变量和修改变量的函数。当我们调用修改变量的函数后，b 模块变量也更着发生了改变。说明导入与一般的赋值不同，导入后的变量值是改变了名字，它仍然与原来的变量是同一个。

export 导出变量的方式有两种 + 特殊用法
* 独立使用 export 声明
* 直接在声明型语句前添加 export 关键字
* 特殊用法：和 default 联合使用

default 的行为跟导出变量是不一致的，这里导出的是值，比如导出的就是普通变量 a 的值，以后 a 的变化与导出的值就无关了，修改变量 a，不会使的其他模块中引入的 default 值发生改变。

### 函数体
宏任务中可能会执行的代码包括脚本（script）、模块（module）和函数体（function body），接下来看看函数体。

JS 语法的全局机制：预处理和指令序言
* 不理解预处理就无法理解 var 等声明类语句的行为
* 而不理解指令序言，就无法理解严格模式

JS 在执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。

var 的作用能够穿透一切语法结果，只认脚本、模块和函数体三种语法结结构。

function 声明在全局（脚本、模块和函数体），表现和 var 相似，不同之处在于不但在变量域中加入变量，还会给他赋值。function 声明出现在 if 等语句的情况有点复杂，它仍然作用域脚本、模块和函数体级别，在预处理阶段仍然会产生变量，但不再被提前赋值。

class 声明在全局的行为跟 function 和 var 都不一样，声明前使用 class 名，会抛错。难道是 class 没有被预处理。那下面的代码就解释不同了
```js
var c = 1
function foo() {
    console.log(c)
    class c {}
}
foo()
```

此时代码仍然会抛出错误，但如果去掉 class 声明，就会正常工作。说明后面 class 声明影响了前面语句的结果。

class 声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误（暂时性死区）。同时 class 声明作用不会穿透 if 等语句结构。这样的 class 设计比 function 和 var 更符合直觉，而且在遇到一些比较奇怪的用法时，倾向于抛出错误。

脚本和模块都支持一种特别的语法，叫做指令序言。最早是为了 use strict 设计的，规定了一种给 JS 代码添加元信息的方式。

"use strict" 是 JS 标准中规定的唯一一种指令序言，但是设计指令序言的目的是，留给 JS 的引擎和实现者一些统一的表达方式，在静态扫描时指定 JS 代码的一些特性。

JS 指令语言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体最前面。

## 语句
我们从普通语句和声明语句进行总结

普通语句
* 语句块（一对大括号）
* 空语句（独立的分号）
* 顺序语句（表达式语句）
* 分支语句（if、switch 语句）
* 循环语句（for、for in、for of、for await of、while、do while）
* return、break、continue、with、throw、try、debugger 语句

> 在 C 时代，switch 生成的汇编代码性能是略优于 if else 的，但是对 JS 来说，则无本质区别，现在 switch 已经完全没有必要使用了，应该用 if else 结构代替

throw 用于抛出异常，try 部分用于标识捕获异常的代码段，catch 部分则用于捕获异常后做一些处理，finally 则是用于执行后做一些必须执行的清理工作。在 catch 中重新抛出错误的情况非常常见，在设计比较底层的函数时，常常会这么做，保证抛出的错误能被理解。

> 声明型语句跟普通语句最大区别就是声明型语句响应预处理过程，普通语句只有执行过程。

声明语句
* var 语句
* let 语句
* const 语句
* class 声明（默认内部的函数定义都是 strict 模式）
* 函数声明

var 声明语句是古典的 JS 中声明变量的方式，而现在，在绝大多数情况下，let 和 const 都是更好的选择。如果仍然想要使用 var，建议把它当做一种"保障变量是局部"的逻辑，遵循三条规则
* 声明同时必定初始化
* 尽可能在离使用的位置近处声明
* 不要在意重复声明

注意：let 和 const 还是会被预处理，会形成访问禁区

### 表达式语句
表达式语句实际上就是一个表达式，它是由运算符连接变量或者直接量构成。表达式语句要么是函数调用，要么是赋值，要么自增自减，否则表达式计算的结果没有任何意义。

我们从粒度最小到最大了解一下

主要表达式
* 表达式的最小单位，涉及的语法结构也是优先级最高的
* 直接量：用某种语法写出来的具有特定类型的值。
* 任何表达式加上圆括号，都被认为是主要表达式，这个机制使得圆括号成为改变运算优先顺序的手段

成员表达式：用于访问对象成员

new 表达式：成员表达式加上 new 就是 new 表达式

函数调用表达式：成员表达式还能构成函数调用表达式，添加一个括号即可

左值表达式：New Expression 和 Call Expression 统称 LeftHandSideExpression，直观的讲，左值表达式是可以放在等号左边的表达式

赋值表达式
* 等号赋值
* 等号是可以嵌套的，对于连续赋值，是采用的右结合的方式

表达式：赋值表达式可以构成表达式的一部分，在 JS 中，表达式就是用逗号运算符连接的赋值表达式。逗号分隔的表达式会依次执行，整个表达式的结果就是最后一个逗号后的表达式结果。

#### 右值表达式
通用计算机语言设计理论中，能够出现在赋值表达式右边的是右值表达式。在 JS 中，规定了在等号右边的表达式就是条件表达式，因此在 JS 标准中从未出现过右值表达式。

JS 标准规定了左值表达式同时也是右值表达式，此外，左值表达式也可以通过跟一定的运算符组合，逐级构成更复杂的结构，直到成为右值表达式。
* 更新表达式：左值表达式搭配 ++ -- 运算符，行成更新表达式
* 一元运算表达式：左值表达式搭配 delete/void/typeof/!/-/~/await
* 乘方表达式：左值表达式搭配 **
* 乘法表达式：* / % 三种运算符
* 加法表达式： + - 两种元素符
* 移位表达式：<< 向左移位 >> 向右移位 >>> 无符号向右位移，左移 n 位相当于乘以 2 的 n 次方，右移 n 位相当于除以 2 取整 n 次
* 关系表达式：> < >= <= instanceof in
* 相等表达式：== === !== !=
* 位运算符
  * 按位与：&
  * 按位异或：^
  * 按位或：|
* 逻辑与、逻辑或
  * 短路特性
  * 不会做类型转换
* 条件运算符：三目运算符

> 在 JS 中，二进制操作整数并不能提高性能，移位运算这里也仅仅作为数学运算存在，这些运算的存在也仅仅是为了照顾 C 系语言用户习惯

相等表达式又包含一个 JS 中著名的设计失误，那就是 == 的行为。一些编程规范甚至要求完全避免使用 == 运算，这也是比较合理的。

归根到底，类型不同的变量比较时只有三条规则
* undefined 与 null 相等
* 字符串和 bool 都转为数字再比较
* 对象转成 primitive 类型再比较

建议：仅在确认 == 发生在 Number 和 String 类型之间使用