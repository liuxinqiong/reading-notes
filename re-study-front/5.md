## 语法一
脚本和模块：在 JS 中有两种源文件，一种叫做脚本，一种叫做模块，这个区分实在 ES6 引入了模块机制开始的，在 ES5 和之前的版本中，就只有一种源文件类型，那就是脚本
* 脚本是可以由浏览器或者 node 环境引入执行的
* 模块只能由 JS 代码用 import 引入执行

从语法产生式做对比，模块和脚本之间的区别仅仅在于是否包含 import 和 export。

现在浏览器可以支持用 script 标签引入模块或脚本，如果要引入模块，必须给 script 标签添加 type="module"，如果引入脚本则不需要 type。

script 标签如果不加 type="module"，默认认为加载的文件是脚本而非模块，如果我们在脚本中写了 export，当然会报错。

脚本可以包含语句，模块中可以包含三种类型
* import 声明
* export 声明
* 语句

import 有两种用法
* 直接 import 一个模块，import 'mod'
* 带 from 的 import，引入模块里的一些信息

> 直接 import 一个模块，知识保证了这个模块代码被执行，引用它的模块是无法获得它的任何信息的，带 from 的 import 意思是引入模块中的一部分信息，可以把它们变成本地的变量

假设有两个模块 a 和 b，在模块 a 中声明了一个变量和一个修改变量的函数，并且把它们导出，用 b 模块导入了变量和修改变量的函数。当我们调用修改变量的函数后，b 模块变量也更着发生了改变。说明导入与一般的赋值不同，导入后的变量值是改变了名字，它仍然与原来的变量是同一个。

export 导出变量的方式有两种 + 特殊用法
* 独立使用 export 声明
* 直接在声明型语句前添加 export 关键字
* 特殊用法：和 default 联合使用

default 的行为跟导出变量是不一致的，这里导出的是值，比如导出的就是普通变量 a 的值，以后 a 的变化与导出的值就无关了，修改变量 a，不会使的其他模块中引入的 default 值发生改变。

### 函数体
宏任务中可能会执行的代码包括脚本（script）、模块（module）和函数体（function body），接下来看看函数体。

JS 语法的全局机制：预处理和指令序言
* 不理解预处理就无法理解 var 等声明类语句的行为
* 而不理解指令序言，就无法理解严格模式

JS 在执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。

var 的作用能够穿透一切语法结果，只认脚本、模块和函数体三种语法结结构。

function 声明在全局（脚本、模块和函数体），表现和 var 相似，不同之处在于不但在变量域中加入变量，还会给他赋值。function 声明出现在 if 等语句的情况有点复杂，它仍然作用域脚本、模块和函数体级别，在预处理阶段仍然会产生变量，但不再被提前赋值。

class 声明在全局的行为跟 function 和 var 都不一样，声明前使用 class 名，会抛错。难道是 class 没有被预处理。那下面的代码就解释不同了
```js
var c = 1
function foo() {
    console.log(c)
    class c {}
}
foo()
```

此时代码仍然会抛出错误，但如果去掉 class 声明，就会正常工作。说明后面 class 声明影响了前面语句的结果。

class 声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误（暂时性死区）。同时 class 声明作用不会穿透 if 等语句结构。这样的 class 设计比 function 和 var 更符合直觉，而且在遇到一些比较奇怪的用法时，倾向于抛出错误。

脚本和模块都支持一种特别的语法，叫做指令序言。最早是为了 use strict 设计的，规定了一种给 JS 代码添加元信息的方式。

"use strict" 是 JS 标准中规定的唯一一种指令序言，但是设计指令序言的目的是，留给 JS 的引擎和实现者一些统一的表达方式，在静态扫描时指定 JS 代码的一些特性。

JS 指令语言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体最前面。