## HTML 语义
div 和 span 不是够用了么。

所以就来谈谈语义类标签，它们的特点是视觉表现上互相都差不多，主要的区别在于它们表示了不同的语义，比如经常见到的 section、nav、p 这些都是语义类的标签。

为什么现在大家的意思都是 div 和 span 走天下呢？这是因为在现代互联网产品里，HTML 用于描述“软件界面”多过于“富文本”，而软件界面里的东西，实际上几乎是没有语义的。因此在任何“软件界面”的场景中，可以直接使用 div 和 span。

但在很多工作场景中，语义类标签也有它们自己无可替代的优点。正确的使用予以标签可以带来很多好处。
* 对开发者更为友好，使用语义类标签增强了可读性，即便在没有 CSS 的时候，开发者也能够清晰的看出网页的结构，也更为便于团队的开发和维护。
* 除了对人类友好外，语义类标签也十分适宜机器阅读。文字表现力丰富，更适合引擎检索（SEO），还可以支持读屏软件，根据文章自动生成目录等等。

> 不恰当使用语义标签，反而会造成负面作用。错误的使用语义标签，会给机器阅读造成混淆、增加嵌套，给 CSS 编写加重负担。因此：“用对”比“不用”好，“不用”比“用错”好。当然有理想的工程师还是应该去追求用对他们。

几个语义化场景
* 自然语言表达能力的补充
* 文章标题摘要
* 适合机器阅读的整体结构

常用语义化标签
* ruby、rt、rp
* em（表示重音）
* h、p、hgroup
* section、header、nav、aside、footer、address、article
  * header：通常出现在前部，表示导航或介绍性的内容
  * footer：出现在尾部，包含作者信息、相关链接、版权信息等
  * aside：表示和文章主题不那么相关的部分，可能包含导航、广告等工具性质的内容，本身很容易被理解为侧边栏，实际上两者是包含关系，侧边栏是 aside，aside 不一定是侧边栏
  * address：表示作者联系方式，明确地只关联到 article 和 body

## 类型系统
JavaScript 语言规定了 7 种语言类型
1. Undefined
2. Null
3. Boolean
4. String
5. Number
6. Symbol
7. Object

为什么有的编程规范要求用 void 0 代替 undefined ？

Undefined 类型表示未定义，他的类型只有一个值，就是 undefined。任何变量在福之前是 Undefined 类型，值为 undefined。一般我们可以用全局变量 undefined 来表达这个值，或者 void 运算来把任意一个表达式变成 undefined 值。

问题在于 JavaScript 的代码中 undefined 只是一个变量，而不是关键字，首先明确一点，这是 JavaScript 语言公认的设计失误之一，所以为了避免无意中被篡改，建立使用 void 0 来获取 undefined 值。

> 在ES5之前的时候，undefined 是可以被赋值的。在现代浏览器当中已经把 undefined 设置为一个 non-configurable, non-writable属性的值了。

Undefined 跟 null 有一定的表意差别，null 表示定义了但是为空。因此在实际编程时，我们一般不会把变量赋值为 undefined，这样可以保证所有值为 undefined 的变量，都是未赋值的自然状态。

Null 类型也只有一个值，就是 null，他的语义表示空值，与 undefined 不同的是，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。

String 是否有最大长度？

String 理论上最大长度是 2^53 - 1，这也是 JS 中可表达的最大安全整数。这在一半开发中都是够用的，但有趣的事，这个所谓最大长度，并不完全是你理解中的字符数。因为 String 的意义并未字符串，而是字符串的 UTF-16 编码，同时我们的字符串的操作 charAt、charCodeAt、length 等方法针对的都是 UTF-16 编码。因为字符串的最大长度，实际上是受字符串编码长度影响的。

JavaScript 中的字符串是永远无法变更的，一旦字符串构造出来，无法用任何方式改变字符串，所以字符串具有值类型的特征。

JavaScript 中的 Number 类型有 2^64 - 2^53 + 3 个值？这是为什么？

JavaScript 中的 Number 类型基本符合 IEEE 754-2008 规定的双精度浮点数规则，但是 JavaScript 为了表达几个额外的语言场景（比如不让除以 0 出错，而引入了无穷大的概念），规定了几个例外情况：
* NaN
* Infinity
* -Infinity

> 值得注意的是，JavaScript 中有 +0 和 -0，在加法类运算中它们没有区别，但是除法的场合则需要特别留意区分。区分 +0 和 -0 的方式，正是检测 1/x 是 Infinity 还是 -Infinity

根据双进度浮点数的定义，Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。

同样根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行）来比较。比如 0.1 + 0.2 == 0.3 问题。因为浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。因此正确的比较方法是使用 JavaScript 提供的最小精度值，检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。
```js
console.log(Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON)
```

Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象备用 Symbol 重塑。Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等。创建 Symbol 使用全局的 Symbol 函数即可。

在 JavaScript 中的几个基本类型，都在对象中有一个亲戚，分别是
* Number
* String
* Boolean
* Symbol

其中 Number、String 和 Boolean，染个构造器是两用的，当跟 new 搭配时，它们产生对象，当直接使用时，表示强制类型转换。Symbol 函数比较特殊，直接用 new 调用它会抛出错误，但它仍然是 Symbol 对象的构造器。

为什么给对象添加的方法能用在基本类型上？因为.运算符提供了装箱操作，他会根据基础类型构造一个临时对象，使得我们能在基础类型上调用对应对象的方法。

### 类型转换
因为 JS 是弱类型语言，所以类型转换发生非常频繁，大部分我们熟悉的运算（比如加减乘除大于小于双等于）都会先进行类型转换。

其实最臭名昭著的是 JS 中的 == 运算，因为试图实现跨类型的比较，但它的规则复杂到几乎没人可以记住。因此很多实践中认为 == 运算符属于设计失误，要求程序员进行显示的类型转换后，用 === 比较。

#### StringToNumber
先看看数字的不同表示
* 30 十进制
* 0b111 二进制
* 0o13 八进制
* 0xff 十六进制
* 1e3 || -1e01 正负号科学计数法

但是 parseInt 和 parseFloat 并不使用这个转换，所以支持的语法跟这里不尽相同。在不传入第二个参数的情况下，parseInt 只支持 16 进制前缀'0x'，而且会忽略非数字字符，而不支持科学计数法。

因为在任何情况下，都建议传入 parseInt 的第二个参数，该参数表示上述字符串的基数。而 parseFloat 则直接把原字符串作为十进制来解析，它不会引入任何其他机制。

多数情况下，Number 是比 parseInt 和 parseFloat 更好的选择。

顺便谈谈 NumberToString，在较小的范围内，数字和字符串的转换是完全符合你直觉的十进制表示。当 Number 绝对值较大或者较小时，字符串表示则是使用科学计数法表示的。

### 装箱转换
每一种基本类型 Number、String、Boolean、Symbol 在对象中都有对应的类，所谓装箱转换，正是把基本类型转换为对象的对象，它是类型转换中一种相当重要的种类。

装箱机制会频繁产生临时对象，在一些对性能要求较高的场景下，应该尽量避免对基本类型做装箱转换。

每一类装箱对象皆有私有的 Class 属性，这些属性可以用 Object.prototype.toString 获取，在 JS 中，没有任何方法可以更改私有的 Class 属性，因此 Object.prototype.toString 是可以准确识别对象对应的基本类型的方法，它比 instanceOf 更加准确。

### 拆箱转换
在 JS 中规定了 ToPrimitive 函数，他是对象类型到基本类型的转换。对象到 String 和 Number 的转换都遵循“先拆箱再转换”的规则。通过拆箱转换，把对象变成基本类型，再从基本类型转换为对应的 String 或者 Number。拆箱转换会尝试调用 valueOf 和 toString 来获得拆箱后的基本类型，如果均不存在或者没有返回基本类型，则会产生类型错误 TypeError。

在 ES6 之后，还允许对象通过显示指定 toPrimitive Symbol 来覆盖原有的行为
```js
o[Symbol.toPrimitive] = () => {}
```

### 总结
程序 = 算法 + 数据结构，运行时类型包含了所有 JavaScript 执行时所需要的数据结构的定义，所以需要格外重视。

“类型”在 JavaScript 中是一个有争议的概念。一方面，标准中规定了运行时数据类型； 另一方面，JS 语言中提供了 typeof 这样的运算，用来返回操作数的类型，但 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。特别需要注意的是：null -> object。