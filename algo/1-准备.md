## 为什么
掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的。

基础架构研发工程师，写出达到开源水平的框架才是你的目标。

掌握数据结构和算法，你看带问题的深度，解决问题的角度就会完全不一样。

## 抓住重点
广义而言：数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。

狭义而言：指某些著名的数据结构和算法，比如队列，栈、堆、二分查找、动态规划等。

> 数据结构是为算法服务的，算法要作用在特定的数据结构之上

首先要掌握一个数据结构与算法中最重要概念 - 复杂度分析。数据结构和算法解决的是如何更省、更快地存储和处理数据的问题

20 个最常用的、最基础的数据结构和算法
* 数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 数
* 算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

不要死记硬背
* 来历
* 自身特点
* 适合解决的问题
* 实际的应用场景

## 复杂度分析
假设每行代码执行的时间都一样，为 unit_time，通过分析可以看出，所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比

大 O 复杂度表示法：T(n) = O(f(n))
* T(n) 表示代码执行的时间
* n 表示数据规模的大小
* f(n) 表示每行代码执行的次数总和
* O 表示 T(n) 和 f(n) 表达式成正比

大 O 时间复杂度表示代码执行时间随数据规模增长的变化趋势，所以也叫做渐进时间复杂度，简称时间复杂度

当 n 很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略，只需要记录一个最大量级就可以了。

时间复杂度分析技巧
* 只关注循环执行次数最多的一段代码
* 加法法则：总复杂度等于量级最大的那段代码的复杂度
* 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

几种常见时间复杂度 按数量级递增
* 常量阶 O(1)
  * 代码执行时间不随 n 的增大而增大
  * 一般而言，只要算法中不存在循环语句、递归语句，即使有成千上万行代码，复杂度也是 O(1)
* 对数阶 O(logn)
* 线性阶 O(n)
* 线性对数阶 O(nlogn)
* 平方阶、立方阶…… K次方阶
* 指数阶 O(2^n)
* 阶乘阶 O(n!)

上述可以分为多项式量级和非多项式量级，其中非多项式量级只有指数阶和阶乘阶。把时间复杂度为多项式量级的算法问题叫做 NP（Non-Deterministic Polynomial，非确定多项式）问题。非多项式时间复杂度的算法其实是非常低效的算法。

对数阶 O(logn) 与线性对数阶 O(nlogn)
* 非常常见，也是最难分析的一种时间复杂度
* 不管是以 2 为底还是以 3 为底，因为对数之间是可以互相转换的，同时采用大 O 标记复杂度时候，可以忽略系数
* 因此在对数阶时间复杂度的表示方法里，我们忽略对数的底，统一表示为 O(logn)

O(m+n)、O(m*n)
* 代码复杂度由两个数据的规模来决定
* 因为无法事先评估 m 和 n 谁的量级大，所以不能简单利用加法法则，省略掉其中一个
* 乘法法则依然有效

空间复杂度：渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系，最常见的空间复杂度就是 O(1)、O(n)、O(n^2)，像 O(logn) 与 O(nlogn) 这样的对数阶复杂度平时都用不到。

## 进阶：复杂度
同一块代码在不同的情况下，时间复杂度有量级的差距，就需要引入下面的知识点了。

四个复杂度分析方面的知识点
* 最好情况时间复杂度
* 最坏情况时间复杂度
* 平均时间复杂度
  * 分析多少种情况，每种情况出现的概率，每种情况下，查找需要遍历的元素个数进行累加除以所有可能次数
  * 总结：找到所有输入的情况及相应发生的概率计算加权平均值
  * 全称应该叫做：加权平均时间复杂度或者期望时间复杂度
* 均摊时间复杂度
  * 分析方法：摊还分析/平摊分析
  * 应用场景比平均时间复杂度更加特殊、更加有限
  * 具体场景：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度