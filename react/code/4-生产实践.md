## 性能优化
主要学习 React 自身特色的性能优化思路
* 使用 shouldComponentUpdate 避免冗余的更新逻辑
  * render 方法会伴随着对虚拟 DOM 的构建和对比，过程相当耗时。在 React 中很多时候我们会不经意间就频繁地调用了 render。为避免不必要的 render 操作带来的性能开销，React 提供了 shouldComponentUpdate 这个口子
  * **React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行 re-render（重渲染）**
  * 因为在 React 中，**只要父组件发生了更新，那么所有的子组件都会被无条件更新**。这就导致了子组件的 props 尽管没有发生任何变化，它本身也没有任何需要被更新的点，却还是会走一遍更新流程。同样的情况也适用于组件自身的更新：当组件自身调用了 setState 后，那么不管 setState 前后的状态内容是否真正发生了变化，它都会去走一遍更新流程。
* PureComponent + Immutable.js
  * PureComponent 内置了对 shouldComponentUpdate 的实现，PureComponent 将会在 shouldComponentUpdate 中对组件更新前后的 props 和 state 进行浅比较，并根据浅比较的结果，决定是否需要继续更新流程。**“浅比较”将针对值类型数据对比其值是否相等，而针对数组、对象等引用类型的数据则对比其引用是否相等**。
  * Immutable.js “不可变值”让“变化”无处遁形。PureComponent 浅比较带来的问题，本质上是对“变化”的判断不够精准导致的。那有没有一种办法，能够**让引用的变化和内容的变化之间，建立一种必然的联系呢**？这就是 Immutable.js 所做的事情。
  * **持久性数据：指的是这个数据只要被创建出来了，就不能被更改。我们对当前数据的任何修改动作，都会导致一个新的对象的返回**。这就将数据内容的变化和数据的引用严格地关联了起来，使得“变化”无处遁形。
* 函数组件的性能优化 React.memo 与 useMemo
  * React.memo 会帮我们“记住”函数组件的渲染结果，在组件前后两次 props 对比结果一致的情况下，它会直接复用最近一次渲染的结果。
  * React.memo 接收两个参数，第一个参数是我们需要渲染的目标组件，第二个参数 areEqual 则用来承接 props 的对比逻辑。
  * **areEqual 函数是一个可选参数，当我们不传入 areEqual 时，React.memo 也可以工作，此时它的作用就类似于 PureComponent——React.memo 会自动为你的组件执行 props 的浅比较逻辑。**
  * 有时候我们希望复用的并不是整个组件，而是组件的某一个或几个部分。这种更加精细化的管控，就需要 useMemo 来帮忙了。**React.memo 控制是否需要重渲染一个组件，而 useMemo 控制的则是是否需要重复执行某一段逻辑。**

## 设计模式
主要学习 React 组件的设计模式
* 高阶组件（HOC）
  * 高阶组件（HOC）是 React 中用于**复用组件逻辑**的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。
  * 沿袭了高阶函数的概念：**接收函数作为输入，或者输出另一个函数的一类函数，就是高阶函数。**
  * 从根本上减少重复的编写和修改工作
* Render Props
  * 一种在 React 组件之间使用一个值为函数的 props 共享代码的简单技术
  * 高阶组件的使用姿势是用“函数”包裹“组件”，而 render props 恰恰相反，它强调的是用“组件”包裹“函数”。
  * 函数并不一定要作为子组件传入，它也可以以任意属性名传入，只要 render props 组件可以感知到它就行。
* 剥离有状态组件与无状态组件

> 本质上基本都是为了实现这样一个终极目标——以尽可能优雅的姿态，实现组件逻辑的复用。

HOC VS Render props
* render props 通常是你更好的选择，因为它更灵活
* 重要的区别对数据的处理上：**在高阶组件中，目标组件对于数据的获取没有主动权，数据的分发逻辑全部收敛在高阶组件的内部；而在 render props 中，除了父组件可以对数据进行分发处理之外，子组件也可以选择性地对数据进行接收**。
  * 假设 withCheckAccess HOC 输出一个 isAccessible，被他包裹的组件都会自动加上 isAccessible prop，此时假设我们有个老组件 A，内部已经支持了 isAccessible 的逻辑，但此时使用的是 isValidated 变量，这时候我们要使用这个 HOC，要么 withCheckAccess 中针对性的做判断，要么对 A 内部进行修改。这就违背了一个开闭原则，我扩展一个功能，却需要修改原有的代码。
  * 处理同样的需求，render props 就能够在保全“开放封闭”原则的基础上，帮我们达到目的。**因为子组件对数据接收有自主权**

有状态组件与无状态组件：“单一职责”原则在组件设计模式中的实践
* 单一职责原则：组件功能要尽可能的聚合，不要试图让一个组件做太多的事情
* 有状态组件和无状态组件，其他说法：容器组件/展示组件，聪明组件/傻瓜组件，核心目的就一个——**把数据处理和界面渲染这两个工作剥离开来**。
* 对于一个 React 组件来说，无外乎两件事情
  * 处理数据（包括数据的获取、格式化、分发等）
  * 渲染界面
* 你可以在一个组件中做完两件事情，但这不够优雅
  * 我们应该将数据梳理的逻辑和界面渲染的逻辑剥离到不同的组件中去，这样功能模块的组合将会更加灵活，更有利于逻辑的复用
  * 控制变更范围，降低代码的维护成本：当数据相关的逻辑发生变化时，只需要去修改有状态的组件即可，无状态组件完全不受影响

Hooks
* 无论是 HOC，还是 render props，两者的出现都是为了弥补类组件在逻辑复用层面的不灵活，都有着自己的不足
  * 嵌套地狱问题，当嵌套层级过多后，数据源的追溯会变得十分困难
  * 较高的学习成本
  * props 属性命名冲突问题
  * ……
* 当我们想要去复用一段逻辑时，第一反应肯定不是“高阶函数”或者“render props”，而应该是“自定义 Hook”

## React 17
React 17 没有增加任何面向开发者的新特性，但这个版本会使得 React 自身的升级变得更加容易。React v17 作为后续版本的“基石”，它让不同版本的 React 相互嵌套变得更加容易。**React v17 开启了 React 渐进式升级的新篇章**。

渐进式升级：比如我们可以在 React 18 中安全的引入 React 17 版本的某个组件。而在 React 17 之前，这样做将会伴随着不可用的风险，彼时我们但凡要升级 React 版本，就必须一次性将整个应用迁移至目标版本。

> “渐进式升级”意味着更大的选择余地，它将在未来为大量的 React 老版本项目留出喘息的空间，确保开发者们不必为了兼容多版本而徒增烦恼。

React 17 值得关注的用户侧改变
* 新的 JSX 转换逻辑
  * React 17 则允许我们在不引入 React 的情况下直接使用 JSX。这是因为在 React 17 中，编译器会自动帮我们引入 JSX 的解析器
  * react/jsx-runtime 中的 JSX 解析器将取代 React.createElement 完成 JSX 的编译工作，这个过程对开发者而言是自动化、无感知的
  * react/jsx-runtime 在内部实现了 React.createElement 无法做到的性能优化和简化。在一定情况下，它可能会略微改善编译输出内容的大小。
* 事件系统重构
  * 放弃利用 document 来做事件的中心化管控
    * 由于 React 依赖将 DOM 事件冒泡到 document 上来实现对所有事件的中心化管控。React 事件函数中阻止冒泡，这只能够保证该事件对应的合成事件在 React 事件体系下的冒泡被阻止了，并不能够阻止原生 DOM 事件的冒泡。因此我们安装在 document 上的事件监听器一定会被触发。
    * 事件的中心化管控不会再全部依赖 document，管控相关的逻辑被转移到了应用的 RootNode 节点。这样一来， React 组件就能够自己玩自己的，再也无法对全局的事件流构成威胁了。
  * 放弃事件池
    * 在 React 17 之前，合成事件对象会被放进一个叫作“事件池”的地方统一管理。这样做的目的是能够实现事件对象的复用，进而提高性能：每当事件处理函数执行完毕后，其对应的合成事件对象内部的所有属性都会被置空，意在为下一次被复用做准备。这也就意味着事件逻辑一旦执行完毕，我们就拿不到事件对象了
    * 事件池的这个设计，虽然利好了性能，却整懵了用户。很多人只有在写过无数 Bug 之后，才会后知后觉地发现，要想拿到目标事件对象，必须显式地告诉 React——我永远需要它，也就是调用 `e.persist()` 函数
    * 但随着时代的发展，如今市面上的浏览器虽不能说是性能绝佳，但基本上也不会因为事件池里的对象多几个少几个就给你表演内存泄漏。因此，React 17 拥抱了新时代的潮流，重新在研发体验和向下兼容性能之间做了选择，这一次，它选择了前者——放弃事件池，为每一个合成事件创建新的对象。因此在 React 17 中，我们不需要 e.persist()，也可以随时随地访问我们想要的事件对象。
* Lane 模型引入
  * 初学 React 源码的同学由此可能会很自然地认为：优先级就应该是用 Lane 来处理的。但事实上，React 16 中处理优先级采用的是 expirationTime 模型。
  * expirationTime 模型使用 expirationTime（一个时间长度） 来描述任务的优先级。而 Lane 模型则使用二进制数来表示任务的优先级：lane 模型通过将不同优先级赋值给一个位，通过 31 位的位运算来操作优先级。
  * Lane 模型提供了一个新的优先级排序的思路，相对于 expirationTime 来说，它对优先级的处理会更细腻，能够覆盖更多的边界条件。

如何深入了解一个前端框架
* **不要小看官方文档**：在日常的源码阅读包括生产实践中，如果遇到了 React 相关的问题，请不要急于去阅读参差不齐的社区文章——先问问 React 文档试试看吧，或许你能收获的会比你想象中要多。
* 调用栈就是你的学习地图：框架的函数调用栈将会给你指明许多方向性的问题。观察调用栈，寻找共性，然后点对点去阅读关键函数的源码，这将大大降低我们阅读源码的难度。
* 如何阅读源码
  1. 复习一下框架官方对框架架构设计、源码分层相关的介绍。文档、框架作者、官方团队的博文
  2. 可尝试分层阅读，一次搞清一个大问题，最后再把思路按照架构分层的逻辑组合起来
  3. 也可以结束调用栈，通过观察一个完整的执行流程中所涉及的函数，自行将每个层次的逻辑对号入座，然后再向下拆分

> 在当下的这种趋势下，很多时候若你能深入地吃透一个优秀的框架，就能够迅速地积累许多可以复用的理解经验，这将为你学习其他的新知识创造极大的加速度。