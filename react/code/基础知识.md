## JSX
JSX 语法是如何在 JavaScript 版本中生效的呢：JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作 “React Element” 的 JS 对象。

JSX 的本质是 React.createElement 这个 JavaScript 调用的语法糖，因此 JSX 充分具备 JavaScript 的能力。

为什么需要 JSX：JSX 语法糖允许前端开发者使用我们最为熟悉的类 HTML 标签语法来创建虚拟 DOM，在降低学习成本的同时，也提升了研发效率与研发体验。

React.createElement 是什么
* 函数原型：createElement(type, config, children)
* 参数解读
  * type：用于标识节点的类型。它可以是类似“h1”“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 React fragment 类型。
  * config：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。
  * children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。
* 函数执行流程
  1. 从 config 中，二次处理 key、ref、self、source 四个属性值
  2. 遍历 config，筛出可以提进 props 里的属性
  3. 提取子元素，推入 props.children 数组
  4. 格式化 defaultProps
  5. 用处理后的数据，发起 ReactElement 调用
* createElement 就像是开发者和 ReactElement 调用之间的一个“转换器”、一个数据处理层。它可以从开发者处接受相对简单的参数，然后将这些参数按照 ReactElement 的预期做一层格式化，最终通过调用 ReactElement 来实现元素的创建。
* 出参解读
    * 返回一个 ReactElement 的调用，这部分源码就更简单了，组装 element 并发挥
    ```js
    const ReactElement = function(type, key, ref, self, source, owner, props) {
    const element = {
        // REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement
        $$typeof: REACT_ELEMENT_TYPE,
        // 内置属性赋值
        type: type,
        key: key,
        ref: ref,
        props: props,
        // 记录创造该元素的组件
        _owner: owner,
    };
    if (__DEV__) { }
    return element;
    };
    ```
  * ReactElement 本质上是以 JavaScript 对象形式存在的对 DOM 的描述，也就是 Virtual DOM
* ReactDOM.render
  * 虚拟 DOM 距离真实的 DOM 之间还有一些距离，这就需要 ReactDOM.render 来填补。
  * 函数原型：ReactDOM.render(element, container, [callback])