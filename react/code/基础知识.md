## JSX
JSX 语法是如何在 JavaScript 版本中生效的呢：JSX 会被编译为 React.createElement()， React.createElement() 将返回一个叫作 “React Element” 的 JS 对象。

JSX 的本质是 React.createElement 这个 JavaScript 调用的语法糖，因此 JSX 充分具备 JavaScript 的能力。

为什么需要 JSX：JSX 语法糖允许前端开发者使用我们最为熟悉的类 HTML 标签语法来创建虚拟 DOM，在降低学习成本的同时，也提升了研发效率与研发体验。

React.createElement 是什么
* 函数原型：createElement(type, config, children)
* 参数解读
  * type：用于标识节点的类型。它可以是类似“h1”“div”这样的标准 HTML 标签字符串，也可以是 React 组件类型或 React fragment 类型。
  * config：以对象形式传入，组件所有的属性都会以键值对的形式存储在 config 对象中。
  * children：以对象形式传入，它记录的是组件标签之间嵌套的内容，也就是所谓的“子节点”“子元素”。
* 函数执行流程
  1. 从 config 中，二次处理 key、ref、self、source 四个属性值
  2. 遍历 config，筛出可以提进 props 里的属性
  3. 提取子元素，推入 props.children 数组
  4. 格式化 defaultProps
  5. 用处理后的数据，发起 ReactElement 调用
* createElement 就像是开发者和 ReactElement 调用之间的一个“转换器”、一个数据处理层。它可以从开发者处接受相对简单的参数，然后将这些参数按照 ReactElement 的预期做一层格式化，最终通过调用 ReactElement 来实现元素的创建。
* 出参解读
    * 返回一个 ReactElement 的调用，这部分源码就更简单了，组装 element 并发挥
    ```js
    const ReactElement = function(type, key, ref, self, source, owner, props) {
      const element = {
          // REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement
          $$typeof: REACT_ELEMENT_TYPE,
          // 内置属性赋值
          type: type,
          key: key,
          ref: ref,
          props: props,
          // 记录创造该元素的组件
          _owner: owner,
      };
      if (__DEV__) { }
      return element;
    };
    ```
  * ReactElement 本质上是以 JavaScript 对象形式存在的对 DOM 的描述，也就是 Virtual DOM
* ReactDOM.render
  * 虚拟 DOM 距离真实的 DOM 之间还有一些距离，这就需要 ReactDOM.render 来填补。
  * 函数原型：ReactDOM.render(element, container, [callback])

## 生命周期
主要讨论 React 15 和 React 16 中生命周期，他们的区别是什么，改动的背后原因是什么。

掌握两个概念
* 虚拟 DOM：核心算法的基石
  * 组件初始化时，通过调用生命周期中的 render 方法，生成虚拟 DOM，然后再通过调用 ReactDOM.render 方法，实现虚拟 DOM 到真实 DOM 的转化
  * 组件更新时，会通过 render 方法生成新的虚拟 DOM，然后借助 diff 算法定位出两次虚拟 DOM 的差异，从而针对发生变化的真实 DOM 做定向更新
* 组件化：工程化思想在框架中的落地
  * 组件是封闭的：在组件自身的渲染工作流中，每个组件都只处理它内部的渲染逻辑。在没有数据流交互的情况下，组件与组件之间可以做到“各自为政”。
  * 组件也是开放的：React 允许开发者基于“单向数据流”的原则完成组件间的通信。而组件之间的通信又将改变通信双方/某一方内部的数据，进而对渲染结果构成影响。

React 15 生命周期
* 需重点关注的几个生命周期方法
  * constructor
  * componentWillReceiveProps
  * shouldComponentUpdate
  * componentWillMount
  * componentWillUpdate
  * componentDidUpdate
  * componentDitMount
  * render
  * componentWillUnmount
* 主要分为三个阶段
  * 组件挂在阶段
  * 组件更新阶段（父组件触发、组件自身触发）
  * 组件卸载阶段
* 组件挂载阶段
  * 执行流程：constructor -> componentWillMount -> render -> componentDitMount
  * componentWillMount：这里做初始化工作，往往会伴随一些风险或者说不必要性
  * render：并不会去操作真实 DOM，职能是把需要渲染的内容返回出来，真实 DOM 的渲染工作，在挂载阶段由 ReactDOM.render 完成
  * componentDitMount：真实 DOM 已经挂载到页面上，类似异步请求、数据初始化等也可以放在这个周期中
* 组件更新阶段
  * 父组件触发执行流程：componentWillReceiveProps -> shouldComponentUpdate -> componentWillUpdate -> render -> componentDidUpdate
  * 子组件触发执行流程：shouldComponentUpdate -> componentWillUpdate -> render -> componentDidUpdate
  * componentWillReceiveProps
    * 参数 nextProps 获得新的 props，通过 this.props 可以获得旧的 props，由此可以感知到 props 的变化
    * 错误认识：componentWillReceiveProps 是在组件的 props 内容发生了变化时被触发的。
    * 正确认识：如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法，如果只想处理更改，请确保进行当前值与变更值的比较，因此**componentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的**
  * componentDidUpdate：经常用来处理 DOM 操作，也常常将 componentDidUpdate 的执行作为子组件更新完毕的标志通知到父组件
  * shouldComponentUpdate
    * 返回值来决定是否执行该方法之后的生命周期，进而决定是否对组件进行 re-render
    * render 方法会伴随着虚拟 DOM 的构建和对比，过程是相当耗时的
* 组件的卸载：componentWillUnmount，常见的销毁原因有两个
  * 组件在父组件中被移除了
  * 组件中设置了 key 属性，父组件在 render 的过程中，发现 key 值和上一次不一致，组件就会被干掉

在 React 16 中，16.4 版本对生命周期进行了细微了修改，我们先看 16.3 的生命周期是什么形式
* 组件挂载阶段
  * 执行流程：constructor -> getDerivedStateFromProps -> render -> componentDitMount
  * 主要区别在于，废弃了 componentWillMount，新增了 getDerivedStateFromProps
  * getDerivedStateFromProps 不是 componentWillMount 的替代品，后者的存在不仅鸡肋而且危险，因此不值得被代替，就应该被废弃
  * getDerivedStateFromProps 设计的初衷是视图替换掉 componentWillReceiveProps，有且仅有一个用途：使用 props 来派生/更新 state，React 团队为了确保 getDerivedStateFromProps 这个生命周期的纯洁性，直接从命名层面约束了它的用途
  * getDerivedStateFromProps 在更新和挂载两个阶段都会“出镜”（这点不同于仅在更新阶段出现的 componentWillReceiveProps）
* 组件更新阶段
  * 执行流程：getDerivedStateFromProps -> shouldComponentUpdate -> render -> getSnapshotBeforeUpdate -> componentDidUpdate
* 组件卸载阶段

>  React 16 中对 render 方法也进行了一些改进，在 16 之前，render 方法必须返回单个元素，而 React 16 允许我们返回元素数组和字符串

认识 getDerivedStateFromProps
* getDerivedStateFromProps 是一个静态方法。静态方法不依赖组件实例而存在，因此你在这个方法内部是访问不到 this 的
* 接收两个参数：props 和 state，它们分别代表当前组件接收到的来自父组件的 props 和当前组件自身的 state
* getDerivedStateFromProps 需要一个对象格式的返回值
* getDerivedStateFromProps 的返回值之所以不可或缺，是因为 React 需要用这个返回值来更新（派生）组件的 state
* getDerivedStateFromProps 方法对 state 的更新动作并非“覆盖”式的更新，而是针对某个属性的定向更新。

提到 React 16.4 对生命周期流程进行了“微调”，其实就调在了更新过程的  getDerivedStateFromProps 这个生命周期上。React 16.4 的挂载和卸载流程都是与 React 16.3 保持一致的，差异在于更新流程上：
* 在 React 16.4 中，任何因素触发的组件更新流程（包括由 this.setState 和 forceUpdate 触发的更新流程）都会触发 getDerivedStateFromProps；
* 而在 v 16.3 版本时，只有父组件的更新会触发该生命周期。

为什么要用 getDerivedStateFromProps 代替 componentWillReceiveProps
* 官方描述：与 componentDidUpdate 一起，这个新的生命周期涵盖过时 componentWillReceiveProps 的所有用例
* getDerivedStateFromProps 可以代替 componentWillReceiveProps 实现基于 props 派生 state
* 为何不能完全和 componentWillReceiveProps 画邓华，因为过于专注了，做且只能做这一件事
* 这不是退化，一个 API 并非越庞大越复杂才越优秀，庞大和复杂的 API 往往会带来维护层面的灾难
* 定义为 static 方法，在 static 方法内部拿不到组件实例的 this，导致你无法做任何类似于 this.fetch、this.setState（导致死循环）这类可能会产生副作用的操作
* getDerivedStateFromProps 生命周期替代 componentWillReceiveProps 的背后，是 React 16 在强制推行“只用 getDerivedStateFromProps 来完成 props 到 state 的映射”这一最佳实践。意在确保生命周期函数的行为更加可控可预测，从根源上帮开发者避免不合理的编程方式，避免生命周期的滥用；同时，也是在为新的 Fiber 架构铺路。

消失的 componentWillMount 与新增的 getSnapshotBeforeUpdate
* 方法原型：getSnapshotBeforeUpdate(prevProps, prevState)
* getSnapshotBeforeUpdate 的返回值会作为第三个参数给到 componentDidUpdate。它的执行时机是在 render 方法之后，真实 DOM 更新之前。在这个阶段里，我们可以同时获取到更新前的真实 DOM 和更新前后的 state&props 信息。
* 常用于获取更新前的真实 DOM 相关信息，比如滚动条位置等
* 设计初衷，是为了“与 componentDidUpdate 一起，涵盖过时的 componentWillUpdate 的所有用例”。getSnapshotBeforeUpdate 要想发挥作用，离不开 componentDidUpdate 的配合。

为什么 componentWillUpdate 就非死不可呢？还是因为它“挡了 Fiber 的路”。

Fiber 架构解析
* Fiber 会使原本同步的渲染过程变成异步的。
* 在 React 16 之前，每当我们触发一次组件的更新，React 都会构建一棵新的虚拟 DOM 树，通过与上一次的虚拟 DOM 树进行 diff，实现对 DOM 的定向更新。这个过程是一个递归的过程。同步渲染的递归调用栈是非常深的，只有最底层的调用返回了，整个渲染过程才会开始逐层返回。**这个漫长且不可打断的更新过程，将会带来用户体验层面的巨大风险：同步渲染一旦开始，便会牢牢抓住主线程不放，直到递归彻底完成。在这个过程中，浏览器没有办法处理任何渲染之外的事情，会进入一种无法处理用户交互的状态。**
* **Fiber 会将一个大的更新任务拆解为许多个小任务**。每当执行完一个小任务时，**渲染线程都会把主线程交回去**，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。在这个过程中，**渲染线程不再“一去不回头”，而是可以被打断的**，这就是所谓的“异步渲染”

同步变异步这个过程，是如何对生命周期造成影响的
* 根据****能否被打断**这一标准，react 16 中生命周期被划分为了 render 和 commit 两个阶段，commit 阶段又细分为 pre-commit 和 commit
  * render 阶段：render 以及之前的流程，纯净切没有副作用，可能会被 React 暂停、终止或重新启动
  * pre-commit 阶段：getSnapshotBeforeUpdate，可以读取 DOM
  * commit 阶段：getSnapshotBeforeUpdate 之后的流程，可以使用 DOM，运行副作用，安排更新
* 总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。
* 为什么这么设计呢？由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。

在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。
* 当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，任务被重启的形式是：重复执行一遍整个任务，而非接着上次执行到的那行代码往下走
* 导致 render 阶段的生命周期都是有可能被重复执行的
* React 16 废弃的哪些生命周期：componentWillMount、componentWillUpdate、componentWillReceiveProps，**由于都处于 render 阶段，都可能重复被执行**，这些 API 常年被滥用，重复执行的过程中都存在不可小觑的风险

滥用的情况，比如在 componentWill 开发的生命周期中
* setState
* fetch 请求
* 操作真实 DOM

存在的问题有
* 完全可以转移到其他生命周期（componentDidXXX）里去做
* 在 Fiber 带来的异步渲染机制下，可能会导致非常严重的 Bug
* 即使你没有开启异步，React 15 下也有不少人能把自己“玩死”，比如滥用 setState 导致重复渲染死循环的

> 思考 getDerivedStateFromProps 为何会在设计层面直接被约束为一个触碰不到 this 的静态方法，其背后的原因也就更加充分了——避免开发者触碰 this，就是在避免各种危险的骚操作。

总的来说，改造生命周期的目的
* 为了配合 Fiber 架构带来的异步渲染机制
* 改造过程中，针对生命周期中长期被滥用的部分推行了具有强制性的最佳实践
* 确保了 Fiber 机制下数据和视图的安全性，同时也确保了生命周期方法的行为更加纯粹、可控、可预测。