## 关于数学
数感

简单多边形的相容三角剖分：将两个简单多边形剖分成同样数量的三角形，同时还需要保证每个三角形的顶点能够一一对应。所谓一一对应，就是给两个多边形进行编号之后，他们中的每一对三角形顶点的编号都相同。

如果两个简单多边形的边数相同，在不允许添加内部点的情况下，并不总能构成相容三角剖分。

应用：通过相容三角剖分可以生成拓扑结构相同的三角网格，而拓扑结构相同的三角网格是实现物体变形特效的基础。

基础图形学计算
* 计算点到直线、线段的距离
* 计算边的切线和法线
* 判断线段的关系
* 绘制圆锥曲线

代数方程 vs 向量的选择
* 向量叉积的几何意义就是平行四边形的面积
* 向量叉积除以底边就是高，也就是点到向量所在直线的距离

> 选择正确数学工具，能够把看似非常复杂的问题转化为简简单单问题，从而顺利解决

始终牢记：**用数学思想和意识去解决工作中的问题**

代数方程 VS 参数方程

椭圆的代数方程和参数方程
* 代数方程
  * 需要计算反正切，性能差
  * 计算中需要开平方，需要判断符号
  * 反正切有无穷大的问题，需要特殊处理

总结：**重视数学基础，锻炼自己的数感，拓宽知识面，以数学思维来思考计算机问题**

## SpriteJS 设计
要实现可视化图表，我们用图表库或者数据驱动框架都能够实现，前者使用起来简单，而后者更加灵活，如 D3.js。

为了让使用方式尽可能接近于原生的 DOM，我还让 SpriteJS 1.0 实现了这 4 个特性，分别是标准的 DOM 元素盒模型、标准的 DOM 事件、Web Animation API （动画）以及缓存策略。

要提升 Canvas 的渲染性能，就要尽量减少绘图指令的数量和执行时间，比较有效的方式是，我们可以将绘制的图形用离屏 Canvas 缓存下来。这样，在下次绘制的时候，我们就可以将缓存未失效的元素从缓存中用 drawImage 的方式直接绘制出来，而不用重新执行绘制元素的绘图指令，也就大大提升了性能。

在 SpriteJS 1.0 中，我实现了一套自动的缓存策略，它会根据代码运行判断是否对一个元素启用缓存，如果是，就尽可能地启用缓存，让渲染性能达到比较好的水平。

能够使用服务端渲染来实现一些特殊的可视化项目。比如，我们曾经有一个项目要处理大量的历史数据，大概有几十万到上百万条记录，如果在前端分别绘制它们，性能一定会有问题。所以，我们将它们通过**服务端绘制并缓存好之后，以图像的方式发送给前端，这样就大大提升了性能**。

通过外部扩展实现了粒子系统和物理引擎，以及对主流响应式框架的支持，让 SpriteJS 2.0 可以直接支持 vue 和 react。

SpriteJS 2.0 还支持了文字排版和布局系统。其中，文字排版支持了多行文本自动换行，实现了几乎所有 CSS3 支持的文字排版属性，布局系统则支持了完整的弹性布局（Flex layout)。这两个特性被很多用户喜爱。

在 SpriteJS 3.0 中，我舍弃了非核心功能，将 SpriteJS 定位为纯粹的图形渲染引擎， 核心目标是追求极致的性能。

SpriteJS 3.0 完全舍弃了 2.0 设计里面较重的 sprite-core，采用了更轻量级的图形库 mesh.js 作为 2D 适配层，mesh.js 以 gl-renderer 作为 webgl 渲染底层库，结合 Canvas2D 的 polyfill 做到了优雅降级。当运行环境支持 WebGL2.0 时，SpriteJS 3.0 默认采用 WebGL2.0 渲染，否则降级为 WebGL1.0，如果也不支持 WebGL1.0，再最终降级为 Canvas2D。

在 3D 适配层方面，SpriteJS 3.0 采用了 OGL 库。这样一来，SpriteJS 3.0 就完全支持 WebGL 渲染，能够绘制 2D 和 3D 图形了。

与 SpriteJS 1.0 和 SpriteJS 2.0 采用缓存机制优化性能不同，SpriteJS 3.0 默认采用 WebGL 渲染，因此使用了**批量渲染的优化策略，在绘制大量几何图形时，它能够显著提升 WebGL 渲染的性能**。

## 前端未来
一些前端开发对技术更新的担忧，我也能够理解。我的建议是，如果你不盲目地去追求所谓的“时髦”技术，不去刻意担心自己是否落伍，而是去多观察这个行业，找到技术发展内在的规律和脉络，那么你就知道该怎么前进，不会有任何恐慌了。

在任何一个领域或方向，**知识体系都可以分为基础知识和领域知识，而领域知识又可以分为通用领域知识和专用领域知识**。它们之间的变化是不一样的，基础知识的变化最慢，其次是通用领域知识，然后是专用领域知识。

用可视化这个方向来举例，基础知识是数学和图形学知识，比如向量、矩阵运算、三角剖分这些知识属于基础知识，它们基本上不会随着时间发生很大变化。而 JavaScript、WebGL 这种属于通用领域知识，它们会改变，也会慢慢发展，比如从 WebGL1.0 发展到 WebGL2.0，从 ES2019 发展到 ES2020，但不会变化、发展得那么快。而类似 ThreeJS、BabylonJS、SpriteJS 和 D3.js 这些属于专用领域知识，很有可能一个大版本升级就会有很大的变化。

学习这些知识，也有不同的方法。一般来说，如果是基础知识，随便什么时候我们都可以学，而且越早学习越好。基础知识就像是你的内功，学好它们，融会贯通之后，学习其他的知识都是事半功倍的。如果是通用的领域知识，一旦你下决心从事这个领域，也是能够尽早学习它比较好，不过由于这些知识是领域相关的，如果能一边学习，一边通过实践来打磨就会掌握得更快。专用领域知识，不一定要很早去学，有一个技巧是，当你用到的时候再去学习它们。如果你没有用到，你可以知道有这门技术，能做什么就行了，不用花大量时间和精力去钻研它们。

如果你确实热爱这个职业，正在考虑长远发展，我建议你最好选择一个好的平台，一个技术氛围好的团队，一份节奏合适的工作。我说的节奏合适指的是忙闲交替，既不会长时间特别忙，也不会持续特别闲。在这样的节奏下，项目积累再加上自己的学习沉淀，你就可以快速地成长了，而且技术氛围好的团队，也可以加快你学习沉淀的速度。

想在专业上达到一定的高度，因为每个人的情况不一样，所以我们要根据自己的情况来规划。不过总还是能找到一些共通点的，我觉得有一点很合适：找到并突破前端领域的“边界”。这个边界可以是某些有深度领域的技术前沿，也可以是某个交叉领域，如与服务端的交界，与移动客户端的交界等等。如果我们能在这些边界上做出突破，就肯定可以步入前端专家的行列了。其实前端专家除了需要技术能力以外，还需要有意识地打造自己的个人影响力，锻炼自己的领导力，要让自己心态开放、眼界开阔，不排斥新技术，拥抱开源，多参与社区。

## 学习的道理
只要扎实基础，循序渐进，几乎所有语言与代码方面的问题，我们都可以一点点啃下去。

那些称得上“疑难不懂”的，其实都只是缺了几门知识，少花了几次笨功夫而已。

有着这些种种不懂，也就当然有种种能懂的知识。你把这些坑坑洞洞都补起来，自然也就懂了。只要你愿意像在学校里一样地去做笨功夫，这些缺失的知识又怎么算得上难呢？

不过很多人所面对的，倒不见得是“难”，而是所谓“疑”。疑难二字，其实并不是同一个东西：你攀山越岭时，所感觉到的便是“难”，只要努力，一座座地翻过去，总还是可以到达的。而你隔岸观花时，那种似是而非才是“疑”。之所以有“疑”，并不是目力不济，而是心志不济。

学习之“易”也就在于此：总有一个确定的过程，以及一个确定的结果。但是，这往往还不够。因为如果老师只教你这个结果，那也只是最低一等的“师”。无论如何，真正的“良师”，会帮助你解决“不知起始”的问题。——于此，你真正还需要知道的是老师“为什么要教”。一旦你知道了“教的目的”，也就知道了复核自己“学的结果”的方法，这就是相互印证了。如果学习不知道起始、不知道目的、不知道印证，那么怎么学都是茫茫然。

而核心原理和体系性的“易”也就在于此：核心原理总是一个简单的结论，你所学的，只是这个结论得到的过程；体系性总是一种明确的结构（组合），你所学的，只是将这个结构组织起来的方法。所以最终来说，你就是要得到一个核心推论的过程，以及了解它所涉及的那些领域之间的关系而已。

正如引言中所说，学习这件事情，其实真的不是很难。至于是不是“天下最轻易者”，我可不敢跟古人去论争。所以在今天的分享里，我也只是想把一些似难实简的地方跟你说说：其一，你可能只是缺了点知识，要补课；其二，你可能只是宥于所知，请开放思想；其三，你可能只是埋头学习，而忘了要学会的是什么。

这种腹诽，实在是这么些年来我最怕见到的。因为持这种态度者，大多都是不愿下苦功夫的人。所以我希望读到这里，心底下还叹着“道理我都懂”的朋友，能再回到第一小节，从苦功夫做起。要知道**古往今来之有成就者，不过将学习持之以恒而已，哪里有什么技巧**。

## 函数式编程
两种编程范式
* 命令式：强调做的步骤
  * 过程式：C
  * 面向对象：C++、Java
* 声明式：强调做什么，以及做的结果
  * 逻辑式：Prolog
  * 函数式：Haskell，Erlang

> JavaScript 同时拥有命令式和声明式的特征

函数式和纯函数
* 函数是对过程的封装，但函数的实现本身可能依赖外部环境，或者有副作用
* 副作用：函数执行本身对外部环境的改变
* 不依赖外部环境和没有副作用的函数叫做纯函数，依赖外部环境或有副作用的函数叫做非纯函数

纯函数的有点
* 易于测试：上下文无关
* 可并行计算：时序无关
* 良好的 Bug 自限性：所产生的 Bug 不会扩散到系统的其他部分

因此在设计系统的时候，要尽可能多设计纯函数，少设计非纯函数，这样能够有效提升系统的可测试性、性能优化空间以及系统的可维护性

如何让系统的纯函数尽可能多，非纯函数尽可能少呢？答案就是使用函数编程范式（把副作用函数进行传递）。

了解一个高阶函数，batch 函数的参数和返回值都是函数
```js
function batch(fn) {
  return function(target, ...args) {
    if(target.length >= 0) {
      return Array.from(target).map(item => fn.apply(this, [item, ...args]));
    } else {
      return fn.apply(this, [item, ...args]);
    }
  }
}
```

高级函数与函数装饰器
* 所谓高阶函数：是指输入参数是函数，或者返回值是函数
* 函数装饰器：如果输入函数和返回值都是函数，这样的高阶函数又叫做函数装饰器

比如使用函数装饰器实现一个 deprecate 函数
```js
function deprecate(fn, oldApi, newApi) {
  const message = 'balabala'
  return function(...args) {
    console.warn(message);
    return fn.apply(this, args);
  }
}
```

数据抽象意识：过程抽象是函数式编程的基础，函数式编程对待函数就像对待数据一样，都会进行封装和抽象，这样能够设计出非常通用的功能模块。

## 未来之路
阻挡前端工程师往可视化发展的主要技术门槛有两道
* 图形学：数学基础
* WebGL：比较偏底层