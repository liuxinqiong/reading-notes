## Canvas/SVG/WebGL
前端性能是一块比较复杂的内容，由许多因素决定，比如，网页内容和资源文件的大小、请求数、域名、服务器配置、CDN 等等。如果你能把性能优化好，就能极大地增强用户体验。

在可视化领域也一样，可视化因为要突出数据表达的内容，经常需要设计一些有视觉震撼力的图形效果，比如，复杂的**粒子效果和大量元素的动态效果**。想要实现这些效果，图形系统的渲染性能就必须非常好，能够在用户的浏览器上稳定流畅地渲染出想要的视觉效果。

可视化方面特殊的性能问题，这些问题大体上可以分为两类，一类是渲染效率问题，另一类是计算问题。
* 渲染效率问题指的是图形系统在绘图部分所花费的时间
* 计算问题则是指绘图之外的其他处理所花费的时间，包括图形数据的计算、正常的程序逻辑处理等等

换句话说，如果我们能在 16 毫秒内完成图像的计算与渲染过程，那视觉呈现就可以达到完美的 60fps（即 60 帧每秒，fps 全称是 frame per second，是帧率单位）。但是，在复杂的图形渲染时，我们的帧率很可能达不到 60fps。所以，我们只能退而求其次，最低可以选择 **24fps**，就相当于图形系统要在大约 **42 毫秒**内完成一帧图像的绘制。这是在我们的感知里，达到比较流畅的动画效果的最低帧率了。要保证这个帧率，我们就必须保证计算加上渲染的时间不能超过 42 毫秒。

影响 Canvas 渲染性能的 2 大要素
* 绘制图形的数量：绘制图形的数量越多，我们需要的绘图指令就越多，花费的渲染时间也会越多
* 绘制图形的大小：画布上绘制的图形越大，绘图指令执行的时间也会增多，那么花费的渲染时间也会越多

总的来说，Canvas2D 绘制图形的性能还是比较高的。在普通的个人电脑上，我们要绘制的图形不太大时，只要不超过 500 个都可以达到 60fps，1000 个左右其实也能达到 50fps，就算要绘制大约 3000 个图形，也能够保持在可以接受的 24fps 以上。因此，在不做特殊优化的前提下，如果我们使用 Canvas2D 来绘图，那么 **3000** 个左右元素是一般的应用的极限，除非这个应用运行在比个人电脑的 GPU 和显卡更好的机器上，或者采用特殊的优化手段。

影响 SVG 性能的 2 大要素
* 结论与 Canvas 类似，影响 SVG 的性能因素也是相同的两点，一是绘制图形的数量，二是绘制图形的大小
* 与 Canvas 不同的是，图形数量增多的时候，SVG 的帧率下降会更明显，因此，一般来说，在图形数量小于 1000 时，我们可以考虑使用 SVG，当图形数量大于 1000 但不超过 3000 时，我们考虑使用 Canvas2D
* 那么当图形数量超过 3000 时，用 Canvas2D 也很难达到比较理想的帧率了，这时候，我们就要使用 WebGL 渲染

影响 WebGL 性能的要素
* 用 WebGL 渲染，不需要一个一个小球去渲染，利用 GPU 的并行处理能力，我们可以一次完成渲染
* 因为我们要渲染的小球形状相同，所以它们的顶点数据是可以共享的。在这里我们采用一种 WebGL 支持的批量绘制技术，叫做 InstancedDrawing（实例化渲染）
* 如果我们增大小球的半径，那么帧率也会明显下降，这一点和 Canvas2D 与 SVG 一样。小球半径增加导致帧率下降，是因为图形增大，片元着色器要执行的次数就会增多，就会增加 GPU 运算的开销。

首先，**WebGL 和 Canvas2D 与 SVG 不同，它的性能并不直接与渲染元素的数量相关，而是取决于 WebGL 的渲染次数**。有的时候，图形元素虽然很多，但是 WebGL 可以批量渲染，就像前面的例子中，虽然有上万个小球，但是通过 WebGL 的 instanced drawing 技术，可以批量完成渲染，那样它的性能就会很高。当然，元素的数量多，WebGL 渲染效率也会逐渐降低，这是因为，元素越多，本身渲染耗费的内存也越多，占用内存太多，渲染效率也会下降。

其次，在渲染次数相同的情况下，WebGL 的效率取决于着色器中的计算复杂度和执行次数。图形顶点越多，顶点着色器的执行次数越多，图形越大，片元着色器的执行次数越多，虽然是并行执行，但执行次数多依然会有更大的性能开销。最后，如果每次执行着色器中的计算越复杂，WebGL 渲染的性能开销自然也会越大。

WebGL 的性能主要有三点决定因素，**一是渲染次数，二是着色器执行的次数（包括顶点着色器和片元着色器，前者的执行次数和几何图形的顶点数有关，后者的执行次数和图形的大小有关。），三是着色器运算的复杂度（复杂度和 glsl 代码的具体实现有关，越复杂的处理逻辑，性能的消耗就会越大）**。当然，数据的大小也会决定内存的消耗，因此也会对性能有所影响，只不过影响没有前面三点那么明显。

## Canvas 绘制加速
Canvas 是指令式绘图系统，它有状态设置指令、绘图指令以及**真正的绘图方法（fill 和 stroke）**等各类 API。通常情况下利用 Canvas 绘图，我们要先调用状态设置指令设置绘图状态，然后用绘图指令决定要绘制的图形，最后调用真正的 fill() 或 stroke() 方法将内容输出到画布上。

常用的手段有 5 种，分别是
* 优化 Canvas 指令
* 使用缓存：能将图形缓存下来，保存到离屏的 Canvas（offscreen Canvas）中，然后在绘制的时候作为图像来渲染，那我们就可以将绘制顶点的绘图指令变成直接通过 drawImage 指令来绘制图像，而且也不需要 fill() 方法来填充图形，这样性能就会有大幅度的提升。
* 分层渲染：Canvas 是将上一次绘制的内容擦除，然后绘制新的内容来实现状态变化的。利用这一特点，我们就可以将变化的元素和不变的元素进行分层处理。也就是说，我们可以用两个 Canvas 叠在一起，将不变的元素绘制在一个 Canvas 中，变化的元素绘制在另一个 Canvas 中。
* 局部重绘：不需要清空 Canvas 的全局区域，而是根据运动的元素的范围来清空部分区域，在很大一部分可视化大屏项目中，我们不会让整个屏幕的所有元素都不断改变，而是只有一些固定的区域改变，所以我们直接刷新那部分区域，重绘区域中的元素就可以了。
* 优化滤镜：滤镜是一种对图形像素进行处理的方法，Canvas 支持许多常用的滤镜。不过 Canvas 渲染滤镜的性能开销比较大。可以对滤镜进行合并，让多个元素只应用一次滤镜，从而减少滤镜对性能的消耗。

此外，还有一种手段叫做多线程渲染，是用来优化非渲染的计算和交互方面导致的性能问题。
* 我们在浏览器主线程中创建 Worker，然后将 Canvas 对象通过 transferControlToOffscreen 转成离屏 Canvas 对象发送给 Worker 线程去处理。让计算过程能够并行执行不会阻塞浏览器的 UI。

缓存的局限性
* 因为缓存是通过创建离屏 Canvas 对象实现的，如果我们要绘制的图形状态（指不同形状、颜色等）非常多的话，那将它们都缓存起来，就需要创建大量的离屏 Canvas 对象。这本身对内存消耗就非常大，有可能反而降低了性能。
* 缓存适用于图形状态本身不变的图形元素，如固定的几何图形，它们每次刷新只需要更新它的 transform，这样的图形比较适合用缓存。如果是经常发生状态改变的图形元素，那么缓存就必须一直更新，缓存更新本身也是绘图过程。因此，这种情况下，采用缓存根本起不到减少绘图指令的作用，反而因为增加了一条 drawImage 指令产生了更大的开销。
* 从缓存绘制和直接用绘图指令绘制还是有区别的，尤其是在 fillText 渲染文字或者我们绘制一个图形有较大缩放（scale）的时候。因为不使用缓存直接绘制的是矢量图，而通过缓存 drawImage 绘制出的则是位图，所以缓存绘制的图形，在清晰度上可能不是很好。

## WebGL 绘制加速
原则：尽量发挥 GPU 的优势。

实际上，对于**需要重复绘制的图形，最好的办法是使用批量绘制**。重复图形的批量绘制，在 WebGL 中也叫做多实例绘制（Instanced Drawing），它是一种减少绘制次数的技术。

在 WebGL 中，一个几何图形一般需要一次渲染，如果我们要绘制多个图形的话，因为每个图形的顶点、颜色、位置等属性都不一样，所以我们只能一一渲染，不能一起渲染。但是，如果几何图形的顶点数据都相同，颜色、位置等属性就都可以在着色器计算，那么我们就可以使用 WebGL 支持的多实例绘制方式，一次性地把所有的图形都渲染出来。

如果是绘制不同的几何图形，只要它们使用同样的着色器程序，而且没有改变 uniform 变量，我们也还是可以**将顶点数据先合并再渲染**，以减少渲染次数。

批量渲染几乎是 WebGL 绘制最大的优化手段，因为它充分发挥了 GPU 的优势，所以能极大地提升性能。因此，**在实际的 WebGL 项目中，如果我们遇到性能瓶颈，第一步就是要看看绘制的几何图形有哪些是可以批量渲染的，如果能批量渲染的，要尽量采用批量渲染，以减少一帧中的绘制次数**。

另外，在前面两个例子中，我们将 id 传入着色器，然后根据 id 在着色器中用伪随机函数计算位置和颜色。这样的好处自然是渲染起来特别快，但坏处是这些数据是在着色器中计算出来的，如果我们想从 JavaScript 中拿到一些有用信息，比如，图形的位置、颜色等等，就很难拿到了。

因此，如果业务中需要用到这些信息，我们就不能将它们放在着色器中计算。当然，我们可以通过 JavaScript 来计算位置和颜色信息，然后把它们写到 attribute 中。不过这样的话，我们使用的内存消耗就会增加一些，而且用 JavaScript 计算这些值的过程会比在着色器中略慢。当然这也是因为项目需求不得不做出的选择。

其他优化手段
* 透明度与反锯齿
  * 在 WebGL 中，我们要处理半透明图形，可以开启混合模式（Blending Mode）让透明度生效。只有这样，WebGL 才会根据 Alpha 通道值和图形的层叠关系正确渲染并合成出叠加的颜色值。
  * 混合颜色本身有计算量，所以开启混合模式会造成一定的性能开销。因此，如果不需要处理半透明图形，我们尽量不开启混合模式，这样性能好就会更好一些。
  * WebGL 本身对图形有反锯齿的优化，反锯齿可以避免图形边缘在绘制时出现锯齿，当然反锯齿本身也会带来性能开销。因此，如果对反锯齿的要求不高，我们在获取 WebGL 上下文时，关闭反锯齿设置也能减少开销、提升渲染性能。
* Shader 的效率

Shader 的效率也是我们在使用 WebGL 时需要注意的。我们前面说过，为了尽可能合并数据，动态批量绘制图形，我们要求图形尽量使用同一个 WebGLProgram，并且避免在绘制过程中切换 WebGLProgram。但如果不同图形的绘制都使用同一个 WebGLProgram，这也会造成着色器本身的代码逻辑复杂，从而影响 Shader 的效率。最好的解决办法就是尽可能拆分不同的着色器代码，然后在绘制过程中根据不同元素进行切换。所以，批量绘制和简化 WebGLProgram 是一对矛盾，我们只能对两者进行取舍，尽可能让性能达到最优。

**尽量用函数代替分支**，避免一些耗时的计算，多使用简单的加法和乘法，这样能够保证着色器高效运行。

WebGL 的性能优化原则就是尽量发挥出 GPU 的优势。核心原则有两个：首先，我们尽量减少 CPU 计算次数，把能放在 GPU 中计算的部分放在 GPU 中并行计算；其次，也是更重要的，我们应该减少每一帧的绘制次数。

对应的优化方法也有两个：**一是如果我们要绘制大量相同的图形，可以利用多实例渲染来实现静态批量绘制；二是如果绘制的图形不同，但是采用的 WebGL 程序相同、以及 uniform 的值没有改变，那我们可以人为合并顶点并进行渲染。减少绘制次数一般来说对性能会有比较明显的提升**。