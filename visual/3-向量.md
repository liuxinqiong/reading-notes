目标：建立一套与各个图形系统无关联的、简单的基于向量和矩阵运算的数学体系，用它来描述所有的几何图形信息

## 向量
直角坐标系特性：不管原点和轴的方向怎么变，用同样的方法绘制几何图形，他们的形状和相对位置都不变。

由于直角坐标系的特性，因此很多时候，我们可以采用变化坐标系的方式来代替坐标换算。比如 Canvas 中 2D 上下文，经常会用到两个变换：translate 和 scale。

如果不能理解坐标系变换带来的好处，可以想像这样一个场景，在可视化的应用中，需要处理成百上千的图形，如果这个时候，在原始坐标下通过计算顶点来绘制图形，计算量会非常大，很麻烦。采用坐标变换的方式就是一个很好的思路，**能够简化计算量，不仅让代码更容易理解，也可以节省 CPU 运算的时间**

在直角坐标系下，一般是用向量来描述点和线段，比如向量 v 有两个含义
* 表示该坐标系位于 (x,y) 处的一个点
* 表示从原点 (0,0) 到坐标 (x,y) 的一根线段

向量运算
* 向量相加：两个向量 v1 和 v2，相加的结果相当于将 v1 向量的终点沿着 v2 向量的方向移动 v2 向量长度的距离
* 一个向量包含长度和方向信息
  * 长度可以用向量的 x、y 的平方和的平方根来表示
  * 方向可以用于 x 轴的夹角表示，使用 Math.atan2(y, z) 可轻松求的
* 根据三角函数，还能推导出如下公式
  * v.x = v.length * Math.cos(v.dir)
  * v.y = v.length * Math.sin(v.dir)
* 点乘：v1·v2 向量 v1 在 v2 方向的投影长度
* 叉乘
* 向量的旋转

先预习下三角函数相关公式
```shell
# 三角和差公式
tan(α+β)=(tanα+tanβ)/(1-tanαtanβ)
tan(α-β)=(tanα-tanβ)/(1+tanαtanβ)
cos(α+β)=cosαcosβ-sinαsinβ
cos(α-β)=cosαcosβ+sinαsinβ
sin(α+β)=sinαcosβ+cosαsinβ
sin(α-β)=sinαcosβ -cosαsinβ

sinα+sinβ=2sin[(α+β)/2]cos[(α-β)/2]
sinα-sinβ=2cos[(α+β)/2]sin[(α-β)/2]
cosα+cosβ=2cos[(α+β)/2]cos[(α-β)/2]
cosα-cosβ=-2sin[(α+β)/2]sin[(α-β)/2]
# 积化和差公式：
sinα·cosβ=(1/2)[sin(α+β)+sin(α-β)]
cosα·sinβ=(1/2)[sin(α+β)-sin(α-β)]
cosα·cosβ=(1/2)[cos(α+β)+cos(α-β)]
sinα·sinβ=-(1/2)[cos(α+β)-cos(α-β)]
```

向量的旋转，推导过程，点 A(x,y) 旋转 β 度，求旋转后 B 点坐标
```shell
# 假设向量 A 的方向为 α 度，
Bx = A.length * cos(α+β)
# A.length = x / cos(α)
Bx = x / cos(α) * cos(α+β)
# 根据和差公式
Bx = x / cos(α) * (cosα * cosβ - sinα * sinβ)
Bx = x * cosβ - x / cos(α) * sinα * sinβ
Bx = x * cosβ - x * tan(α) * sinβ
Bx = x * cosβ - y * sinβ
# 类似的求 By
By = A.length * sin(α+β)
By = x / cos(α) * (sinα * cosβ + cosα * sinβ)
By = y * cosβ + x * sinβ
```

看一个简单的 Vector2d.js 例子
```js
export class Vector2D extends Array {
    constructor(x = 1, y = 0) {
        super(x, y)
    }

    set x(v) {
        this[0] = v
    }

    set y(v) {
        this[1] = v
    }

    get x() {
        return this[0]
    }

    get y() {
        return this[1]
    }

    get len() {
        return Math.hypot(this.x, this.y)
    }

    get dir() {
        return Math.atan2(this.y, this.x)
    }

    copy() {
        return new Vector2D(this.x, this.y)
    }

    add(v) {
        this.x += v.x
        this.y += v.y
        return this
    }

    sub(v) {
        this.x -= v.x
        this.y -= v.y
        return this
    }

    scale(a) {
        this.x *= a
        this.y *= a
        return this
    }
    // 叉乘
    cross(v) {
        return this.x * v.y - v.x * this.y
    }
    // 点乘
    dot(v) {
        return this.x * v.x + v.y * this.y
    }
    normalize() {
        return this.scale(1 / this.length)
    }
    rotate(rad) {
        const c = Math.cos(rad)
        const s = Math.sin(rad)
        this.x = x * c - y * s
        this.y = x * s + y * c
    }
}
```