## 实现可视化的四种方式
渲染引擎绘制图形，大体有 4 中方式
1. HTML + CSS
2. SVG：弥补 HTML 在绘制矢量图形方面的能力不足
3. Canvas2D
4. WebGL：通过它，用 GPU 渲染各种复杂的 2D 和 3D 图形。WebGL 利用了 GPU 并行处理的特性，让它在处理大量数据展现的时候，性能大大优于前 3 中绘图方式

### HTML + CSS
HTML + CSS 如何实现可视化，例举几个简单场景
1. 柱状图可以通过网格布局和线性渐变实现
2. 饼图可以使用圆锥渐变
3. 折线图可以通过高度很小的 DIV 模拟线段，用 transform 改变角度和位置

缺点
* 绘制方式不简介，而且 CSS 代码中，很难看出数据与图形的对应关系
* HTML + CSS 作为浏览器渲染引擎的一部分，为了完成渲染工作，除了绘制图形外，还要做很多额外的工作，比如说，浏览器的渲染引擎在工作时，要先解析 HTML、SVG、CSS，构建 DOM 树、Render Object 树和 RenderLayer 树，然后用 HTML 或 SVG 绘图。当图形发生变化时，很可能要重新执行全部的工作，性能开销大。可视化与传统网页不同，不太需要复杂的布局，更多的是在绘图和数据计算，因此这些额外的工作相当于白白消耗了性能

因此 Canvas2D 和 WebGL 更适合去做可视化的绘图工作。他们的绘图 API 能够直接操作绘图上下文，一般不涉及引擎的其他部分，在重绘图形时，也不会发生重新解析文档和构建结构的过程，开销要小的多。

图形系统与浏览器渲染引擎工作对比
![图形系统与浏览器渲染引擎对比](imgs/图形系统与浏览器渲染引擎对比.jpeg)

### SVG
SVG 全称：Scalable Vector Graphics，可缩放矢量图

SVG 基本知识
* g 标签表示分组
* rect 标签表示矩形元素
* 其他：圆弧、椭圆、多边形和贝塞尔取现等等

> 弥补了 HTML 在不规则图形的绘制上的不足

不足
1. 在渲染引擎中，SVG 元素和 HTML 元素一样，在输出图形前都需要经过引擎的解析、布局计算和渲染树生成
2. 一个 SVG 元素只表示一种基本图形，如果要展示的数据很复杂，生成图形的 SVG 元素就会很多，大量的 SVG 元素不仅会占用很多的内存空间，还会增加引擎、布局计算和渲染树生成的开销，降低性能，减慢渲染速度

### Canvas2D
无论时 HTML/CSS 还是 SVG，他们都属性**声明式**绘图系统，根据数据创建各种不同的图形元素（或者 CSS 规则），然后引擎浏览器渲染引擎解析它们并渲染。

Canvas2D 是浏览器提供的一种可以直接用代码在一块平面的画布上绘制图形的 API，使用它来绘图更像是传统的编写代码，调用绘图指令，然后引擎直接在页面上绘制图形，这是一种**指令式**的绘图系统

为了实现复杂的效果，Canvas2D 还提供了丰富的设置和绘图 API
* 操作上下文，来改变填充和描边颜色
* 对画布进行几何变化
* 调用各种绘图执行
* 将绘制的图形输出到画布上

值得注意的是，HTML/CSS 和 SVG 一个元素对应一个基本图形，所以可以很方便的操作它们，比如注册点击事件。但这样的功能在 Canvas2D 上就比较难实现了。因为对于 Canvas 来说，就是一系列指令的执行过程，无法分别具体哪个元素，因此很难单独对 Canvas 绘图的局部进行控制。**需要通过数学计算，通过定位的方式来获取局部元素**

### WebGL
WebGL 相比前三种方式要复杂很多，API 相对更底层，使用起来也不如前三种简单直接。

通常 Canvas2D 的绘制图形性能已经足够搞了，下面三种情况我们有必要直接操作更强大的 GPU 来实现绘图
* 绘制的图形数量非常多
* 对较大图像的细节做像素处理，比如光影、流体效果和一些复杂的像素滤镜
* 绘制 3D 物体，WebGL 内置了对 3D 物体的投影、深度检测等特性

### 总结
技术方案选择
![技术方案选择](imgs/技术方案选择.jpeg)

## 指令式绘图系统 - Canvas
Canvas 元素上的 width 和 height 属性不等同于 Canvas 元素的 CSS 样式属性。
* 样式宽高：CSS 元素中的宽高影响 Canvas 在页面上呈现的大小
* 画布宽高：HTML 属性中宽高决定了 Canvas 元素的坐标系
* 实际绘制时，如果不设置 Canvas 元素的样式，则画布宽高就会等于样式宽高的像素值

为什么会出现两种方式呢：将画布宽高和样式宽高分开的做法，能更方便的适配不同的显示设备。因为这样我们就会有一个确定大小的坐标系，无论这个 Canvas 以多大的尺寸显示在各种设备上，我们的代码都不需要修改。否则如果 Canvas 的坐标范围（画布宽高）更着样式宽高比变化的话，那么当屏幕尺寸发生改变的时候，就要重新计算需要绘制的图形的所有坐标，这会是一场灾难。

坐标系和浏览器窗口的坐标系类似
* 左上角为坐标原点，x 轴水平向右，y 轴垂直向下
* 和笛卡尔坐标系不同，y 轴是相反的
* 考虑旋转或者三维运动，这个坐标系就会变成左手系

绘制图形的步骤
1. 获取 Canvas 上下文
  1. 获取 Canvas 元素
  2. 通过 getContext 获取上下文对象，传入 2d 参数
2. 利用上下文绘制图形

Context API 分类
* 设置状态的 API，可以设置或改变当前的绘图状态，比如改变图形的颜色、线宽、坐标系变化等
* 绘图指令 API，用来绘制不同形状的几何图形

简单例子
```js
const rectSize = [100, 100]
context.fillStyle = 'red'
// 开始绘制
context.beginPath()
context.rect(0.5 * canvas.width, 0.5 * canvas.height, ...rectSize)
// 将绘制内容真正输出到画布中
context.fill()
```

上面的例子绘制的矩形并没有在中心处，原因都懂，有两种方式解决
1. 手动计算 x，y 的坐标：这种方式就是简单，直接改变图形顶点的坐标位置。如果我们要绘制的不是矩形，而是很多顶点的多边形，就需要重新计算出每个顶点的位置，这会非常麻烦
2. 先给画布设置一个平移变化，然后在进行绘制：不需要去改变图形的顶点位置。但改变的画布的状态，如果后续还有其他图形需要绘制，需要记得把画布状态恢复回来

平移变化
```js
context.translate(-0.5 * rectSize[0], -0.5 * rectSize[1])
```

如何恢复画布状态
* 第一种反向平移
* 利用 save 和 restore 方式，可以暂存和恢复画布某个时刻的状态
  * save 指令不仅可以保存 translate 状态，还可以保存其他信息，比如 fillStyle 等颜色信息
  * restore 将状态恢复成 save 指令前的设置

Canvas 的优缺点
* 渲染效率高
* Canvas 在 HTML 层面上是一个独立的画布元素，所以所有的绘图内容都是在内部通过绘图指令来完成的，绘制出来的图形对于浏览器来说，只是 Canvas 中的一个个像素点，很难直接抽取其中的图形对象进行操作。比如 HTML 和 SVG 中绘制一系列图形的时候，我们可以一一获取这些图形的元素对象，然后绑定用户事件。但同样的操作在 Canvas 中没有可以实现的简单方法

思考题
* 如何判断点是否在某个图形内
* Canvas 中如何局部清除和局部重绘

## SVG
全称是 Scalable Vector Graphics，可缩放矢量图，是浏览器支持的一种基于 XML 语法的图像格式。

SVG 既可以用 JavaScript 操作绘制各种几何图形，还可以作为浏览器支持的一种图片格式，使用 img 标签加载或者通过 Canvas 绘制。

SVG 属于声明式绘图系统，绘制方式和 Canvas 不同，不需要使用 JavaScript 来操作绘图 API，只需要和 HTML 一样，声明一些标签就可以实现绘图了。

SVG 坐标系
* 和 Canvas 完全一样，同时默认情况下与浏览器像素对应
* 可以通过给 svg 元素设置 viewBox 属性，来改变 svg 坐标系，也就是设置画布坐标

绘制步骤
1. 获取 SVG 对象
2. 通过创建 SVG 元素，将元素添加到 DOM 文档里，让图形显示出来

基础知识
* SVG 元素需要通过 document.createElementNS 来创建
* SVG 的 g 元素表示一个分组，可以用它来对 SVG 元素建立起层级结构，如果给 g 元素设置属性，那么子元素会继承这些属性

SVG 与 Canvas 不同
* 写法上不同：声明式和指令式
  * SVG 元素需要由浏览器负责渲染和管理，会有 DOM 操作开销
* 用户交互不同
  * SVG 非常大的优点，就是可以让图形的用户交互非常简单
  * Canvas 实现用户交互，就需要经过数学计算了
* 性能问题，一般情况下， 当 SVG 节点超过 1000 个时，就能很明显感觉到性能问题

## WebGL
计算机图形系统的主要组成部分
* 光栅（Raster）：几乎所有现在图形系统都是基于光栅来绘制图形的，光栅就是指构成图像的像素阵列
* 像素（Pixel）：一个像素对应图像上的一个点，通常保存图像上的某个具体位置的颜色等信息
* 帧缓存（Frame Buffer）：绘图过程中，像素信息被存放于帧缓存中，帧缓存是一块内存地址
* CPU：中央处理单元，负责逻辑计算
* GPU：图形处理单元，负责图形计算

绘图过程中主要做的两件事
* 对给定的数据结合绘图的场景要素（相机、光源、遮挡物体等等）进行计算，最终将图形变为屏幕空间的 2D 坐标
* 为屏幕空间的每个像素点进行着色，把最终完成的图形输出到显示设备上
* 整个步骤是一步一个进行的，前一步的输出就是后一步的输入，所以我们也把这个过程叫做渲染管线

GPU 是什么

先来看 CPU，CPU 像一个大的管道，等待处理的任务就像时依次通过这个管道的获取。一条 CPU 流水线串行处理这些任务的速度，取决去 CPU 的处理能力。实际上一个计算机系统会有很多条 CPU 流水线，任何一个任务都可以随机地通过任意一个流水线，这样计算机就能够并行处理多个任务了。这样的一条流水线就是常说的线程（Thread）

处理图像应用，实际上就是在处理计算图片上的每一个像素点的颜色和其他信息。每处理一个像素点就相当于完成了一个简单的任务，而一个图片应用又是由成千上万个像素点组成，所以需要同时处理成千上万个小任务。

要处理这么多小任务，比起使用若干个强大的 CPU，使用更小、更多的处理单元，是一种更好的处理方式。GPU 就是这样的处理单元。

GPU 是由大量的小型处理单元构成，可能远远没有 CPU 那么强大，但胜在数量众多，可以保证每个单元处理一个简单的任务。

WebGL 绘制步骤（绘制一个三角形）
1. 创建 WebGL 上下文
2. 创建 WebGL 程序（WebGL Program）
  * 是给 GPU 最终运行着色器的程序
  * 编写两个着色器，着色器是用 GLSL 编程语言编写的代码片段
    1. 编写顶点着色器和片元着色器代码片段
    2. 使用代码片段创建对应的 shader 对象，包括创建 shader、指定 shader 对应的代码片段，编译 shader 三个步骤
  * 创建 WebGLProgram 对象，将这两个 shader 关联到 WebGLProgram 程序上。保存创建 program，关联 vertexShader 和 fragmentShader，将 program 链接到 WebGL 上下文对象上
  * 通过 useProgram 启用这个对象
3. 将数据存入缓冲区
  * 创建缓存对象
  * 绑定为当前操作对象
  * 再把数据写入缓存区
4. 将缓存区数据读取到 GPU
  * GLSL 中 attribute 表示声明变量，vec2 是变量的类型，表示一个二维向量
  * 将 buffer 的数据绑定给顶点着色器的 position 变量
5. GPU 执行 WebGL 程序，输出结果
  * 调用绘图指令，执行着色器程序完成绘制
  * gl.clear 清除画布内容
  * gl.drawArrays 传入绘图模式

为什么创建两个着色器呢。需要理解顶点和图元，**WebGL 是以顶点和图元来描述图形几何信息的**
* 顶点：几何图形的顶点
* 图元：WebGL 可直接处理的图形单元，由 WebGL 的绘图模式决定，有点、线、三角形等

因为 WebGL 绘制一个图形的过程，一般需要用到两段着色器
* 一段叫做顶点着色器（Vertex Shader）：处理顶点的 GPU 程序代码，可以改变顶点的信息（比如坐标、法线方向、材质等），从而改变绘制出来的图形的形状或者大小
* 一段叫做片元着色器（Fragment Shader）：根据顶点和绘图模式指定的图元，计算出需要着色的像素点，然后对它们执行片元着色器程序。简单来说就是对指定图元中的像素点着色。片元着色器对像素点着色的过程是并行的，无论有多少个像素点，片元着色器都可以同时处理。

WebGL 从顶点着色器和图元提取像素点给片元着色器执行代码的过程，就是生成光栅信息的过程。**片元着色器的作用，就是处理光栅化后的像素信息**

举个例子
* 如果将图元设为线段，那么片元着色器就会处理顶点之间的线段上的像素点信息，这样画出的图形就是空心的
* 如果将图元设为三角形，那么片元着色器就会处理三角形内部的所有像素点，这样画出来的图形就是实心的

> 因为图元是 WebGL 可以直接处理的图形单元，所以其他非图元的图形最终必须要转换为图元才可以被 WebGL 处理，比如四边形，需要拆分成两个三角形再交给 WebGL 处理

WebGL 坐标系
* 右手坐标系，x 朝右，y 朝上，z 朝外
* z 轴，y 轴在画布的范围是 -1 到 1

> 定义三角形的三个顶点，WebGL 使用的数据需要使用类型数组定义，默认是 Float32Array。JavaScript 通常使用类型化数组来处理二进制缓冲区

顶点着色器的作用
* 通过 gl_Position 设置顶点
* 通过 varying 变量，向片元做着色器传递数据，这些值会根据片元着色器的像素坐标和顶点像素坐标的相对位置做**线性插值**

WebGL 支持的图元尅行
* POINTS 点
* LINES 线
* LINE_STRIP 线条
* LINE_LOOP 回路
* TRIANGLES 三角形
* TRIANGLE_STRIP 三角带
* TRIANGLE_FAN 三角扇
