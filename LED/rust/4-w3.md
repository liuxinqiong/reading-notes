主要学习模块系统

## 背景
编写大型程序时，组织你的代码显得尤为重要
* 通过对相关功能进行分组和划分不同功能的代码，你可以清楚在哪里可以找到实现了特定功能的代码，以及在哪里可以改变一个功能的工作方式
* 封装实现细节可以使你更高级地重用代码，公有还是私有
* 作用域

> 对于一个由一系列相互关联的包组合而成的超大型项目，Cargo 提供了 “工作空间” 这一功能

Rust 模块系统的组成
* Package：允许你构建、测试和分享 crate
* Crates：一个模块的树形结构，形成了库或二进制项目
* Modules 和 use：控制作用域和路径的私有性
* Path：一个命名，例如结构体、函数或模块等项的方式

Package 和 Crates
* 包是提供一系列功能的一个或者多个 crate，一个包会包含有一个 Cargo.toml 文件，阐述如何去构建这些 crate
* crate 是一个二进制项或者库，crate root 是一个源文件，Rust 编译器以它为起始点，并构成你的 crate 的根模块

包中所包含的内容由几条**规则**来确立
* 一个包中至多只能包含一个库 crate（library crate）
* 包中可以包含任意多个二进制 crate（binary crate）
* 包中至少包含一个 crate，无论是库的还是二进制的

Cargo 遵循的一个约定
* `src/main.rs` 就是一个与`包同名`的二进制 crate 的 crate 根
* 如果包目录中包含 `src/lib.rs`，则包带有与其同名的库 crate，且 `src/lib.rs` 是 crate 根
* 通过将文件放在 `src/bin` 目录下，一个包可以拥有多个二进制 crate：每个 `src/bin` 下的文件都会被编译成一个独立的二进制 crate。
* crate 根文件将由 Cargo 传递给 `rustc` 来实际构建库或者二进制项目

模块
* 模块的优势
  * 将一个 crate 中的代码进行分组，以提高可读性与重用性
  * 可以控制项的私有性，如果你希望创建一个私有函数或结构体，你可以将其放入模块
* 模块的定义
  * mod 关键字定义
  * 模块可以嵌套
  * `整个模块树`都植根于名为 `crate` 的隐式模块下。OK，记住 `crate`，它会在路径引用时帮助到我们
  * 默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项
  * `super` 开头来构建从父模块开始的相对路径，`self` 表示自身开始的相对路径，**通常在模块中比较常用**
* pub 关键字
  * 如果我们在一个结构体定义的前面使用了 pub ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的
  * 如果我们将枚举设为公有，则它的所有成员都将变为公有
* use 关键字：使用 use 将名称引入作用域
  * **一次性将路径引入作用域**，多次使用时可以使用更短的路径
  * 支持搭配绝对路径，也支持相对路径
  * 在作用域中增加 use 和路径类似于在文件系统中创建软连接
  * 使用 use 将函数引入作用域的习惯用法：使用 use 将函数的父模块引入作用域，我们必须在调用函数时指定父模块，**这样可以清晰地表明函数不是在本地定义的，同时使完整路径的重复度最小化**。
  * 使用 use 引入结构体、枚举和其他项时，习惯是指定它们的完整路径。除非名词相同，不得已为之
* as 关键字
  * 使用 as 指定一个新的本地名称或者别名。
* re-exporting
  * pub use：Bring into scope and reexport from here.
  * 方便开发这个库的程序员和调用这个库的程序员之间组织起来。

路径用于引用模块树的项
* 绝对路径：从 crate 根开始，以 crate 开头
* 相对路径：从当前模块开始，以 self、super 或当前模块的标识符开头
* 一个或多个由双冒号（::）分割的标识符

> 注意标准库（std）对于你的包来说也是外部 crate。因为标准库随 Rust 语言一同分发，无需修改 Cargo.toml 来引入 std

模块进行文件分割
* mod 关键字进行模块声明，与模块定义的区别是结尾使用分号，这将告诉 Rust 在另一个与模块同名的文件中加载模块的内容。
* 有了 mod 声明语法，我们可以将 mod 声明在不同文件中
* mod 是通过同名文件来加载模块的，因此你需要保证有对应的同名文件，如果你相对 mod 进一步拆分成更多文件，通过建立同名文件夹的方式进行管理
* 上述通过同名文件 + 同名文件夹的方式进行模块管理，看上去不够内聚。我们还可以基于一个约定，也就是在文件夹中建立 `mod.rs` 文件，作用和上述方式的同名文件一样，不同的是放在文件夹中，**推荐用法**