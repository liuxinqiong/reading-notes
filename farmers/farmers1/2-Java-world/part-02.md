## 日志系统
Java 帝国诞生初期就提供了集合、线程、I/O、网络等常用功能更，但是却忽略了一个重要的领域：输出日志

日志是一个很重要的东西，因为程序运行起来以后，基本上就是一个黑盒子，如果程序的行为和预料的不一致，那么要如何定位bug呢。

日志系统功能
1. 日志消息除了能打印到控制台，还可以输出到文件，甚至可以通过邮件发送出去
2. 内容可以格式化，如变成纯文本、XML、HTML格式等
3. 对于不同的Java class，不同的package，以及不同级别的日志，可以灵活的输出到不同的文件中
4. 能对日志进行分级（DEBUG、INFO、WARN、ERROR、FATAL），比如debug日志，在本机或者测试环境下使用，方便程序员进行调试，error日志，在生产环境下出错必须记录下来

于是Log4j就诞生了，意思是Log for Java。

直到JDK 1.4后，Java 在官方提供了 java.util.logging 包，其中核心概念Logger/Formatter/Handler和Log4j非常相似，但是Log4j早已深入人心，地位不可撼动了。

后续作者对Log4j进行了重写，叫做Logback，运行速度比Log4j还要快。

日志系统有了更多的选择，除了java.util.logging和Log4j外，还有Logback，tinylog等工具。

于是为了方便使用者移植，作者提供了一个抽象层，用户用这个抽象层的API来写日志，至于底层用什么日志工具并不关心。抽象层取名Simple Logging Facade for Java。简称SLF4J。

## 序列化-咸鱼翻身
序列化：把一个Java对象编程二进制的字节流，或者反过来，把字节流编程Java对象

设计思考：网络就是计算机，一个个Java对象应该可以在网络中到处旅行，从一台机器出发时，变成二进制字节流，到达另外一代机器，摇身一变，编程Java对象继续运算

另一个功能就是：既然可以以二进制的方式在网络中漫游，自然也可以把这些字节流存储到硬盘中，当JVM停机时，可以等待JVM重生，把对象恢复

> 序列化可以让Java对象跨越时间和空间永生

> Java RPC：通过序列化，开发人员可以轻松地调用远程服务器上的Java方法，就像调用本地方法一样

致命缺点：严重依赖Java环境，在服务端这不是问题，但是Web兴起时，一个浏览器是很难有Java环境的

### XML 和 JSON
这里就比较讲到这两个家伙了。

有一段时间，Java序列化的工作都交给XML做，但是XML有个缺点，太复杂了。你需要把类中的各个字段和它们的值变成XML标签/属性/值才行，当XML字符串漫游到另一台机器时，还得有一堆代码把XML变成对象

> Java对象序列化，大部分情况下只需要让你的类实现Serializable接口，序列化就可以接管后续的所有工作，不用你操心了

XML有个优势，语言中立，在这里是Java对象，到了客户端什么语言都可以。但是标签冗余太多，真正的数据很少，在网络上传输是一种浪费。

序列化也有个优势，二进制的，非常紧凑，不浪费

于是JSON出来，JSON数据格式精简，同样语言中立，这也是现在用的最多的传输方式，在Web时代，JSON和JavaScript是一对绝配，联手统治了浏览器

### 翻身
二进制序列化方式能减少存储空间，方便网络传输，硬伤就是无法跨越语言。于是我在想：如果我支持多语言呢？

> 计算机所有的问题都可以通过增加一个中间层来解决

这个中间层的主要任务就是定义/描述信息的格式，通过一个编译器，把自定义的消息格式转换成各种语言的实现。

这样一来，既语言中立，又采用二进制传输，体积小，解析速度快，完美综合了各种优点。唯一的额外工作就是需要把消息格式的定义编译成各种语言的实现

## 加锁
锁是个好东西，没有锁，多个线程并发的读写共享资源就会出错，线程中最常用的互斥锁。

所谓互斥，就是同一时刻只有获得锁的那个线程才有资格去操作共享资源，其他线程都被阻塞，被放到一个锁池的地方，什么事情都做不了

要不要加锁？不加锁如何保证正确性呢？
1. 从内存中读取value值，假设为10，称为A
2. B = A + 1得到B = 11
3. 用A的值和内存的值相比，如果相等（说明过去一段时间里，没人修改内存value的值），就把B的值写入内存，如果不相等（说明过去一年时间里，有人修改了内存的值），就意味着A的值已经不是最新的值了，那就放弃这次修改，跳回第一步。

但是很明显，第三步不是原子操作，并发执行的时候还是会出问题，这里可以在底层解决，将第三步Compare and Swap这是一条硬件指定，操作系统和硬件能保证原子执行。Compare and Swap简称CAS。

在Java中如何实现读取内存的值和compareAndSwap函数呢，通过JNI（Java Native Interface），用C语言实现，然后在Java中封装一下。

> synchronized叫做悲观锁，使用CAS，每个线程不用阻塞，毕竟，对于阻塞而言，激活是一笔不小的开销

一开始CAS只支持简单的类型，对于复杂的数据不方便使用CAS，因为CAS需要频繁的读写内存数据，并且进行数据的比较，如果数据结构很复杂，那么读写内存是不可承受之重，这就还不如最早的悲观锁了。

那么是否可以不比较数据，只比较两个对象的引用呢。这里会有个ABA问题
1. 线程1读出内存的数值为A，然后让出CPU
2. 线程2也读到了A，改成了B，然后又把B改成值A
3. 线程1开始运行，发现内存值还是A，完全不知道内存被操作过

在这里如果是简单类型，结果不会有什么问题，可以如果是引用类型就存在问题了。作者通过链表的方式解释了这个问题，我就不描述了，打字不好表达

解决办法，既然引用相同，在加入一个版本号们，每个放入AtomicReference的对象都加入一个version，这样一来，尽管引用相同，但也是区分了

## Spring
软件系统设计时，一项非常重要的工作就是把一个大系统按业务功能分解成一个个低耦合、高内聚的模块，分而治之，但分解之后就会发现有些东西是通用的，或者跨越多个模块的
* 日志：对特定操作输出日志来记录
* 安全：对执行操作之前进行操作检查
* 事务：在方法开始之前要开始事务，在方法结束后要提交或者回滚事务
* 性能统计：要统计每个方法的执行时间

这些非功能性需求，是多个业务模块需要的，是跨越模块，该怎么办呢
* 每个业务函数都写一遍？
  * 这些代码几乎把真正的业务代码淹没了
  * 重复代码会非常多
* 模版方法：一个抽象类，业务代码继承抽象类实现业务函数，抽象类中定义执行函数，内容调用业务函数和通用函数
  * 父类定义一切，子类只能无条件接受，完全没有反抗的余地
  * 比如某个子类不需要事务支持，也没办法去除
* 装饰者模式
  * 面向接口编程，通用函数和业务函数都实现执行接口
  * 有点像对象组合
  * 缺点：都强制实现指定接口
* AOP
  * 把非功能性代码和业务代码完全隔离开，因为他们的关注点和业务代码的关注点完全不同，它们之间应该是正交的
  * 切面，切入点，通知

实现AOP
* 切面类：普通Java类，不需要实现乱七八糟接口
* 切入点：要加入非功能函数的方法
* 通知：方法调用之前/之后

但Java是静态强类型语言，代码一旦写好，编译成Java类以后，就可以在运行时通过反射来查看类的信息，但是想要对编译好的类进行修改是不可能的，如何突破这个限制呢
* 修改现有类：在编译的时候做手脚，根据AOP的配置信息，将非功能代码和业务类编译到一起，这种方法需要增强编译器，并且业务类会改变
* 满天过海：运行期间做手脚，在业务类加载以后，为该业务类动态地生成一个代理类，让代理类去调用执行这些切面代码。增强现有的业务类，业务类不用进行改变，实际上，客户直接使用过的是代理类对象，而不是原有的业务类对象

生成代理类方案
* 使用Java动态代理技术，这种技术要求业务类必须有接口才能工作
* 使用CGLib，只要业务类没有被标记为final就可以，因为会生成一个业务类的子类作为代理类

经过AOP增强的类，已经不是原有的类了，而是一个新的类，这个新的类是自动生成的，那么我该如何得到实例去使用呢？

这是就需要“容器”了，接管创建对象的艰巨任务。

在Java对象中，最早的时候，我们需要自己去创建自己所依赖的对象，有了Spring容器介入，所以依赖关系都由容器搞定，于是控制就反转了。Inversion of Control，简称IoC。

但是IoC这个词不够直观和清晰，又叫依赖注入（Dependency Injection，DI）