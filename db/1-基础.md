## 三范式
范式的目的：它是减少表中数据冗余，同时提高数据完整性的过程。

如果没有范式，我们可能会面临如下问题
* 插入异常：当我们无法在没有其他属性的情况下将数据插入表格
* 更新异常：由于数据冗余和数据部分更新而导致的数据不一致
* 删除异常：某些属性由于其他属性的删除而丢失

在关系数据库中，关系不是随便来的，有一定要求，这就是范式
* 第一范式：最低要求，即关系数据中每个属性都不可再分，处理原子性问题
  * 如果表包含复合属性或多值属性，则违反第一范式
* 第二范式：要求非主属性对码都是完全函数依赖
  * 假设表中有员工号、部门号和办公地点三个属性，表中的码为员工号+部门号，但办公地点仅由部分决定，因此不是完全依赖
  * 要满足第二范式，则需要拆成两个表，一个表由员工号和部门号组成，一个由部门号和办公地点组成
* 第三范式：消除非主属性对于码的传递函数依赖
  * 非主属性不应该依赖于给定表中的其他非主属性
  * 假设表中有 StudentID/StudentName/SubjectId/Subject/Address，SubjectID 决定 Subject，StudentID 决定 SubjectID，从而导致 StudentID 通过 SubjectID 间接决定了 Subject。备注：其实例子不太合适，假设一个学生只能选一门课
  * 要满足第三方式，应有表1(StudentID/StudentName/SubjectId/Address)和表2(SubjectID/Subject)
* Boyce Codd Normal Form (BCNF)，又叫做 3.5NF
  * 解决 3NF 未处理的某些类型的异常
  * 如果 A 能决定 B，则 A 必须是某个特定表的主键

> 码指的是表中一个属性或属性组，其他所有属性都完全依赖于这个属性或属性组。可理解成主键。

范式化消除了数据的冗余，不会产生数据的插入、修改、删除的问题。但需要提醒大家的是，完全范式化和完全反范式化都是不切实际的，在真实的项目中不会非黑即白，经常需要混用。

第一范式每个属性不可再分，可能会比较隐蔽
* 一个字段包含了多个信息，如 address = city1,street，当然形式多种多样，如 json 也可以
* 多个字段存储相同信息，如 Vendor 1, Vendor2

### 范式补充
关于数据库范式:根据规则创建表并在这些表之间建立关系，这些规则既**可以保护数据，又可以通过消除冗余和不一致的依赖关系**使数据库更加灵活。
* 冗余数据会浪费磁盘空间以及造成维护困难问题
* 不一致的依赖：不一致的依赖关系可能使数据难以访问，因为查找数据的路径可能丢失或损坏
* 虽然可能存在其他级别的规范化，但第三种规范化被认为是大多数应用程序所需的最高级别
* 与许多正式规则和规范一样，现实世界的场景并不总是允许完美的遵从性。通常规范化需要额外的表，有些客户觉得这很麻烦。如果您决定违反前三条规范化规则中的一条，请确保您的应用程序预见到可能发生的任何问题，例如冗余数据和不一致的依赖项

第一范式
* 消除各个表中的重复组
* 为每组相关数据创建一个单独的表
* 用主键标识每组相关数据

第一范式举例：不要在单个表中使用多个字段存储相似数据
* 为了跟踪可能来自两个可能来源的库存项目，库存记录可能包含供应商代码1和供应商代码2的字段。
* 如果你需要添加第三个供应商该如何处理呢？添加字段并不是答案，它需要修改程序和表，并且不能顺利地适应动态数量的供应商。相反，应将所有供应商信息放在名为 Vendors 的单独表中，然后使用外键将库存链接到供应商。

第二范式
* 记录不应该依赖于表的主键(必要时是复合键)以外的任何内容
* 为应用于多个记录的值集合创建单独的表
* 用外键关联这些表

第二范式举例
* 考虑客户地址问题，客户表需要地址，但订单、运输、发票同样也需要
* 不要将客户地址作为单独的条目存储在每个表中，而是将其存储在一个地方，要么存储在 Customers 表中，要么存储在单独的 Addresses 表中。

第三范式
* 消除不依赖于键的字段
* 记录中不属于该记录键的值不属于表。通常，当一组字段的内容可能应用于表中的多条记录时，请考虑将这些字段放在单独的表中。如果大学信息存储在candidate表中，则无法列出当前没有候选人的大学。创建一个单独的 Universities 表，并使用大学代码键将其链接到 candidate 表
* 坚持第三范式，虽然理论上是可取的，但并不总是实际的。理论上，正常化是值得追求的。但是，许多小表可能会降低性能或超过打开文件和内存容量。只对频繁变化的数据应用第三种范式可能更为可行。如果仍然存在一些依赖字段，那么在设计应用程序时要求用户在更改任何一个字段时验证所有相关字段。

第三范式举例
* 员工候选表：候选人的大学名称和地址可以包括在内。但是你需要一份完整的大学名单来进行群发。

相关资料
* [What is Normalization in SQL and what are its types?](https://www.edureka.co/blog/normalization-in-sql/)
* [Description of the database normalization basics](https://learn.microsoft.com/en-us/office/troubleshoot/access/database-normalization-description)

## 锁
排他锁：Exclusive Lock，简称 X 锁，如果需要写数据，用 X 锁锁住，除非被释放，锁着其他人无法获得 X 锁。

共享锁：Share Lock，简称 S 锁，这个锁和排他锁 X 有区别，主要用于读数据，如果一个数据加了 X 锁，就没法加 S 锁，加了 S 锁就没法加 X 锁。

隔离级别
* Read uncommitted：最低事务隔离级别，写数据时加上 X 锁，直到事务结束，读的时候不加锁，虽然能够避免 `数据丢失`，但是可以读到没有提交或者回滚的内容（`脏数据`）
* Read committed：第二事务隔离级别，写数据时加上 X 锁，直到事务结束，读的时候加上 S 锁，读完数据立即释放，能避免 `数据丢失` 和 `脏数据`，但是会出现不可重复读问题
* Repeatable Read：写数据的时候加上 X 锁，直到事务结束，读数据的时候加 S 锁，也是直到事务结束。这能避免 `数据丢失`，`脏数据` 和 `不可重复读` 三个问题，这事数据库库隔离级别
* Serializable: 串行化，避免上述三个问题 + 幻读问题

## 断电保存
数据库解决断电数据丢失问题
* Undo 日志
* Redo 日志
* 幂等性

## NoSQL
相关资料
* [Differences Between SQL & NoSQL Databases – MySQL & MongoDB Comparison](https://www.edureka.co/blog/sql-vs-nosql-db/)

提供存储和检索非结构化数据的机制，这种类型的数据库可以处理大量的数据，并且具有动态模式，因此 NoSQL 数据库没有特定的查询语言，没有或很少的关系，数据以集合和文档的格式存储。

NoSQL 更适合分层数据存储，这是因为随着表数量的增加，维护它们之间关系的复杂性也在不断增加。因此，在这种情况下，您无法将包含许多列的大量表彼此关联起来。但是，当您考虑 NoSQL 数据库时，这种数据库更适合分层数据存储，因为它遵循类似于 JSON 数据的键值对存储数据的方式。

SQL数据库用于重型交易类型应用程序。因为SQL提供了数据的原子性，完整性和稳定性。另外，您可以将 NOSQL 用于交易目的，但是，在高负载和复杂的交易应用中，它仍然不够稳定。因此，您可以理解 SQL 主要用于 OLTP（在线交易处理），而 NOSQL 主要用于 OLAP（在线分析处理）