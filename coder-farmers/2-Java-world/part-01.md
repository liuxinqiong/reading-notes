## Java 帝国
C语言帝国
* 优势：贴近硬件，运行极快，效率极高
* 枷锁：指针和内存管理

为了实现跨平台，我们在操作系统和应用程序之间增加了一个抽象层：Java虚拟机。用Java写的程序都运行在虚拟机上，除非个别情况，都不用看到操作系统。

Java三只军队
* Java 2标准版（J2SE）：去占领桌面
* Java 2移动版（J2ME）：去占领移动端
* Java 2企业版（J2EE）：去占领服务端

其中两只大军很快败下阵来，失之东隅，收之桑榆，J2EE赶上了好时候。

2006年，一直Hadoop的军队让Java王国入侵了大数据领域，由于使用了Java语言，绝大多数程序员在理解了Map/Reduce、分布式文件系统在Hadoop中的实现以后，很快就能编写处理海量数据的程序。

2008年，Android系统横空出世，Java在Google的支持下，以一种意想不到的方式占领了手机端，完成了当年J2ME壮志未酬的事业。

Java占据了大部分的服务端开发，尤其是关键的、复杂的系统，绝大多数的手机端，以及大部分的大数据领域。

## Java Class
BootStrap ClassLoader -> Extensiton ClassLoader -> App ClassLoader

文件验证器：检查分析，确保每条指令都是正确的，检查是不是有超类，是不是覆盖了final方法，跳转指令是不是正确等。

方法区

工作台，台上立了一只有很多抽屉的柜子（局部变量区），每个抽屉上都有一个编号，旁边还有个深桶（操作数栈）

有时候线程不止有一个工作台，而是一摞工作台，一个压一个。线程们永远在最上面那个工作台上工作。从来不会先干下面的活儿。这些工作台也是栈，学名Java函数栈，每个台子代表一个方法调用，这一摞工作台就是一个方法的调用链。

堆，在堆中会有清理者，专门清理没用的对象，比如一个局部变量，方法结束后，就没人引用了，白白的占用空间，如果不清理，很快就会 Out Of Memory 了。

具体堆区有多大，是由码农决定的，在启动虚拟机的时候会指定参数。

如何知道谁有用，谁没用呢？

可达性分析，清理者掌握着一些叫做GC Roots的对象，从这些节点出发四处搜索被GC Roots直接引用的对象，然后再找这些对象🔒引用的对象这么一层一层找下去，就形成了一条以GC Roots为起点的引用链条，如果你不在这条链条上，那就很有可能被清理掉了

## 持久化
内存数据易失性（断电威胁）

背景：直接操作硬盘数据太慢，同时冯诺伊曼要求，数据必须在内存中，CPU才能操作。

序列化与反序列化：把内存中重要对象转换为二进制文件存储在硬盘上，同时可以反序列化，将二进制文件编程Java对象，继续在内存中干活。弱点：效率低

关系数据库
* 类似二维表格方式存储数据，可以进行大规模的数据存储和查询
* 事务操作
* SQL：屏蔽了具体的实现细节和各个数据库之间的差异

Object-Relational Mapping：对象属性变成数据库的行/列

JDBC：Java Database Connectivity

> JAVA语言只负责定义接口，具体JDBC实现必须由各个数据库提供

问题来了，JDBC是一个非常低级的接口，导致程序员需要处理大量的细节，冗余代码太多，写一个简单的查询就需要大堆代码伺候
1. 打开Connection
2. 创建Statement
3. 执行SQL
4. 遍历ResultSet
5. 关闭Connection

ORM框架的发展：EJB -> Hibernate -> iBatis -> Spring

> Spring不但自己提供了轻量级访问数据库的方法JdbcTemplate，还能轻松地集成Hibernate、iBatis等一批工具，慢慢的成为事实的标准

## JDBC的诞生
JDBC初期设计：直接使用Socket编程太低级了，必须有一个抽象层屏蔽这些细节。否则针对不同数据库需要书写几套代码，想来也是很痛苦的。

于是抽象出一个JDBC抽象层，有Connection、Statement、ResultSet这些概念，由Connection可以创建Statement，Statement执行查询可以得到ResultSet，然后ResultSet提供了对数据遍历的方法，比如rs.next()、rs.getXXX()，然后他们都只是接口，具体实现需要由各个数据库或者第三方来提供。

接下来通过工厂模式、配置文件、反射进一步抽象，JDK只负责定义JDBC相关接口，实现几乎全交给各个数据库厂商

## 分布式事务与消息队列
事务的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），简称ACID。

当数据量大到一定程度，势必要拆分数据库，就会出现跨数据库的事务，当一个业务同时操作多个数据库时，没有分布式事务是实现不了的。

两阶段提交，设定一个全局的事务管理器，负责协调各个数据库的事务提交
1. 阶段1：全局事务管理器向各个数据库发出准备消息，各个数据库需要在本地把一切都准备好，执行操作，锁住资源，记录redo/undo日志，但并不提交。总而言之，进入一种时刻准备提交或回滚的状态，然后向全局事务管理器报告是否准备好了
2. 阶段2：如果所有的数据库都报告准备好了，全局事务管理器就下命令：提交。这时候才真正提交，由于都已准备完毕，只需要快速完成本地提交即可。如果有任何一个数据库报告没准备好，那么全局事务管理器就下命令，放弃，这个时候各个数据库执行回滚操作，并且释放在阶段1锁住的各种资源

于是JPA（Java Transction API）诞生了，但是JPA和EJB一样发展不是很好。

主要原因是分布式事务伴随着大量节点的通信交换，协调者要确定其他节点是否完成，加上网络带来的超时，导致JPA性能底下，在分布式、高并发和要求高性能的场景下举步维艰

总想着让两个数据库保证实时的一致性（强一致性），JPA付出的代价太高了。我们可以忍受一段时间的不一致，只要最终一致就行，这就是最终一致性

> Java帝国的官方标准总是被臣民们所建立的事实标准所打败

消息队列：数据库A执行完一个扣除事务后，往消息队列插入一条增加消息，这时候数据库A事务就结束了，消息队列的消息会在将来的某一刻被读取出来，进行处理。这是根本不需要什么两阶段提交，性能很好

> 消息队列的数据都是被持久化到硬盘上的，不会丢失

数据库A添加一张消息队列事件表，用于保存消息队列，两张表位于同一个数据库中，所以直接使用本地事务就行，不用分布式事务

> 幂等性：当你对一个事务进行操作的时候，可以一直重复的操作，那个事务不受影响

为了实现幂等性，数据库B需要新增一张执行记录表，用于判断是否已经执行过，如果没有执行就增加，如果执行了，就抛弃消息。

## JSP 装配工的没落
功能：把页面模版和数据装配起来，变成HTML发送给浏览器

CGI方式输出HTML：本质字符串拼接

1996年微软推出ASP（Active Server Page）。

> CGI是在代码中混杂HTML，而ASP则是HTML中混杂代码

紧接着Sun公司推出JSP（Java Server Page），但是存在一个问题，程序员把绝大部分业务逻辑搞在JSP中，会导致无法编译。

推出MVC，把展示和逻辑分开，用Servlet来充当控制器，用Java类来充当模型，而视图就是JSP了。

这样一来使JSP只关注显示，但是在界面上显示逻辑还是必不可少的，所以像分支、循环这样的控制语句不可或缺。因此JSP提供了一套标准，叫做JSP Standard Tag Library（JSTL）标签库。

JSTL本质是Java类，能够接收到你传递的参数，然后计算，输出HTML。

JSTL考虑到不够用，同时开放接口给你，你可以自由扩展，定义标签库。

AJAX技术出来后，服务端MVC中的view越来也少，很多从来浏览器发过来的请求不会进行模版和数据的装配，更不会有HTML返回，而是直接把JSON数据返回给浏览器。

趋势：浏览器实现了自己的MVC，前后端分离，后端负责提供接口及页面模版，浏览器读到页面模版和JSON后直接在浏览器进行装配。

## 消息队列
如果两套系统部署在同一台Java虚拟机中，此时系统间协作就是简单的方法调用。

往往随着用户量和数据量的增长，必须做的一件事情就是业务系统拆分。此时原先的Java方法调用就改成了Web服务。

这样存在一个问题，比如订单系统和配送系统，配送系统并不和订单系统一样，一样一直standby，因此就会存在一个问题，订单系统调用web服务通知配送时候，配送系统可能会不响应，只能反复尝试，但是这样体验很差。

因此就思考：可否将这个同步操作改成异步的呢？我这边发送完之后，我就不管了，配送系统什么时候处理是他的事情。于是消息队列（Message Queue）就诞生了。

架设一个消息队列在两个系统之间，订单系统产生订单后，只要把订单信息写到这个队列就完事了，配送系统从消息队列中读取信息即可。

> 消息队列必须实现持久化，保存在硬盘上

## 动态代理
背景：Java不支持动态性，不能在运行时修改一个类，导致不能用声明的方式来编程。

需求：写完代码后
* 某些函数调用前后加上日志记录
* 某些函数加上事务支持
* 某些函数加上权限控制
* ……

这些需求十分通用，如果在每个函数中都实现一遍，那么重复代码就太多了。

虽然Java不能修改现有的类，但是可以在运行时动态的创建新的类，让这个类作为代理，由于是面向接口编程，在调用方看来都是IHelloWorld接口，并不会意识到底层已经沧海桑田了。
```java
public interface IHelloWorld {
    public void sayHello();
}
public class HelloWorld implements IHelloWorld {
    public void sayHello() {
        System.out.println('hello world')
    }
}
```

Java提供一个InvocationHandler接口，该接口中有一个叫做invoke的方式就是写扩展代码的地方。

Proxy.newProxyInstance()，动态生成类

> 动态代理：运行时动态生成类，并且作为一个真实对象的代理来做事情

## 注解
Java帝国配置文件都在使用XML。

注解有点像增强版的注释，这个注释不但有一定的格式，还有特定的含义，这样别的工具就可以通过它来做事情了。

允许自定义注解。
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
    boolean ignore() default false;
}
```

@Target表示该注解的应用目标，可以是类、方法、方法参数等。@Retention表示这个注解要保留到什么时候，可以只在源码中，或者在.class文件中或者在运行中

如何使自定义注解发挥作用呢。在运行时通过反射的方式取出方法的注解，如果这个直接是@Test，并且没有被忽略，就可以通过反射的方式去执行这个方法了。

> 使用注解，配置靠近代码，容易阅读，容易修改

使用注解多了，配置会分散在各个Java文件中，则极难查找，如果使用XML，则所有的配置集中在一处，则一目了然，通过如果你想修改配置就得修改Java源文件，就需要重新编译部署。

注解发布后，并没有出现谁取代谁，而是被混合起来使用，对于一些需要集中配置的场合，如数据源的配置，自然使用XML，对于@Controller、@RequestMapping、@Transactional这样的注解更喜欢和Java方法卸载一起，显得简单直观

## 泛型
想起多年以前，没做前端时，被问到的面试题了，我想这是答案吧。
```java
List list = new ArrayList()
list.add("apple")
list.add(new Integer(10))
```

思考一下上面的代码有什么问题，如果往list中添加不同类型数据时，取出的时候还得做强制转换，不然很容易出错。这会导致一个问题，这会增加使用者的责任，编译器也无法帮忙，在运行时才会抛出Class Cast异常。

通过泛型能够在编译期检查出错误，使用List的人也不用做强制转换，还是很有好处的
```java
public class ArrayList<T> implements List<T> {

}
public static <T extends Comparable<T>> T max(List<T> list)
```

> 泛型极大限度的减少了运行期那些转型导致的异常，简化了代码
