## Web起源
加上链接的文本就不是普通的文本了，而升级为超文本（HyperText）

界面标记语言：HyperText Markup Language，简称HTML

用于在浏览器和服务器之间传输文本，该通信方法就叫做超文本传输协议（HyperText Transfer Protocol，HTTP）

## 进程通信
1. 初期：进程在一个系统内，通过共享内存可以通信
2. 系统负载过大，不同进程可能被分离到不同的系统，可以通过Socket通信
3. Socket 通信向 Web 服务化
   * URL：描述Web服务地址
   * 描述方式和数据传输方式（HTTP GET/POST + JSON）

## HTTPS
所有的复杂度都是基于网络传输不安全所致，如果采用加密算法，核心就是如何安全的交换密钥。HTTPS中总的来说就是对称加密算法和非对称加密算法的综合使用，使用非对称加密算法交换对称加密算法密钥，然后使用对称加密算法进行通信，因为考虑对称加密算法比非对称加密算法快百倍。

> 对称加密算法：加密和解密用的是同一个密钥

简单使用对称加密算法存在的问题就是：密钥传输如果被人窃取了，那就前功尽弃了

于是非对称加密算法来了，不同于之前的算法，它要求一对钥匙，一个是保密的，称为私钥，另一个是公开的，称为公钥。

> 非对称加密算法：用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应私钥才能解密

由于非对称加密算法的特点，通信时用对方的公钥加密后直接发送到网络上，由于私钥是保密的，因此只能对方查看内容。同时考虑到非对称加密算法的效率低，采用开头说的两者结合的混合方式。

你以为这样就万事大吉了，你错了，有一个攻击叫做“中间人攻击”，如果中间人两头骗，你拿到的是中间人的公钥，这样就麻烦了，中间人拿到你的数据包，就可以用自己的私钥解密了。因此关键问题出在公钥的分发上，虽然这个东西是公开的，但是在别有用心的人看来，截取以后还可以干坏事。

问题的关键回到了：如何证明你到底是谁，证明这个公钥是你的，而不是攻击者的。

因此我们需要一个公证处。它提供的公证材料大家都信任，这个公证给大家颁发一个证书，用于证明一个人的身份。

这个证书里面包含一个人的基本信息，还包含最关键的一环：这个人的公钥。

可是虽然带上了基本信息，但是证书如何安全传输呢？如果证书被篡改，比如替换掉里面的公钥，换成攻击者的公钥，不就能伪造身份了么。这如何解决，防篡改，我们很容易想到-数字签名

可以把公钥和个人信息用一种hash算法生成一个消息摘要作为签名，这里用了hash算法两个极好的特性，不可逆和雪崩效应。用户拿到证书后，同样可以对个人信息和公钥做相同的hash，如果和签名不一致，说明被人修改了。

这样还是存在一个问题，就是如果攻击者直接把整个信息替换了，也就是说直接伪造一个证书呢？这样就不可知了。

很容易想到数字签名不能直接传输，我们需要加密，此时CA可以通过自己的私钥对数据签名进行一次加密，因为攻击者是无法得到CA的私钥的，这样一来证书就无法伪造了。

此时数字证书的构成为：公钥 + 基本信息 + 数据签名（私钥加密后的信息摘要）

这样一来用户取得证书后，只需要用同样的hash生成信息摘要，然后用CA公钥对数据签名进行解密，得到CA创建的信息摘要，两者一对比，就知道有没有修改了。

看到这里我觉得挺完美了，可其实还有的问题，而且是一个根本问题，因为我们需要使用CA的公钥对数据签名进行解密，如果此时发动中间人攻击，攻击人就可以成功伪造成CA了，一切似乎回到了原点。

如何到这个鸡生蛋，蛋生鸡的问题呢？必须信任某个CA，并且能通过安全的方式获取他们的公钥，这样才能继续下去了。

因此既然网络不安全，那就只能通过不通过网络了，实际上也是这么做的。

> CA本身也有证书表明自己的身份，但是CA的证书要怎么验证没被篡改呢？只好由这个CA的上一次验证，然后再由上一次来验证，于是CA们形成了一个分级的链条，在链条的顶部就是操作系统/浏览器预置的顶层CA的证书，相当于你自动信任了它们

HTTPS的流程
1. 浏览器发出安全请求
2. 服务器发送数字证书
3. 浏览器与预置的CA列表验证证书，如果有问题，则提示风险
4. 浏览器用自己的私钥进行解密，得到对称密钥
5. 双方都知道了对称密钥，用它加密通信

## SSO单点登录
背景：企业发展大了以后，可能会有很多的内部系统，如果每个系统都有自己的登录功能，将会导致帐号非常的多，不利于记忆，同时不同系统之间需要重复登录，体验很不好。

> 单点登录：在一个地方登录多次，就可以访问我们这里所有的系统了

由于登录态是通过cookie保存的，那么可不可以通过cookie共享呢？cookie有个致命问题，同时也是为安全设计的，就是cookie是不可以跨域！

有个变相的解决办法就是：将所有的系统都统一到同一个域名的二级域名下，然后将 cookie 域名范围设置在一级域名下，这样 cookie 就可以共享，然后登录态，比如 session 可以通过 redis 实现共享。

共享 session 需要耗费服务器资源，可以不可以只共享 cookie 呢？在某系统登录后，系统就在 cookie 中写一个 token，用户访问别的系统，就可以把 cookie 带过去，系统验证一下 token，如果没问题，则表示已经登录。这里有个行业解决方案 JWT（JSON Web Token），特别需要注意的是，系统在生成 token 的时候，都要对数据生成一个签名，防止别人篡改。

JWT流程
1. 准备header信息 + 用户信息
2. 使用信息摘要算法（不可逆）生成摘要，同时为了防止整个替换，需要用密钥进行签名
3. 最终组成 header信息 + 用户信息 + 签名，构成 token

别的系统得到 token 后，就用同样的算法再计算签名，然后跟计算的签名对比，如果相同说明已经登录，同时可以从用户信息中取出 userID 使用了。

突然发现一个严重的问题了，每个系统的用户表不一致，拿到 userID 也无法使用啊。

通过上面的方案我们发现两个问题
* 域名限制
* 用户表问题

用户表问题其实很好解决，搞SSO的目的就是消除多个账号的问题，将来每个系统都不需要维护自己的用户系统，他们会建立一个统一的认证中心，所有的用户注册和认证都在那里完成。

这里需要所有系统的配合，如果某系统发现用户没有登录，全部统一重定向到认证中心，比如：www.sso.com/login?redirect=www.a.com/pageA，redirect是为了实现登录成功后跳转回系统。

认证中心要做几件重要的事情：
1. 建立一个全局session
2. 创建一个ticket（随机字符串）
3. 重定向到之前访问的系统，此时加上ticket，eg：www.a.com/pageA?ticket=T123，此时cookie也会被发送给浏览器，比如Set cookie:ssoid=123;domain=sso.com.

此时就走到具体每个系统层面了
1. 系统拿到ticket后，再次向认证中心进行认证，认证中心验证ticket有效后，同时注册该系统，这一步主要是为了验证ticket的合法性
2. 验证通过后，建立局部session，返回对应资源，此时需要写你自己的cookie

访问A系统时已经通过认证中心登录，此时在访问B系统，会怎么样呢？逻辑其实是一样的，直接跳转sso.com，而此时浏览器已经有了认证中心的cookie，sso.com会认为登录成功，生成ticket，然后跳转到B系统，接下来 B 系统的认证步骤就和 A 一样了。

> 本质上就是一个认证中心的 cookie，加上多个系统的 cookie

为什么在验证ticket的合法性的时候需要注册该系统呢？主要是为了实现单点退出。用户在一个系统退出了，认证中心需要把自己会话和cookie消灭，同时还要去通知各个系统，让他们把自己的会话统统消灭。

> 由耶鲁大学提出，叫做CAS（Central Authentication Service），著名的 SSO 解决方案

## 从密码到token
主要是OAuth三种认证方式
* Resource Owner Password Credentials Grant（资源所有者密码凭据许可）
* Implicit Grant（隐式许可）
* Authorization Code Grant（授权码许可）

如果别人要获取你在某平台的信息，比如微信公众号开发，用户都是接受不了将用户名和密码提供给第三方应用的。那么如何打通这个桥梁呢？

第三方应用支持第三方平台登录，第三方应用首先去平台进行注册，注册后平台会颁发一个 app_id 和 app_secret，应用重定向到平台登录页时，需要带上app_id用来表示应用，此时平台就可以知道是哪个应用在申请授权。

用户在平台登录成功后，将通过 URL 重定向的方式 token 回传给应用，此时应用就可以通过 token 的方式去请求接口了。

上述方式有一个问题，token 通过明文的方式发送到浏览器，此时如何 token 被攻击者获取到，这是十分危险的。

授权码 + token 升级
* 平台登录成功后，不直接发送token，而是给一个授权码
* 应用后台获取到这个授权码后，在后台再次访问平台认证中心，此时才能得到 token，从而让浏览器接触不到 token
* 这里虽然隐藏了 token，但是授权码还是暴露的，攻击者拿到授权码后，不照样能获取到 token！此时就需要 app_id 和 app_secret 发挥作用了，app_secret 只会存储在后台，授权码和 app_id 和 app_secret 关联，这样就保证了只有我的服务器发出的token请求，认证中心才认为合法。同时可以让授权码有时间限制，比如5分钟有效，还可以让授权码只能换一次token。

> 猛然发现，微信公众号就是这么干的哇

OAuth术语
* 资源所有者
* 资源服务器
* 客户端
* 授权服务器
