## 数据库的发展史
单机版信息系统：基于文件进行存储

为了应对各式各样的查询需求，因为针对每一个查询需求，那是无穷尽的。

> 所有计算机的问题都可以通过增加一个中间层解决

通过增加一个中间层，把物理层（文件层）屏蔽掉，通过熟悉的术语进行查询。中间层要有逻辑的数据结构，比如表，列，类型。定义好之后，还需要写一个解析器，把这样的语句变成内部对文件的操作。这里需要编译原理的知识。

这样一来，自己的程序也可以调用逻辑层来编程，也不用直接操作文件了，简化了很多。

> SQL：最大的好处是用户完全不用考虑物理层那些文件的结构，只需要关注逻辑层的表就可以了

文件存储进行优化：不再采用简单的逗号分割，增加了索引、缓存、查询优化等手段。由于中间层的存在，所以这些变化对应用层没什么影响

### 并发访问
重要的功能增强：网络访问，从单机软件变成了客户端-服务器结构的软件。

基于文件的操作改成基于行的操作：每个人的修改只能影响这一行。这样解决了文件并发访问，数据被覆盖丢失的情况。

但是如果同时修改同一行呢？那就还会有问题，解决办法——行加锁

### 原子性问题
就拿转账而言，这个操作必须是原子的，要么全部发生，要么根本不发生。这样类似的操作叫做`事务`

`Undo日志`实现事务管理
1. 在执行真正操作之前，要先记录数据项原来的值，把这样的日志写入日志文件中。如果事务执行到一半断电了，数据库重置就可以根据Undo日志文件进行恢复
2. Undo日志不仅记录数据项原来的值，还会记录事务的开始和结束。如果在日志文件中看到了提交事务或者回滚事务，则这个事务已经完成，不用再去恢复。如果只看到了开始事务，而看不到提交或者回滚，那么我就得恢复，恢复完成后，在日志文件中补上一行“回滚事务”，这样下一次就可以忽略这个事务
3. 如果日志还没写入就断电了呢？遵循两条简单的规则
  * 更新数据之前，一定要先把对应的日志写入硬盘的日志文件
  * “提交事务”这样的undo日志记录一定要在所有的新数据写入成功之后再写入

### 安全
定义三大类权限
* 对数据操作的，如SELECT、UPDATE、INSERT等
* 对结构操作的，如创建表、修改表
* 做管理的，如备份数据、创建用户等

## Socket
两台主机之间通过失败重传来实现可靠的传输。

三次握手，滑动窗口，累计确认，分组缓存，流量控制，友好分手

> TCP协议很复杂，不能要求每个程序员都去实现建立连接的三次握手、累计确认、分组缓存，这些应该属于操作系统内核的部分，没必要重复开发，对于应用程序来讲，操作系统需要抽象出一个概念，让上层应用去编程，这就是Socket

TCP是两个进程之间的通信，客户端上可以有很多进程同时访问多个服务器，服务器上也有多个进程对外提供服务，我们通过端口号将它们区分开。为什么不通过进程号呢？

进程号是一个动态的东西，如果服务器端的进程重启了，进程号就变了。服务端都是被动访问的，所以大家需要知道它提供的服务的端口号。这个端口号就像一扇门，服务端的进程就在这扇门后面监听，等待客户端的连接。

> TCP的连接必须通过客户端IP、客户端PORT，服务端IP和服务端PORT来确定

## CPU和内存
理解CPU和内存是怎么一起工作的，绝对是基础中的基础。

简化一下CPU和内存，内存就是一个个小格子。每个格子都有一个编号，这个编号称为内存的地址，格子中的数据可以被CPU读写。CPU结构超级复杂，我们先关注运算器和寄存器

运算器可以进行各种运算，但是有一个限制，即这个运算器不能直接操作内存进行运算，它在运算时使用的是内部的数据格子，学名寄存器。

CPU必须把数据装载寄存器中才能进行运算。CPU运行速度很快，但是能做的事情却十分简单，主要是以下4种
* 从内存中某个格子读取数据，放入自己内部的寄存器Rx
* 把Rx的数据写入内存的某个格子中（会覆盖原有的数据）
* 进行数学运算（加减乘除）和逻辑运算（AND/OR）
* 根据条件进行跳转

CPU在运行时从哪里获取指令呢？还是内存，指令也需要在内存中才能被CPU访问到，CPU读取指令后，会进行分析译码，再进行计算

> 内存小格子中存放的不仅仅是数据，还存放着至关重要的程序指令。我们需要告诉CPU第一条指令在什么地方，然后就可以疯狂运行了

## 翻译家族发家史
翻译家族：把码农写的源代码变成可以执行的程序

### 机器语言
计算机刚发明初，通过拨弄各种开关、操作各种电缆把程序输入到计算机中。

这所谓的程序，真就是10011这样的二进制。后来做出了改进，把程序达到穿孔纸带上，让机器直接读穿孔纸带。但是程序的本质还是没有变化，依然使用二进制来编程。

这个年代，直接用二进制写程序，对我们翻译家族没有任何的需求

### 汇编语言
既然二进制这么难记，那么能不能给这些指令起一个好听的名字呢？答案是肯定的。人们给这些帮助记忆的助记符起了一个名字：汇编语言。

但是计算机是无法执行汇编语言的，因为计算机这个太笨只认二进制，所以需要翻译一下才行。

于是汇编器登场了，负责把汇编语言写的程序翻译为机器语言。这个编译过程比较简单，几乎就是一一对应关系。

汇编语言的优点是贴近机器，运行效率极高，但是缺点也是太贴近机器，直接操作内存和CPU，难以结构化编程，每次函数调用还得手动把内存中的栈帧管理好。

> 穿孔纸带和汇编语言都成为低级语言，这时时代称为机器语言编程时代

### 高级语言
人类一直在思考一种更高级的语言来写程序的可能性，这种高级语言应该面向人类编写和阅读，而不应面向机器执行。

想要的高级语言是这样的
* 使用各种类型的变量来表示数据，而不使用寄存器
* 能使用复杂的表达式来告诉计算机自己的意图
* 可以用条件语句处理分支
* 可以用循环语句处理循环
* 可以定义函数来封装、复用一段业务逻辑

人类在黑暗中探索了很久，在1957年，第一个高级语言的编译器在IBM 704机器上运行成功。

由于翻译的复杂性，除了汇编器之外，很多新成员加入进来，形成了一条专门的翻译流水线，这条流水线的家族成员分工合作，负责把高级语言翻译成低级语言
* 词法分析：将代码分成一个个片段，每个片段叫做Token
* 语法分析：将Token按照语法规则组建成一个树
* 语义分析：标识符的类型、作用域是不是正确、运算是否合法、取值范围有没有问题
* 后续工作：根据语法树生成中间代码，然后翻译成汇编语言

编译器、操作系统、数据库、网络协议栈等软件一起，成为计算机世界底层的基础软件

> 源程序 -> 词法分析 -> 语法分析 -> 语义分析 -> 中间代码生成 -> 代码优化 -> 代码生成 -> 目标程序

## 编程世界的那把锁

### 共享变量惹的祸
单线程的逻辑正确并不表示多线程并发运行时的逻辑也正确

> 只要有共享变量，在多线程读/写的时候就会出现不一致

除非你消除共享变量，每个线程只访问一个函数内的局部变量，这些局部变量我们每个线程都会有一份，函数结束以后就会销毁，所以线程之间就隔离了，就安全了。

但是消除共享变量谈何容易，人类使用的很多语言，那些共享变量大多是一个对象的字段，你想把字段去掉，只留下函数，那类也没有存在的必要了。

既然共享变量无法消除，解决办法就是`加锁`！任何线程想要操作一个共享变量，就先去申请一把锁，拿到锁才能操作。

> 自旋锁：线程运行时，检查lock是否可以设置为true，如果已经变成true了，就无限循环，拼命的抢，除非时间片到了，被迫让出CPU。但线程不会阻塞，仍旧处于就绪状态，等待下一次调度，进入CPU继续抢

如果有两个线程都读取到了lock=false，都把lock改成了true，那么锁算谁的？

不可分割原子操作：这个检测lock是否为false以及设置为lock为true的操作其实被合并了，叫做test_and_set(lock)，在这个函数执行时，总线甚至被锁住了，别人不能访问内存，即使多个CPU在执行也不会有问题
```c++
// 如果lock初始值为false，则会被置为true，函数返回false，则意味着抢到锁了
// 如果lock初始值为true，则仍然被置为true，返回值也是true，意味着没抢到
boolean test_and_set(*lock) {
  boolean rv = *lock
  *lock = true
  return rv
}

// 试图获得锁
while(test_and_set(&lock)) {
  // 等待
}
x = x + 1;
lock = false;
```

以上代码看着没啥问题了，可是如果是递归函数，就会出现自己把自己搞成了死锁。

这样一来，这个自旋锁虽然实现了互斥的访问，但是不能重新进入同一个函数（不可重入）。

解决方案
* 每次成功地申请锁后，要记录到底是谁申请的，还有用一个计数器记录重入的次数，持有锁的家伙再次申请只是计数器加1而已
* 释放锁的时候也一样，把计数器减1，等于0才表示真正的释放锁

那么多线程拼命地抢，空耗CPU也是一种浪费啊，于是诞生一种改进锁：如果抢不到，就不要无限循环了，乖乖去等待队列中待着，等到锁被别人释放了，再通知你去抢。

### 信号量
线程之间不仅是互斥关系那么简单，有时候线程之间还得同步：必须等待另一个/多个家伙完成以后才能开始工作。

举个例子：打印机
* 打印线程负责打印队列元素，打印完成删除，队列为空等待加入线程加入文档
* 加入线程负责添加文档，如果队列满了，则需要等待打印线程删除一个元素

> 所谓信号量，其实就是一个整数，基于这个整数有两个操作：wait和signal
```c++
// s++、s--是原子性
int s
wait(s) {
  while(s <= 0) {}
  s--
}

signal(s) {
  s++
}
```

用信号量也可以实现互斥
```c++
int lock
wait(lock) // 相当于得到互斥锁
// 做事情
signal(lock) // 相当于释放锁
```

上述wait一直循环，会出现忙等待，改进如下
```c++
typeof struct {
  int value;
  struct process *list
}semaphore

wait(semaphore *s) {
  s->value--
  if(s->value < 0){
    // 让自己进入阻塞，加入等待队列s->list
  }
}

signal(semaphore *s){
  s->value++
  if(s->value <= 0){
    // 从等待队列s->list唤醒一个
  }
}
```

消费者和生产者同步问题
```c++
int lock = 1;
int empty = 5;
int full = 0;
// 生产者
while(true) {
  // 如果队列已满，则只好等待
  wait(empty);
  // 有空位了，也需要加锁，避免两个线程同时操作
  wait(lock);
  // 加入……

  // 释放锁
  signal(lock);
  // 通知消费者产生了新的文件
  signal(full);
}

// 消费者
while(true) {
  // 如果队列为空，则等待
  wait(full);
  // 有数据了，加锁
  wait(lock);
  // 删除……

  // 释放锁
  signal(lock);

  // 通知生产者有空位了
  signal(empty);
}
```

## 加法器
加法器同时实现加法和减法，能极大的节省CPU的电路设计。

7 - 3 可以转换为 7 + 3 的补数。那什么是补数呢？

> 补数：对二进制数的所有位取反，然后加1

上面只考虑到了整数，一旦引入负数，首先需要使用一个符号位来表示是正数还是负数

> 最高位的 0 表示正数，1 表示负数，真正有效的数字只剩下 3 位

还是 7 -3 的问题，7 - 3 等同于 7 + (-3) 的补码，这样一来我们完全可以把负数使用补码来表示，然后把负 0 特别当作 -8 来处理。

这样一来，负数直接用补码表示，不但减法变加法，连符号位都可以参与运算。

> 在计算机内部，是使用补码来表示二进制数的，如果是一个正数，补码就是他本身，如果是一个负数，则需要把除符号位之外的二进制数取反加1的操作

因为4位的系统，如果只表示无符号数，那么范围是[0, 15]，表示有符号数，范围是[-8, 7]就好理解了

## 递归
计算阶乘
```c++
int factorial() {
  if(n == 1) {
    return 1
  } else {
    return n * factorial(n -1)
  }
}
```

内存逻辑结构：栈帧1 -> 栈帧2 -> 栈帧3 -> …… -> 堆 -> 数据段 -> 代码段

阶乘函数，编译后会被放到代码段，注意，只有一套代码被放到代码段

每个栈帧代表了被调用中的一个函数，这些函数栈帧以先进后出的方式排列起来，就形成了一个栈。每个栈帧保存着：上一个栈帧的指针，输入参数，返回值，返回地址等

比如计算factorial(4)
* 栈帧计算factorial(4)，方法是4*factorial(3)
* 形成新的栈帧计算factorial(3)
* 如此递归下去，到最后得到factorial(1) = 1
* 逐次出栈，就能计算出最终的factorial(4)

> 注意：每个递归函数必须要有一个终止条件，，否则就会发生无线递归了

你也考虑到了，栈容量是有限的，如果 n 值太大了，就有可能栈溢出

算法改进
```c++
int factorial(int n, int result) {
  if(n == 1) {
    return result
  } else {
    return factorial(n-1, n*result)
  }
}
```

此时的计算过程：`factorial(4, 1) = factorial(3, 4*1) = factorial(2, 3*4*1) = factorial(2, 3*4*1) = factorial(1, 2*3*4*1) = factorial(1, 24) = 24`

这样一来，执行中不存在回退，比如执行factorial(1, 24)，不需要回退到之前的任何一步。计算机发现这种情况，只用一个栈帧就可以搞定这些计算，无论你的n多大。

> 当递归调用是函数体中最后执行的语句，并且它的返回值不属于表达式的一部分时，这个递归就是尾递归。现在编译器就会发现这个特点，生成优化的代码，复用栈帧。

第一种情况因为有n * factorial(n -1)，递归处在一个表达式中，还要进行计算，所以就没法复用栈帧，只能一层一层的调用下去
