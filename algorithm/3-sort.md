这里我们主要学习下排序

## 基本介绍
最常用排序算法分类
* 冒泡、插入、选择：时间复杂度 O(n^2) 基于比较
* 快排、归并：O(nlogn) 基于比较
* 桶、计数、基数：O(n) 并不基于比较

如何分析一个排序算法呢
* 排序算法的执行效率
  * 最好情况、最坏情况、平均情况时间复杂度
  * 时间复杂度的系数、常数、低阶：同一阶时间复杂度的排序算法性能性能对比的时候，需要考虑进来
  * 比较次数和交换（或移动）次数
* 排序算法的内存消耗
  * 原地排序：指空间复杂度是 O(1) 的排序爽啊
* 排序算法的稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

## 分类一

### 冒泡排序
冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

使用 JavaScript 例出基本代码
```js
function bubbleSort(array) {
    const length = a.length;
    if (length <= 1) {
        return;
    }
    for (let i = 0; i < length; i++) {
        let flag = false;
        for (let j = 0; j < length - i - 1; j++) {
            if (a[j] > a[j + 1]) {
                const temp = a[j]
                a[j] = a[j + 1]
                a[j + 1] = temp
                flag = true; // 表示有数据交换
            }
        }
        if (!flag) {
            break;
        }
    }
}
```

按照上面的方式分析冒泡排序
* 原地排序
* 稳定排序
* 最好情况复杂度 O(n)，最坏情况复杂度 O(n^2)，平均复杂度 O(n^2)

那么如何分析平均复杂度呢？介绍两个概念：有序度和无序度
* 有序度：数组中具有有序关系的元素对个数，数学表达式为：`有序元素对：a[i] <= a[j], 如果 i < j。`
* 逆序度：相反，逆序度 = 满有序度 - 有序度，数学表达式为：`逆序元素对：a[i] > a[j], 如果 i < j。`
* 满有序度：一个完全有序的数组，有序度就是 `n*(n-1)/2`

> 我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

冒泡排序操作原子：比较和交换

### 插入排序
将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

理解了原理之后，代码也比较简单，具体如下
```js
function insertSort(array) {
    const length = a.length;
    if (length <= 1) {
        return;
    }
    for (let i = 1; i < length; i++) {
        // 查找插入位置，从后往前遍历，因为会插入元素
        const value = a[i];
        let j = i - 1;
        for (; j >= 0; j--) {
            // 比你小，往后移动
            if (a[j] > value) {
                a[j + 1] = a[j]
            } else {
                break;
            }
        }
        a[j + 1] = value
    }
}
```

算法分析
* 原地排序
* 稳定排序
* 最好情况复杂度 O(n)，最坏情况复杂度 O(n^2)，平均复杂度 O(n^2)

插入排序操作原子：比较和移动

### 选择排序
选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

算法分析
* 原地排序
* 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)
* 非稳定排序

基本的知识都讲完了，我们来看开篇的问题：冒泡排序和插入排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

原因在于，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。

### 总结
这三种时间复杂度为 O(n^2) 的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。有些编程语言中的排序函数的实现原理会用到插入排序算法。

## 分类二
冒泡排序、插入排序和选择排序，时间复杂度都是 O(n^2)，适合小规模数据的排序，这里学习两种时间复杂度为 O(nlogn) 的排序算法，归并排序和快速排序。适合大规模的数据排序，比上述三种排序算法要更常用

归并排序和快速排序都用到了分治思想，非常巧妙。思考如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大个元素

### 归并排序
思想：把数组从中间分层前后两部分，然后对前后两部分分别排序，再讲排好序的两部分合并在一起，这样就有序了。使用的就是分治思想，将一个大问题，分解成小的子问题来解决，小问题解决了，大问题也就解决了。

> 分治是一种解决问题的处理思想，递归是一种编程技巧

JavaScript 示例代码
```js
function mergeSort(arr, left, right) {
    if(left >= right) {
        return;
    }
    const q = Math.floor((left + right) / 2);
    mergeSort(arr, left, q);
    mergeSort(arr, q + 1, right);
    merge2(arr, left, q, right);
}
// 合并两个已排序数组
function merge2(arr, left, q, right) {
    const leftArr = []
    const rightArr = []
    for (let i = 0; i <= q - left; i++) {
        leftArr[i] = arr[left + i];
    }
    // 第一个数组添加哨兵（最大值）
    leftArr[q - left + 1] = Number.MAX_VALUE;
    for (let i = 0; i < right - q; i++) {
        rightArr[i] = arr[q + 1 + i];
    }
    // 第二个数组添加哨兵（最大值）
    rightArr[right - q] = Number.MAX_VALUE;
    let i = 0;
    let j = 0;
    let k = left;
    while (k <= right) {
        // 当左边数组到达哨兵值时，i不再增加，直到右边数组读取完剩余值，同理右边数组也一样
        if (leftArr[i] <= rightArr[j]) {
            arr[k++] = leftArr[i++];
        } else {
            arr[k++] = rightArr[j++];
        }
    }
}
```

归并排序是不是稳定算法，主要看 merge 函数，比如上面代码，对于相等的情况，优先处理左侧的代码，则就是稳定排序

关于复杂度：如何分析递归的复杂度呢。假设求解 a 问题时间是 T(a)，求解 b、c 问题的时间是 T(b) 和 T(c)，那么关系式为

> T(a) = T(b) + T(c) + K，其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间

不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写出递推公式。

归并排序的分析
* 假设对 n 个元素进行归并排序需要的时间是 T(n)，分解成两个子数组排序的时间都是 T(n/2)，merge 的时间复杂度是 O(n)，因此套用公式等于 `T(n) = 2 * T(n / 2) + n`
* 一步步分解推导可得 `T(n) = 2^k * T(n / 2^k) + k * n`，当 `T(n / 2^k) = T(1)` 时，也就是 `n / 2^k = 1`，得到 `k = log2n`
* 将 k 代入得到 `T(n) = Cn + nlog2n`
* 因此复杂度等于 O(nlog2n)

空间复杂度：归并排序的时间复杂度任何情况下都是 O(nlog2n)，即便是快速排序，最坏情况下时间复杂度也是 O(n ^ 2)，但是归并排序并没有像快排那样，应用广泛，有个致命的弱点，`归并排序不是原地排序算法`。因为在合并函数中，合并两个有序数组时，需要借助额外的存储空间，如果按照分析时间复杂度的方法，通过递推功能来求解，归并过程需要的空间复杂度就是 O(nlog2n)，但这是不对的。因为尽快每次合并操作完成后，临时开辟的内存空间就释放掉了，在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用，临时内存空间最大也不会超过 n 个数据大小，所以空间复杂度是 O(n)

### 快速排序
核心思想：如果要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意数据作为 pivot（分区点），遍历 p 到 r 之间的数据，小于 pivot 的放到左边，将大于 pivot 的放到右边，pivot 放在中间。经过这一步骤后，数组 p 到 r 之间就分成了三个部分，前面 p 到 q - 1 的都是小于 pivot 的，中间是 pivot，后面的 q + 1 到 r 之间是大于 pivot 的。根据分治、递归的处理思想，反复处理左右两个区间的数据，直到区间缩小为 1，就完成排序了。

JavaScript 示例代码
```js
function quickSort(arr, p, r) {
    if(p >= r) {
        return
    }
    const q = partition(arr, p, r)
    quickSort(a, p, q - 1)
    quickSort(a, q + 1, r)
}
```

问题的关键就抛给了分区函数 partition，如果不考虑空间消耗的话，取区间最后一个元素作为 pivot申请两个临时数组，遍历 arr 数组，将小于和大于 pivot 的元素分别放置在各自的数组中，最后拷贝两个数组元素和 pivot 到 arr 中。

但这种思路的话，需要很多额外的内存空间，那么快排就不是原地排序算法，如何设计才能空间复杂度 O(1) 呢。原地分区函数的实现思路非常巧妙
```js
function partition(arr, p, r) {
    const pivot = arr[r];
    const i = p;
    for (let j = p; j < r; j++) {
        if (arr[j] <= pivot) {
            swap(arr, i, j);
            i++;
        }
    }
    swap(arr, i, r);
    return i;
}

function swap(arr, i, j) {
    if (i == j) {
        return;
    }
    let tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```

分区的过程涉及交换操作，快排并不是一个稳定的排序算法。

归并排序的处理过程是由下而上的，先子问题，在然后再合并。快排正好相反，处理过程由上到下的，先分区、然后再处理子问题

快排性能分析
* 如果每次分区操作，都能正好把数组分成大小接近的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的
* 极端情况下，每次分区得到的区间都是不均等的，则可能需要 n 次分区，每次大约扫描 n/2 个元素，因此时间复杂度退化成了 O(n ^ 2)

## 分类三