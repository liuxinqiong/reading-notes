这里我们主要学习下排序

## 基本介绍
最常用排序算法分类
* 冒泡、插入、选择：时间复杂度 O(n^2) 基于比较
* 快排、归并：O(nlogn) 基于比较
* 桶、计数、基数：O(n) 并不基于比较

如何分析一个排序算法呢
* 排序算法的执行效率
  * 最好情况、最坏情况、平均情况时间复杂度
  * 时间复杂度的系数、常数、低阶：同一阶时间复杂度的排序算法性能性能对比的时候，需要考虑进来
  * 比较次数和交换（或移动）次数
* 排序算法的内存消耗
  * 原地排序：指空间复杂度是 O(1) 的排序爽啊
* 排序算法的稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

## 分类一

### 冒泡排序
冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

使用 JavaScript 例出基本代码
```js
function bubbleSort(array) {
    const length = a.length;
    if (length <= 1) {
        return;
    }
    for (let i = 0; i < length; i++) {
        let flag = false;
        for (let j = 0; j < length - i - 1; j++) {
            if (a[j] > a[j + 1]) {
                const temp = a[j]
                a[j] = a[j + 1]
                a[j + 1] = temp
                flag = true; // 表示有数据交换
            }
        }
        if (!flag) {
            break;
        }
    }
}
```

按照上面的方式分析冒泡排序
* 原地排序
* 稳定排序
* 最好情况复杂度 O(n)，最坏情况复杂度 O(n^2)，平均复杂度 O(n^2)

那么如何分析平均复杂度呢？介绍两个概念：有序度和无序度
* 有序度：数组中具有有序关系的元素对个数，数学表达式为：`有序元素对：a[i] <= a[j], 如果 i < j。`
* 逆序度：相反，逆序度 = 满有序度 - 有序度，数学表达式为：`逆序元素对：a[i] > a[j], 如果 i < j。`
* 满有序度：一个完全有序的数组，有序度就是 `n*(n-1)/2`

> 我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

冒泡排序操作原子：比较和交换

### 插入排序
将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

理解了原理之后，代码也比较简单，具体如下
```js
function insertSort(array) {
    const length = a.length;
    if (length <= 1) {
        return;
    }
    for (let i = 1; i < length; i++) {
        // 查找插入位置，从后往前遍历，因为会插入元素
        const value = a[i];
        let j = i - 1;
        for (; j >= 0; j--) {
            // 比你小，往后移动
            if (a[j] > value) {
                a[j + 1] = a[j]
            } else {
                break;
            }
        }
        a[j + 1] = value
    }
}
```

算法分析
* 原地排序
* 稳定排序
* 最好情况复杂度 O(n)，最坏情况复杂度 O(n^2)，平均复杂度 O(n^2)

插入排序操作原子：比较和移动

### 选择排序
选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

算法分析
* 原地排序
* 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)
* 非稳定排序

基本的知识都讲完了，我们来看开篇的问题：冒泡排序和插入排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

原因在于，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。

### 总结
这三种时间复杂度为 O(n^2) 的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。有些编程语言中的排序函数的实现原理会用到插入排序算法。

## 分类二
冒泡排序、插入排序和选择排序，时间复杂度都是 O(n^2)，适合小规模数据的排序，这里学习两种时间复杂度为 O(nlogn) 的排序算法，归并排序和快速排序。适合大规模的数据排序，比上述三种排序算法要更常用

归并排序和快速排序都用到了分治思想，非常巧妙。思考如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大个元素

### 归并排序
思想：把数组从中间分层前后两部分，然后对前后两部分分别排序，再讲排好序的两部分合并在一起，这样就有序了。使用的就是分治思想，将一个大问题，分解成小的子问题来解决，小问题解决了，大问题也就解决了。

> 分治是一种解决问题的处理思想，递归是一种编程技巧

JavaScript 示例代码
```js
function mergeSort(arr, left, right) {
    if(left >= right) {
        return;
    }
    const q = Math.floor((left + right) / 2);
    mergeSort(arr, left, q);
    mergeSort(arr, q + 1, right);
    merge2(arr, left, q, right);
}
// 合并两个已排序数组
function merge2(arr, left, q, right) {
    const leftArr = []
    const rightArr = []
    for (let i = 0; i <= q - left; i++) {
        leftArr[i] = arr[left + i];
    }
    // 第一个数组添加哨兵（最大值）
    leftArr[q - left + 1] = Number.MAX_VALUE;
    for (let i = 0; i < right - q; i++) {
        rightArr[i] = arr[q + 1 + i];
    }
    // 第二个数组添加哨兵（最大值）
    rightArr[right - q] = Number.MAX_VALUE;
    let i = 0;
    let j = 0;
    let k = left;
    while (k <= right) {
        // 当左边数组到达哨兵值时，i不再增加，直到右边数组读取完剩余值，同理右边数组也一样
        if (leftArr[i] <= rightArr[j]) {
            arr[k++] = leftArr[i++];
        } else {
            arr[k++] = rightArr[j++];
        }
    }
}
```

归并排序是不是稳定算法，主要看 merge 函数，比如上面代码，对于相等的情况，优先处理左侧的代码，则就是稳定排序

关于复杂度：如何分析递归的复杂度呢。假设求解 a 问题时间是 T(a)，求解 b、c 问题的时间是 T(b) 和 T(c)，那么关系式为

> T(a) = T(b) + T(c) + K，其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间

不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写出递推公式。

归并排序的分析
* 假设对 n 个元素进行归并排序需要的时间是 T(n)，分解成两个子数组排序的时间都是 T(n/2)，merge 的时间复杂度是 O(n)，因此套用公式等于 `T(n) = 2 * T(n / 2) + n`
* 一步步分解推导可得 `T(n) = 2^k * T(n / 2^k) + k * n`，当 `T(n / 2^k) = T(1)` 时，也就是 `n / 2^k = 1`，得到 `k = log2n`
* 将 k 代入得到 `T(n) = Cn + nlog2n`
* 因此复杂度等于 O(nlog2n)

空间复杂度：归并排序的时间复杂度任何情况下都是 O(nlog2n)，即便是快速排序，最坏情况下时间复杂度也是 O(n ^ 2)，但是归并排序并没有像快排那样，应用广泛，有个致命的弱点，`归并排序不是原地排序算法`。因为在合并函数中，合并两个有序数组时，需要借助额外的存储空间，如果按照分析时间复杂度的方法，通过递推功能来求解，归并过程需要的空间复杂度就是 O(nlog2n)，但这是不对的。因为尽快每次合并操作完成后，临时开辟的内存空间就释放掉了，在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用，临时内存空间最大也不会超过 n 个数据大小，所以空间复杂度是 O(n)

### 快速排序
核心思想：如果要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意数据作为 pivot（分区点），遍历 p 到 r 之间的数据，小于 pivot 的放到左边，将大于 pivot 的放到右边，pivot 放在中间。经过这一步骤后，数组 p 到 r 之间就分成了三个部分，前面 p 到 q - 1 的都是小于 pivot 的，中间是 pivot，后面的 q + 1 到 r 之间是大于 pivot 的。根据分治、递归的处理思想，反复处理左右两个区间的数据，直到区间缩小为 1，就完成排序了。

JavaScript 示例代码
```js
function quickSort(arr, p, r) {
    if(p >= r) {
        return
    }
    const q = partition(arr, p, r)
    quickSort(a, p, q - 1)
    quickSort(a, q + 1, r)
}
```

问题的关键就抛给了分区函数 partition，如果不考虑空间消耗的话，取区间最后一个元素作为 pivot申请两个临时数组，遍历 arr 数组，将小于和大于 pivot 的元素分别放置在各自的数组中，最后拷贝两个数组元素和 pivot 到 arr 中。

但这种思路的话，需要很多额外的内存空间，那么快排就不是原地排序算法，如何设计才能空间复杂度 O(1) 呢。原地分区函数的实现思路非常巧妙
```js
function partition(arr, p, r) {
    const pivot = arr[r];
    const i = p;
    for (let j = p; j < r; j++) {
        if (arr[j] <= pivot) {
            swap(arr, i, j);
            i++;
        }
    }
    swap(arr, i, r);
    return i;
}

function swap(arr, i, j) {
    if (i == j) {
        return;
    }
    let tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```

分区的过程涉及交换操作，快排并不是一个稳定的排序算法。

归并排序的处理过程是由下而上的，先子问题，在然后再合并。快排正好相反，处理过程由上到下的，先分区、然后再处理子问题

快排性能分析
* 如果每次分区操作，都能正好把数组分成大小接近的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的
* 极端情况下，每次分区得到的区间都是不均等的，则可能需要 n 次分区，每次大约扫描 n/2 个元素，因此时间复杂度退化成了 O(n ^ 2)

## 分类三
复杂度为 O(n) 的排序算法：桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度是线性的，所以这类排序算法叫做线性排序。

之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。

特点：对排序的数据要求很苛刻，重点是掌握这些排序算法的适用场景

### 桶排序（Bucket sort）
核心思想：将要排序的数据分到几个有序的桶里，每个桶里的数据在单独进行排序，排完序后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。

桶排序对要排序数据的要求是非常苛刻的
* 要排序的数据很容易就能划分成 m 个桶
* 桶与桶之间有天然的大小顺序，这样每个桶排序完后，桶与桶之间的数据不需要在进行排序
* 数据在各个桶之间的分布是比较均匀的

> 桶排序比较适合用在外部排序中，比如数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中

### 计数排序（Counting sort）
计数排序其实是桶排序的一种特殊情况。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，就可以把数据划分成 k 个桶。每个桶的数值都是相同的，省掉了桶内排序的时间

为啥这个排序算法叫做计数排序呢，含义来自哪里呢？因为其使用了另一个数组进行计数，具体看代码
```java
public void countingSort(int[] a, int n) {
    if(n <= 1) {
        return;
    }
    // 查找数据中数组范围
    int max = a[0];
    for(int i = 1; i < n; i++) {
        if(max < a[i]) {
            max = a[i];
        }
    }
    // 申请计数数组
    int[] c = new int[max + 1];
    for(int i = 0; i <= max; i++) {
        c[i] = 0
    }
    // 计算每个元素的个数放入 c
    for(int i = 0; i < n; i++) {
        c[a[i]]++
    }
    // 顺序累加
    for(int i = 1; i <= max; i++) {
        c[i] = c[i - 1] + c[i];
    }
    // 申请临时数据，存储排序之后的结果
    int[] r = new int[n];
    // 计算排序
    for(int i = n - 1; i >= 0; i--) {
        int index = c[a[i]] - 1;
        r[index] = a[i];
        c[a[i]]--;
    }
    // 拷贝结果
    for(int i = 0; i < n; i++) {
        a[i] = r[i];
    }
}
```

计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转换为非负整数

### 基数排序（Radix sort）
如果给手机号排序，该怎么做呢。由于手机号有 11 位，范围太大，不适合上述两种排序。

手机号码中，如果前面几位中，a 手机号码已经比 b 手机号码大了，那后面几位就不用看了。

处理思路：借助稳定排序，先按照最后一位排序手机号码，在按照倒数第二位重新排序，依次类推，经过 11 轮排序后，手机号码就都有序了。

根据每一位排序，可以用桶排序或者计数排序，复杂度为 O(n)，要排序数据有 k 位，总的复杂度是 O(k*n)，当 k 不大时，因为基数排序的时间复杂度就近似于 O(n)。

基数排序对要排序的数据是有要求的，需要可以分割出独立的位来比较，而且位之间有递进的关系，如果 a 数据的高为比 b 数据大，那么剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则就无法做到 O(n) 了。

## 通用排序
线性排序算法的时间复杂度比较低，适用场景比较特殊，所以如果要写一个通用的排序函数，不能选择线性排序算法。

对于小规模数据进行排序，可以选择时间复杂度是 O(n^2) 的算法，对比大规模数据进行排序，时间复杂度 O(nlogn) 的算法更加高效，因此为了兼顾任意数据的排序，一般首选时间复杂度是 O(nlogn) 的排序算法。

针对 O(nlogn) 排序算法有归并排序、快速排序和堆排序。使用归并排序的情况并不多，快排在最坏情况下时间复杂度是 O(n^2)，而归并可以做到平均情况和复杂情况都是 O(nlogn)，但其并没有受宠，主要原因是归并排序不是原地排序算法。

如何解决快排复杂度恶化问题呢
* 背景：如果数据原来就是有序或者接近有序的，每次分区点都选择最后一个数据，那么就会恶化。出现的主要原因是因为我们分区点选的不够合理。
* 最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。因此不能简单的直接选择第一个或者最后一个数据作为分区点
* 三数取中法，如果数据量比较大，也可以发展成五数取中或者十数取中
* 随机法

快排使用递归来实现，需要警惕递归溢出，为避免递归过深而堆栈过小，导致堆栈溢出，两种办法
* 限制递归深度，一旦递归过深，超过了设定的阀值，就停止递归
* 在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程

qsort 算法
* 优先使用归并排序，如果要排序的数据量比较大的时候，会改为用快速排序来排序
* 使用三数取中发选择分区点
* 实现一个堆上的栈，手动模拟递归解决
* 不仅用到了归并和快速排序，还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素少于等于 4 时，就退化为插入排序，不再继续用递归。因为在小规模数据前，O(n^2) 算法不一定比 O(nlogn) 算法执行时间长