这里我们主要学习下排序

## 基本介绍
最常用排序算法分类
* 冒泡、插入、选择：时间复杂度 O(n^2) 基于比较
* 快排、归并：O(nlogn) 基于比较
* 桶、计数、基数：O(n) 并不基于比较

如何分析一个排序算法呢
* 排序算法的执行效率
  * 最好情况、最坏情况、平均情况时间复杂度
  * 时间复杂度的系数、常数、低阶：同一阶时间复杂度的排序算法性能性能对比的时候，需要考虑进来
  * 比较次数和交换（或移动）次数
* 排序算法的内存消耗
  * 原地排序：指空间复杂度是 O(1) 的排序爽啊
* 排序算法的稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

## 分类一

### 冒泡排序
冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。

使用 JavaScript 例出基本代码
```js
function bubbleSort(array) {
    const length = a.length;
    if (length <= 1) {
        return;
    }
    for (let i = 0; i < length; i++) {
        let flag = false;
        for (let j = 0; j < length - i - 1; j++) {
            if (a[j] > a[j + 1]) {
                const temp = a[j]
                a[j] = a[j + 1]
                a[j + 1] = temp
                flag = true; // 表示有数据交换
            }
        }
        if (!flag) {
            break;
        }
    }
}
```

按照上面的方式分析冒泡排序
* 原地排序
* 稳定排序
* 最好情况复杂度 O(n)，最坏情况复杂度 O(n^2)，平均复杂度 O(n^2)

那么如何分析平均复杂度呢？介绍两个概念：有序度和无序度
* 有序度：数组中具有有序关系的元素对个数，数学表达式为：`有序元素对：a[i] <= a[j], 如果 i < j。`
* 逆序度：相反，逆序度 = 满有序度 - 有序度，数学表达式为：`逆序元素对：a[i] > a[j], 如果 i < j。`
* 满有序度：一个完全有序的数组，有序度就是 `n*(n-1)/2`

> 我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。

冒泡排序操作原子：比较和交换

### 插入排序
将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。

理解了原理之后，代码也比较简单，具体如下
```js
function insertSort(array) {
    const length = a.length;
    if (length <= 1) {
        return;
    }
    for (let i = 1; i < length; i++) {
        // 查找插入位置，从后往前遍历，因为会插入元素
        const value = a[i];
        let j = i - 1;
        for (; j >= 0; j--) {
            // 比你小，往后移动
            if (a[j] > value) {
                a[j + 1] = a[j]
            } else {
                break;
            }
        }
        a[j + 1] = value
    }
}
```

算法分析
* 原地排序
* 稳定排序
* 最好情况复杂度 O(n)，最坏情况复杂度 O(n^2)，平均复杂度 O(n^2)

插入排序操作原子：比较和移动

### 选择排序
选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

算法分析
* 原地排序
* 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)
* 非稳定排序

基本的知识都讲完了，我们来看开篇的问题：冒泡排序和插入排序的时间复杂度都是 O(n^2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

原因在于，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。

### 总结
这三种时间复杂度为 O(n^2) 的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。有些编程语言中的排序函数的实现原理会用到插入排序算法。