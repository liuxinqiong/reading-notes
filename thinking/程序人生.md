# 避免的开发模式
你要避免的软件开发模式
* IDD（IDE-Driven Development）
* DDD（Debugger-Driven Development）
* PDD（Print-Driven Development）
* BDD（Bug-Driven Development）
* RDD（Rat-race-game-Driven Development）：整个职业生涯都在原地打转的开发模式

# 如何选择工作
黑客与画家中已经给出答案
* 选择那些具备**可测量性**和**可放大性**的工作
* 行业的选择：**蓬勃发展的行业**要优于处于稳定的行业
* 选择公司：**处在上升期的公司**优于成熟稳定的公司
* 选择团队：**重视个人能力的小团队**优于过分强调集体智慧的大团队
* 选择老板：**敢打敢拼敢担当的老板**优于过于温情柔顺的老板
* 优先选择那些拥有**更多优秀队友的团队**

# 撰写合格的 REST API
步骤
1. 定下基础框架，比如 express，restify，hapi，loopback，sails.js 等
2. 选择核心的组件
  1. validator：任何一个系统的运行环境都是肮脏的世界，用于净化输入输出，比如 joi 和 json schema
  2. swagger doc：生成 API 的文档和测试UI
  3. ORM：只支持一种 db 的 ORM 就不是很合适，比如 Mongoose / Sequelize，上上之选是接口支持多种不同数据库，这样的 ORM 不多，可用的似乎只有 waterline
  4. 日志系统：node restify 缺省使用 bunyan 作日志，而 bunyan 可以生成 json 格式的日志
  5. 测试框架：ava / rewire / supertest / nyc
    * ava：单元测试框架
    * rewire：mock 技巧
    * supertest：api 级别的测试
    * nyc：test coverage

# 代码重构之道
重构代码最最最重要的一个先验条件是：自动化测试。

如果要重构的环节测试覆盖率不好，先想法提高覆盖率；如果根本没有测试例，请先做好这个基本功再谈重构。

什么情况你需要进行重构呢
* 当你写一段代码时，不得不从别处拷贝粘贴代码
* 当你写一段代码时，不得不从别处拷贝粘贴代码：比如，逻辑写得太绕，太复杂，太难以理解，循环太多，分支太多，状态太多等等。这样的代码几乎跪在那里请求你的重构，不重构说不过去。
* 当你调用已有的代码时（函数，类），不得不阅读被调用的代码才能确定怎么调用时
  * 接口定义的不好：比如参数有十多个
  * 文档写的不好
* 当你写一段代码时，连带着要改很多代码：当这个场景发生的时候，代码的味道相当糟糕，意味着不仅代码本身有问题，相关代码的设计甚至架构也有很大的问题。如果没有一定功底的程序员，重构这样的代码会比较费劲。

严格自律与他律
* 稍微大一点的软件项目是多人一起合作完成的。和别人合作，我们要坚信两点
  * 人天性都是懒惰的，有捷径的话，绝不规规矩矩走大道
  * 人都会受到 role model 或者社区的感染，如果已有的代码库形成了一个良好的氛围，新加入的人有一种融入已有体系的紧迫感。

开源项目其实可以给我们很多启发，看看那些著名的开源项目，很多参与其中的人在他们各自的公司里都未必有这么好的习惯，但在开源项目中，项目本身的检测和社区带来的压力会让它们自律。

对于人的天性，我们可以如下引导

在一个项目启动之初，一定要设置足够的代码签入（checkin）门槛。**lint/build/test** 一个都不能少。比如如下规则
```json
{
  "extends": "airbnb/base",
  "rules": {
    "no-console": 2,
    "max-statements": [2, 50],
    "max-depth": [2, 5],
    "max-nested-callbacks": [2, 3],
    "max-params": [2, 5],
    "complexity": [2, 10],
    "max-len": [2, 120, 4]
  }
}
```

具体要求解释如下
* 代码中不能有任何形式的 console.xxx 出现。为此，我不惜定义 print 函数为 cli 使用。这是逼着程序员好好考虑如何 log，用什么样的 log level 合适。
* 一个函数最多有 50 行代码。那么超过 50 行代码怎么办？要么拆分之，要么精简之。
* 一个函数的嵌套不能超过 5 层。多个 for 循环，深层的 if-else，这些都是罪恶之源。如果超过这个限制，只能拆分，或者使用函数式编程：map/filter/reduce。
* 一个函数最多有 3 层 callback。这是逼着程序员不要误用 callback，尽量多用 Promise。
* 一个函数最多 5 个参数。参数太多的函数，基本是试图揉太多事情在一起。
* 一个函数的复杂性不超过 10。你的所有分支，循环，回调等等统统加在一起，在一个函数里不超过 10 个（注意不是嵌套）。

接下来要有 role model，或者社区氛围来引导行为。一般我启动的项目，我会撰写初始的项目，力保每行代码清晰可读，每个函数深思熟虑，每个接口都有友好的文档，每个关键的函数有详尽的测试，然后在 code review 严格把关。这样，在更多的人加入项目后，大家前有模板可循，经验可依，后有鞭策之威，自然写出比较漂亮的代码。

# 阅读源码

## 为什么
略过大量阅读代码的阶段有几个害处
* 写代码的基础是牢靠的，，前辈们踩过的坑，总结的经验教训，你都不得不亲自用最慢的法子踩一遍
* 很容易养成 stackoverflow driven 的写代码习惯
* 周围最强的那个工程师的开发水平的上限就是你的上限

> 累积素材是基础，被启发出来的思路将这些素材串成线，这就形成了知识（knowledge）。书读得越多，越勤于思考的人，知识也就越丰富。而知识的融会贯通，最终形成读书的第三大功用：通过了解，吸收别人的思想，去芜存菁，最终形成自己的思想，或者说智慧（wisdom）。

## 如何阅读
在选定合理的代码规模和要阅读的源码后，我们就可以清开书桌，摆上 mac，准备好笔墨纸砚，留出至少一个小时到半天时间，开始徜徉在代码的海洋。

读大型代码项目思路
* 读根目录下的 readme，或者任何看上去撩拨着你让你戳它的文件。这就跟书本的「序」一样，能够帮你更进一步了解这份代码的意图
* 接下来需要聚焦在代码的目录结构，和每个源码的文件名。他们就像书本的目录页。如果每个目录下有 readme，也可快速阅读之。通过目录我们就可以快速知道哪些是可以略过的部分
* 从入口梳理主线。不同语言和框架的主线不太一样

另一个角度 —— 阅读的场景来谈谈如何阅读
* 场景一：为了破案而阅读代码
  * 带着线索，循着问题，读且只读和解决问题相关的代码
  * 「猜」起到了很大的作用，你猜一下嘛。连蒙带猜也是解题的一种思路，伟大的数学家同时也是伟大的猜想家
  * 读代码时，猜文件名，函数名，变量名的意图，猜某个分支的意图，猜某段代码的意图，最终结合运行的结果，打印出来的调试信息来印证我们的猜测
  * 复盘总结
    * 这个问题的 root cause 是什么？触发它的代码的流程是什么？
    * 在读代码的过程中，哪些地方我猜对了，哪些没猜对？
    * 有功夫的话，代码的哪个部分是值得细细品读把玩的？
    * 下次再出现类似的问题，我该怎么更快地从源码中定位出问题？
* 场景二：为了明理而阅读代码
  * 算法、基础知识、理论（各种框架是如何实现这些设计模式的？）
  * 这个过程是一个正反馈，是马太效应累积地过程。你读的书多，你脑子里的知识点就多，疑问同样也多。这些疑问促使你读相关的代码去印证和解惑，代码读多了，又感觉理论知识欠缺，于是周而复始，不断学习下去。反之，书读得少，你脑子里都没存几个问号，也就无所谓读代码去求证了。
  * 理解作者的意图。心满意足后，我一般会问问：
    * 这代码有可以优化的地方么？
    * 有潜在的安全漏洞么？
    * 是否有未处理的状态或者异常？
  * 方法步骤
    1. 检视阅读法把整个代码过一遍，找到值得阅读的核心代码。
    2. 粗读这部分代码，将其内容进一步 breakdown。手边准备好笔和纸（或者其他趁手的工具），随时记录。记录最好的方式是图表。
    3. 精读这部分代码，结合你已有的知识，理解这个代码所需要的资料，猜测和还原代码中某种事件，消息，或者某个流程发生的场景。把猜测记录下来。这时，如果遇到外围的代码（调用了外部的函数），只要对理解不产生障碍，可以先放一下，把整个过程完整而详细地捋一遍再说。这个过程一定要多问问题，把「我以为我懂了但实际没懂」的情形尽可能减少。
    4. 用检视阅读法粗度剩下的代码，如果找到其他值得精读的代码，跳至 2
    5. 使用对比阅读（或者说，主题阅读）方式，把类似功能的 repo 都扫一遍。尝试着用自己的语言消化不同作者的实现，关注其实现的差异，并试图评判这种差异。
    6. 用软件将手稿电子化，便于将来回顾。文字可以直接上笔记本工具
* 场景三：为了能级跃迁而阅读代码
  * 读那些基础地不能再基础，你认为自己一辈子都不会去写的那些代码。比如 linux kernel，比如 OTP。这种读法，你不知何时能够完成，所以，要有足够的耐心和时间。**检视阅读 + 主题阅读 + 思维导图是经常用到的方法**。

# work directly on master
work directly on master, instead of using feature branches.

使用 feature branch 的常规流程
* 一个团队会有一个需求池
* 当有空闲开发者时，从需求池中挑选任务
* 开发者中从 master branch 创建一个 feature branch，开始编写虚修
* 他们会推送代码到 feature branch，这个频率是不确定的，可能是几分钟、几小时或几天
* 当代码提交时，CI/CD 在分支上执行 build 操作
* 当开发完整时，通常可能需要几天到一周的时间，开发者创建一个 PR
* 团队中的其他人 review 代码，这可能是 leader 或者是高级开发者
* reviewer 可能会评论并需要修改，开发者需要更新代码，然后重新提交 PR
* 当 PR 被批准后，开发者将分支 merge 到 master，通常是将分支中的所有提交压缩到 master 中的一个大提交
* CI 在 master 上执行 build 操作

团队直接基于 master 进行开发，当然，这必须以安全的方式进行。为了能够做到这一点，团队需要这些关键的实践
* 结对编程
  * 代码可以被实时审核，不需要后面提交 PR
  * 改善团队韧性，更高的质量，代码风格变得更加标准
  * 团队可以一起发现更好的解决方案，以及知识分享
* 有一个你信任的架构
  * 足够多的自动化测试让你自信
  * 快速的本地编译
  * TDD/BDD，足够有效的测试策略
* 使用抽象分支或特性标志来隐藏未完成的工作

work directly on master benefit
* 尽早反馈
  * 通过 PR 的方式，只有当开发者觉得完成时才会有反馈，这对于一些本质的修改通常太晚了
  * 当结对时，反馈会在代码编写时甚至之前发生，可以讨论如何解决问题，会更容易修改
* 更好的质量反馈
  * 通过 PR 的方式，反馈通常是评论的形式，很难讨论到软件开发需要的细节。文字的表达不如对面对沟通来的丰富
  * 面对面沟通更容易澄清你想要说的内容，并进行健康的辩论。
* 代码集体所有权
  * 集体代码所有权，而不是个人所有权
  * it's our code, not my code
* 团队代码风格
  * 好的团队的代码看起来像是一个人写的
  * 比起个人喜好，更重视团队合作
  * 结对编程更容易统一代码风格
* 持续集成
* 习惯不去破坏东西
* 更容易处理大型重构
  * 在分支工作时，我们往往害怕做可能导致合并冲突的事情。比如重命名包，移动东西，架构变更。当直接在 master 上工作时，至少做这些事情更容易，因为我们可以提交小的更改，并让团队的其他成员保持最新的状态。
* 更清楚地了解每个人在做什么
* 检查变更的更好工具
* 保存原始的提交历史

对于一个能够直接在 master 上工作的团队来说，这意味着他们知道
* 如何在不破坏代码的情况下工作
* 如何编写好的测试
* 如何有效地一起工作

> 特性分支针对个人性能进行优化，但基于主干的开发针对团队性能进行优化

特性分支有些场景还是很有用的：当代码有一个明确的所有者，但其他人在做工作时，特性分支是好的。比如开源项目，因为其他人通常在不通的区域，无法面对面沟通

怎么尝试做呢
* 审视你的测试策略：更多的 TDD 实践
* 开始更多的结对

真实案例
* 开发人员配对
* 一对开发者选择新需求，编写测试集以及完成该需要的细分任务列表
* 当这两个人认为他们已经准备好了时，他们召集团队并向每个人展示验收测试，目的是确认每个人对需求的理解都是一样的，以及团队将要去实现什么，这叫做 BDD 开发模式，通过我们用例子来达成共识（create shared understanding）
* 每对开发人员从需求中挑选任务，选择独立的任务
* 每对成员直接提交代码到 master，频率几分钟到几小时不等。我们都喜欢小的，频繁的，有明确的信息表明“为什么”我们刚刚做了一个特定的改变。提交消息能清晰的表达新增或修改了什么，实现了什么产出
* 每当开发人员从 git 中提取内容时，他们都会 rebase，以保持提交的顺序与现实中发生的相同
* 提交前，本地构建确保是成功的
* 测试策略遵循金字塔，倾向于更快的测试
* 通过使用抽象分支模式，代码库在任何时候都是可发布的
* 每当推入代码时，CI工具都会构建代码并运行所有测试
* 当任务在几天完成后，具体所有的成员演示实现的东西
* QA 专家将执行一些探索性测试(通常持续几个小时到几天)
* 如果没有出现意外情况，那么应用程序将被提升到生产环境中
* 期间，在前一个需求的开发接近尾声时，其中一对将开始查看下一个需求，以做好准备并保持良好的流程
* 如果在任何时候，一对团队成员觉得有必要讨论一些事情(例如，架构决策、设计、取舍），所有的结对会聚集在一起进行即兴的黑帮编程，一起找出解决方案

来源：[Why I love Trunk Based Development (or pushing straight to master)](https://medium.com/@mattia.battiston/why-i-love-trunk-based-development-641fcf0b94a0)