/**
 * 委托模式：多个对象接受并处理同一个请求，他们可以将请求委托给另一个对象统一处理请求
 */

// 最常见例子：事件处理，可以减少事件数，因为事件多了，内存消耗就大了，尤其在低版本浏览器中，事件过多会影响用户体验

// 完整事件流：从事件捕获开始，到触发该事件，再到事件冒泡三个阶段，可以将子元素事件委托给父元素去绑定执行
ul.onclick = function (e) {
    var e = e || window.event
    var tar = e.target || e.srcElement
    if (tar.nodeName.toLowerCase === 'li') {
        e.style.backgroundColor = 'gray'
    }
}

// 不仅可以优化页面中事件的数量，还有一个作用就是『语言未来』，日后动态添加的元素，同样会有事件


// 内存外泄，主要在低版本IE浏览器中，他的引用计数式垃圾回收机制，使的那些对DOM元素的引用没有显示清除会遗留在内存中，除非关闭浏览器，否则无法清除
btn.onclick = function () {
    btn_container.innerHTML = 'test'
}

// 上面的代码，父元素会重置内容，会将按钮自身覆盖掉，然后click事件没有清除，所以这个事件就会泄露到内存中，为了解决这个问题，需要显示清除事件
btn.onclick = function () {
    btn.onclick = null
    btn_container.innerHTML = 'test'
}

// 但是在一些标准浏览器中是不需要的，因为采用标记清除方式管理内存，所以更好的方式还是使用事件委托

// 扩展
// 标记清除：是对于脱离作用域的变量进行回收。当进入作用域时，进行标记，离开作用域时，标记并回收这些变量。

// 引用计数：是记录每个变量的被引用情况，每当过一段时间开始垃圾回收的时候，就把被引用数为0的变量回收。这个问题可能导致循环引用，类似死锁。这样变量就永不会被销毁。