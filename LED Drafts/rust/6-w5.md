## 函数式特性
主要学习
* 闭包：一个可以存储在变量里的类似函数的结构
* 迭代器：一种处理元素序列的方式

### 闭包
闭包是保存进变量或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获调用者作用域中的值。

闭包的定义以一对竖线（|）开始，在竖线中指定闭包的参数；如果有多于一个参数，可以使用逗号分隔，比如 |param1, param2|。

参数之后是存放闭包体的大括号 —— 如果闭包体只有一行则大括号是可以省略的。大括号之后闭包的结尾，需要用于 let 语句的分号。

闭包不要求像 fn 函数那样在参数和返回值上注明类型。函数中需要类型注解是因为他们是暴露给用户的显式接口的一部分。**严格的定义这些接口对于保证所有人都认同函数使用和返回值的类型来说是很重要的**。但是闭包并不用于这样暴露在外的接口：他们储存在变量中并被使用，不用命名他们或暴露给库的用户调用。

> 闭包语法非常类似于函数语法，除了使用竖线而不是括号以及几个可选的语法之外

使用带有泛型和 Fn trait 的闭包
* Fn 系列 trait 由标准库提供。所有的闭包都实现了 trait Fn、FnMut 或 FnOnce 中的一个。

演示一下 memoization 技术
```rust
// 定义结构体
struct Cacher<T>
    where T: Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}

impl<T> Cacher<T>
    where T: Fn(u32) -> u32
{
    fn new(calculation: T) -> Cacher<T> {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
```

闭包会捕获其环境：闭包还有另一个函数所没有的功能：**他们可以捕获其环境并访问其被定义的作用域的变量**。

当闭包从环境中捕获一个值，闭包会在闭包体中储存这个值以供使用。这会使用内存并产生额外的开销，在更一般的场景中，当我们不需要闭包来捕获环境时，我们不希望产生这些开销。因为函数从未允许捕获环境，定义和使用函数也就从不会有这些额外开销。

闭包可以通过三种方式捕获其环境，他们直接对应函数的三种获取参数的方式：获取所有权，可变借用和不可变借用。这三种捕获值的方式被编码为如下三个 Fn trait：
* FnOnce：为了消费捕获到的变量，闭包必须获取其所有权并在定义闭包时将其移动进闭包。其名称的 Once 部分代表了闭包不能多次获取相同变量的所有权的事实，所以它只能被调用一次。
* FnMut：获取可变的借用值所以可以改变其环境
* Fn：从其环境获取不可变的借用值
* **当创建一个闭包时，Rust 根据其如何使用环境中变量来推断我们希望如何引用环境**。如果你希望强制闭包获取其使用的环境值的所有权，可以在参数列表前使用 `move` 关键字。这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用。
* 大部分需要指定一个 Fn 系列 trait bound 的时候，可以从 Fn 开始，而编译器会根据闭包体中的情况告诉你是否需要 FnMut 或 FnOnce。

### 迭代器
迭代器（iterator）负责遍历序列中的每一项和决定序列何时结束的逻辑。

迭代器是惰性的（lazy），这意味着在调用方法使用迭代器之前它都不会有效果。一旦创建迭代器之后，可以选择用多种方式利用它。
* 创建 iter 的三种方式
  * iter()
  * into_iter()
  * iter_mut()
* 如何遍历
  * 使用 for-in 循环
* 迭代器都实现了一个叫做 Iterator 的定义于标准库的 trait
  * type Item 和 Self::Item，他们定义了 trait 的 关联类型：表明实现 Iterator trait 要求同时定义一个 Item 类型，这个 Item 类型被用作 next 方法的返回值类型。
  * next 是 Iterator 实现者被要求定义的唯一方法。next 一次返回迭代器中的一个项，封装在 Some 中，当迭代器结束时，它返回 None。
* 迭代适配器
  * 迭代器适配器：将当前迭代器变为不同类型的迭代器。可以链式调用多个迭代器适配器
  * map、filter、rev、fold、chain（组合多个范围）、zip（产生元祖 tuple 的迭代器）、enumerate（获取索引及其元素)、max、min、sum
  * collect：消费迭代器并将结果收集到一个数据结构中
  * Range(..) 生成一个步长为 1 的 iterator

> 迭代器的实现方式提供了对多种不同的序列使用相同逻辑的灵活性

无限与超越(Infinity and Beyond)：无限范围本身是无用的，有用的是将他们和其他适配器和消费者结合起来，比如如下例子
```rust
let v = (1..)
  .map(|x| x * x)
  .filter(|x| x % 5 == 0 )
  .take(10)
  .collect::<Vec<i32>>();
```

itertools 包含强大的附加迭代器适配器
* step
* unique
* join
* sorted_by

> 函数式编程风格倾向于最小化可变状态的数量来使代码更简洁。

**相比摆弄不同的循环并创建新 vector，（迭代器）代码则更关注循环的目的。这抽象掉那些老生常谈的代码，这样就更容易看清代码所特有的概念**

### 性能：循环 VS 迭代
迭代器是 Rust 的 零成本抽象（zero-cost abstractions）之一，它意味着抽象并不会引入运行时开销

闭包和迭代器是 Rust 受函数式编程语言观念所启发的功能。他们对 Rust 以底层的性能来明确的表达高级概念的能力有很大贡献。闭包和迭代器的实现达到了不影响运行时性能的程度。这正是 Rust 竭力提供零成本抽象的目标的一部分。