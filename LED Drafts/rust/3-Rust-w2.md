## 本周分享
主要内容为结构体、枚举与模式匹配

## 结构体
基础语法
* struct 关键字
* 大括号 K-V 的方式实例化
* 数据访问使用 `.`
* key 和变量名相同，可以省略变量赋值操作，这一点和 JS 一致
* `..` 扩展符
* 元组结构体：这个挺特别的，引用用来声明类似 Point 这样不需要有语义 key 的对象
  * 支持结构
  * 支持通过 `.` + 下标的方式访问
* 没有任何字段的类单元结构体
* 我们需要使用生命周期来实现在结构体中存储引用，先 Mark 一下

扩展 - Debug 打印方式
* 使用 `{:?}` 而不是 `{}`，`{:#?}` 采用格式化的方式
* 为结构体添加注解 `#[derive(Debug)]`

方法
* 方法与函数是不同的，因为它们在**结构体的上下文**中被定义（或者是**枚举或 trait 对象的上下文**）
* 不以 self 作为参数的函数。这被称为关联函数。关联函数经常被用作返回一个结构体新实例的构造函数
* 支持多个 impl 块

> 使用方法替代函数，除了可使用方法语法和不需要在每个函数签名中重复 self 的类型之外，其主要好处在于组织性。我们将某个类型实例能做的所有事情都一起放入 impl 块中，而不是让将来的用户在我们的库中到处寻找 Rectangle 的功能。

在 C/C++ 语言中，有两个不同的运算符来调用方法：. 直接在对象上调用方法，而 -> 在一个对象的指针上调用方法，这时需要先解引用（dereference）指针。
* 换句话说，如果 object 是一个指针，那么 object->something() 就像 (*object).something() 一样。
* Rust 有一个叫 自动引用和解引用（automatic referencing and dereferencing）的功能。方法调用是 Rust 中少数几个拥有这种行为的地方。

## 枚举和模式匹配
枚举基础
* 如何定义
  * enum 关键字
  * 通过双冒号语法 `::` 访问
* 如何连同数据编码
  * 仅仅使用枚举并将数据直接放进每一个枚举成员，这样就不需要结构体来帮忙了
  * 用枚举替代结构体还有另一个优势：每个成员可以处理不同类型和数量的数据，此时枚举起到一个关键作用，可以聚合多个不同类型，形成一个新的类型
* 支持通过 impl 为枚举定义方法
* Option 枚举
  * Rust 并没有很多其他语言中有的空值功能,确实拥有一个可以编码存在或不存在概念的枚举。这个枚举是 `Option<T>`
  * 过于重要，直接被包含在了 prelude 之中，你不需要将其显式引入作用域。它的成员也是如此，因此不需要使用 `Option::` 前缀
  * 为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 `Option<T>` 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 `Option<T>` 类型，你就 可以 安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性

一个复杂的 enum 示例
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 }, // 匿名结构体
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

match 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。

match 的力量来源于模式的表现力以及编译器检查，它确保了所有可能的情况都得到处理。
* 基本语法
  * match 关键字搭配表达式
  * 分支：模式 + 一些代码，中间通过 `=>` 分隔，每一个分支之间使用逗号分隔。
* 从枚举成员中提取值的
  * match 一个枚举，绑定其中的值到一个变量，接着根据其值执行代码。
  * 比如从 Option 的 Some 中提取值
* 匹配是穷尽的：必须穷举到最后的可能性来使代码有效
* `_` 通配符，类似于 `default`
* if let
  * if let 语法让我们以一种不那么冗长的方式结合 if 和 let，来处理只匹配一个模式的值而忽略其他模式的情况。
  * if let 获取通过等号分隔的一个模式和一个表达式
  * if let 意味着编写更少代码，更少的缩进和更少的样板代码。
  * if let 是 match 的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。
  * if let 中包含一个 else。else 块中的代码与 match 表达式中的 _ 分支块中的代码相同