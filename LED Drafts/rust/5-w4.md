## 集合
不同于内建的数组和元组类型，这些集合指向的数据是储存在堆上的，这意味着数据的数量不必在编译时就已知，并且还可以随着程序的运行增长或缩小。

三个在 Rust 程序中被广泛使用的集合
* vector 允许我们一个挨着一个地储存一系列数量可变的值
* 字符串（String）是一个字符的集合
* 哈希 map（hash map）允许我们将值与一个特定的键（key）相关联。

### vector
vector
* `Vec<T>`
* 特点
  * 内存中彼此相邻地排列所有的值
  * 在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中
  * **枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举**
  * 如果在编写程序时不能确切无疑地知道运行时会储存进 vector 的所有类型，枚举技术就行不通了。这时，你可以使用 **trait** 对象
* 新建 vector
  * Vec::new：当没有向 vec 中插入任何值时，此时 Rust 并不知道我们想要存储什么类型的数据，此时必须使用类型注解声明类型，一旦插入值 Rust 就可以推断出想要存放的类型，所以你很少会需要这些类型注解
  * vec! 宏：使用初始值来创建一个 Vec
* 更新操作
  * push
  * pop
* 访问操作
  * 索引语法：& + [] 的方式获取引用，比如 &v[2]，这种情况如何访问越界，则会导致程序奔溃
  * get 语法：以索引作为参数来返回一个 `Option<&T>`
* 遍历操作
  * 不可变 `for i in &v`，可变 `for i in &mut v`
  * **解引用符号**：`*`

### 字符串
String 的类型是由标准库提供的，而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。
* 新建字符串
  * String::new
  * 字符串字面值的 to_string() 函数，等同于使用 String::from()
* 更新字符串
  * 使用 push_str 和 push 附加字符串
  * 使用 + 运算符或 format! 宏拼接字符串：解引用强制多态，&String 可以被强转成 &str
* 索引字符串
  * Rust 的字符串不支持索引：String 是一个 `Vec<u8>` 的封装，由于编码的问题，一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值
  * 索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。为了更明确索引并表明你需要一个字符串 slice，相比使用 [] 和单个值的索引，可以使用 [] 和一个 range 来创建含特定字节的字符串 slice
* 遍历字符串
  * for-in 遍历 chars() 函数返回值
  * bytes() 返回每一个原始字节

### HashMap
通过一个 哈希函数（hashing function）来实现映射，决定如何将键和值放入内存中。很多编程语言支持这种数据结构，不过通常有不同的名字：哈希、map、对象、哈希表等
* 哈希 map 可以用于需要任何类型作为键来寻找数据的情况，而不是像 vector 那样通过索引
* 新建 HashMap
  * use 标准库中集合部分的 HashMap，在这三个常用集合中，HashMap 是最不常用的，所以并没有被 prelude 自动引用。
  * HashMap::new()
  * 元组的 vector 的 collect 方法
  ```rust
  let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();
  ```
* 哈希 map 和所有权
  * 对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map。对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者
  * 如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。但是这些引用指向的值必须至少在哈希 map 有效时也是有效的
* 访问哈希 map 中的值
  * get：返回 `Option<V>`
  * for-in 循环，不同于 vector 的是，循环出来的每一项是 (key, value) 元组
* 更新元素
  * 覆盖一个值：insert
  * 只在键没有对应值时插入：entry(key).or_insert(value)
  * 根据旧值更新一个值
* 哈希函数：如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 hasher 来切换为其它函数。hasher 是一个实现了 BuildHasher trait 的类型。

## 错误处理
Rust 将错误类型组合成两个主要类别：可恢复错误（recoverable）和 不可恢复错误（unrecoverable）。
* 可恢复错误通常代表向用户报告错误和重试操作是合理的情况，比如未找到文件。
* 不可恢复错误通常是 bug 的同义词，比如尝试访问超过数组结尾的位置。

### panic!
Rust 有 `panic!` 宏。当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。
* 当出现 panic 时，程序默认会开始展开（unwinding），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接终止（abort），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。
* 通过设置环境变量 `RUST_BACKTRACE` 为非零的值，来查看整个 panic 过程中函数调用相关信息

### Result
大部分错误并没有严重到需要程序完全停止执行。这时我们可以通过 `Result` 枚举来实现可恢复的错误。详细定义如下
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

> 注意与 Option 枚举一样，Result 枚举和其成员也被导入到了 prelude 中，所以就不需要在 match 分支中的 Ok 和 Err 之前指定 Result::

在处理错误时，**unwrap** 这类方法可以消除大量嵌套的 match 表达式。

有趣的写法
```rust
use std::fs::File;
use std::io::Error;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}

// 也可以采用如下的写法
fn main() {
    fn handle_error(error: Error) -> File {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    }
    let f = File::open("hello.txt").unwrap_or_else(handle_error);
}
```

失败时 panic 的简写：unwrap 和 expect
* `Result<T, E>` 类型定义了很多辅助方法来处理各种情况。其中之一叫做 unwrap。如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值。如果 Result 是成员 Err，unwrap 会为我们调用 panic!
* 使用 expect 而不是 unwrap 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。

传播错误：自行编写的函数，也可以通过返回 Result 的方式，将错误向上传播。

传播错误的模式在 Rust 是如此的常见，以至于 Rust 提供了 `?` 问号运算符来使其更易于处理。Result 值之后的 ? 被定义为：如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序将继续执行。如果值是 Err，Err 中的值将作为整个函数的返回值。有一点需要注意：? 运算符所使用的错误值被传递给了 from 函数，其用来将错误从一种类型转换为另一种类型。当 ? 运算符调用 from 函数时，收到的错误类型被转换为定义为当前函数返回的错误类型。这在当一个函数返回一个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败。只要每一个错误类型都实现了 from 函数来定义如将其转换为返回的错误类型，? 运算符会自动处理这些转换。

> ? 运算符消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 ? 之后直接使用链式方法调用来进一步缩短代码

### 如何选择
何时应该 panic! 以及何时应该返回 Result 呢？
* 示例、代码原型和测试都非常适合 panic!
* 当我们比编译器知道更多的情况：当你有一些其他的逻辑来确保 Result 会是 Ok 值时，调用 unwrap 也是合适的
* 错误处理指导原则
  * 在当有可能会导致有害状态的情况下建议使用 panic!
  * 如果别人调用你的代码并传递了一个没有意义的值，最好的情况也许就是 panic! 并警告使用你的库的人他的代码中有 bug 以便他能在开发时就修复它
  * 当错误预期会出现时，返回 Result 仍要比调用 panic! 更为合适
  * 当代码对值进行操作时，应该首先验证值是有效的，并在其无效时 panic!
  * 虽然在所有函数中都拥有许多错误检查是冗长而烦人的。幸运的是，可以利用 Rust 的类型系统（以及编译器的类型检查）为你进行很多检查。如果函数有一个特定类型的参数，可以在**知晓编译器已经确保其拥有一个有效值的前提下**进行你的代码逻辑。
* 创建自定义类型进行有效性验证
  * 类似于 i32 类型，编译器会保证不能输入负数
  * 我们也可以自定义类型，比如 SmallNum 类型，限制就是小于 100

## 泛型、trait 和生命周期
泛型的具体应用有
* 泛型函数
* 泛型结构体
* 泛型枚举
* 泛型方法

关于泛型的具体使用，和大部分支持泛型的语言基本一致，比较有趣的是针对泛型方法的定义
```rust
struct Point<T> {
    x: T,
    y: T,
}

// impl 必须带 T 声明
impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

// 或者只针对某种类型添加方法，意味着只有当 T 是 f32 的实例有这个方法
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

泛型代码的性能
* Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。
* Rust 通过在编译时进行泛型代码的单态化（monomorphization）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。

trait，这是一个定义泛型行为的方法。trait 可以与泛型结合来将泛型限制为拥有特定行为的类型，而不是任意类型。可以通过 trait 以一种抽象的方式定义共享的行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。**类比 interface**
* 定义 trait
  * 直接通过 trait 关键字
  * trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。
* 实现 trait
  * 具体语法 impl TraitName for StructName
* 默认实现
  * 定义默认实现，这样某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为
  * 默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现
  * 注意无法从相同方法的重载实现中调用默认方法 - ？？？看不懂
* trait 作为参数：函数类型声明为 `impl Trait`
* Trait Bound 语法
  * impl Trait 只不够是 Trait Bound 语法糖
  * trait bound 与泛型参数声明在一起，位于尖括号中的冒号后面，从而构成**泛型约束**
  * 通过 `+` 指定多个 trait bound
  * 通过 where 简化 trait bound：在函数签名之后的 where 从句中指定 trait bound 的语法
* 返回实现了 trait 的类型
* 使用 trait bound 有条件地实现方法

trait 和 trait bound 让我们使用泛型类型参数来减少重复，并仍然能够向编译器明确指定泛型类型需要拥有哪些行为。因为我们向编译器提供了 trait bound 信息，它就可以检查代码中所用到的具体类型是否提供了正确的行为。在动态类型语言中，如果我们尝试调用一个类型并没有实现的方法，会在运行时出现错误。Rust 将这些错误移动到了编译时，甚至在代码能够运行之前就强迫我们修复错误。另外，我们也无需编写运行时检查行为的代码，因为在编译时就已经检查过了，这样相比其他那些不愿放弃泛型灵活性的语言有更好的性能。

派生 trait？？？

### 生命周期与引用有效性
这是 Rust 最与众不同的功能。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们**使用泛型生命周期参数**来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。

生命周期（lifetimes），它是一类允许我们向编译器提供引用如何相互关联的泛型。Rust 的生命周期功能允许在很多场景下借用值的同时仍然使编译器能够检查这些引用的有效性。

> 因为生命周期也是泛型，所以语法和泛型类型是一致的

生命周期
* 生命周期避免了悬垂引用
* 借用检查器：编译器有一个借用检查器，它比较作用域来确保所有的借用都是有效的，被引用的对象比它的引用者存在的时间更短时，程序被拒绝编译

生命周期注解
* 生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期。
* 语法：生命周期参数名称必须以撇号（`'`）开头，其名称通常全是小写，类似于泛型其名称非常短。`'a` 是大多数人默认使用的名称。

函数生命周期注解例子
```rust
// 参数中的引用和返回值之间的限制是他们都必须拥有相同的生命周期
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

> 生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。

生命周期省略规则：一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。

函数或方法的参数的生命周期被称为**输入生命周期**（input lifetimes），而返回值的生命周期被称为**输出生命周期**（output lifetimes）。

编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。
* 第一条规则是每一个是引用的参数都有它自己的生命周期参数
* 第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数
* 第三条规则是如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 &self 或 &mut self，那么 self 的生命周期被赋给所有输出生命周期参数。第三条规则使得方法更容易读写，因为只需更少的符号。

静态生命周期
* `'static`，其生命周期能够存活于整个程序期间。所有的字符串字面值都拥有 `'static` 生命周期
* 使用之前，思考一下这个引用是否真的在整个程序的生命周期里都有效

## 测试
Rust 在语言本身包含了软件测试的支持。这里我们主要学习
* 编写测试时会用到的注解和宏
* 运行测试的默认行为和选项
* 将测试组织成单元测试和集成测试

如何编写测试
* 通过在 fn 行之前加上 `#[test]` 注解来将一个函数变成测试函数。当使用 cargo test 命令运行测试时，Rust 会构建一个测试执行程序用来调用 test 属性的函数，并报告每一个测试是通过还是失败
* 当测试函数中出现 panic 时测试就失败了。每一个测试都在一个新线程中运行，当主线程发现测试线程异常了，就将对应测试标记为失败。
* assert! 希望确保测试中一些条件为 true 时使用
* assert_eq! 和 assert_ne! 宏来测试相等，当断言失败时，会打印出这两个值具体是什么，以便于观察测试为什么失败
* 任何在 assert! 的一个必需参数和 assert_eq! 和 assert_ne! 的两个必需参数之后指定的参数都会传递给 format! 宏
* 使用 should_panic 检查 panic
  * `#[should_panic]` 属性位于 `#[test]` 之后
  * 可以给 should_panic 属性增加一个可选的 expected 参数。测试工具会确保错误信息中包含其提供的文本
* 还可以使用 `Result<T, E>` 编写测试
  * 在测试通过时返回 Ok，测试失败时返回 Err
  * 目的：可以在在函数体中使用问号运算符，如此可以方便的编写任何运算符会返回 Err 成员的测试。

更多测试内容
* 如何忽略和过滤测试
* 性能测试
* 文档注释作为测试

控制测试的运行
* cargo test 生成的二进制文件的默认行为是并行的运行所有测试，并截获测试运行过程中产生的输出，阻止他们被显示出来，使得阅读测试结果相关的内容变得更容易。
* 如果你不希望测试并行运行，或者想要更加精确的控制线程的数量，可以传递 `--test-threads` 参数和希望使用线程的数量给测试二进制文件
* 显示函数输出：默认情况下，当测试通过时，Rust 的测试库会截获打印到标准输出的所有内容。比如在测试中调用了 println! 而测试通过了，我们将不会在终端看到 println! 的输出：只会看到说明测试通过的提示行。如果测试失败了，则会看到所有标准输出和其他错误信息。
* 如果你希望也能看到通过的测试中打印的值，截获输出的行为可以通过 `--nocapture` 参数来禁用
* 通过指定名字来运行部分测试
  * 运行单个测试：传递任意测试的名称来只运行这个测试
  * 过滤运行多个测试：指定部分测试的名称，任何名称匹配这个名称的测试会被运行
  * **注意测试所在的模块也是测试名称的一部分，所以可以通过模块名来运行一个模块中的所有测试。**
* 忽略某些测试
  * 使用 `#[ignore]` 标记
  * 如果我们只希望运行被忽略的测试，可以使用 cargo test -- --ignored

测试的组织结构
* 单元测试：倾向于更小而更集中，在隔离的环境中一次测试一个模块，或者是测试私有接口
* 集成测试：与其他外部代码一样，通过相同的方式使用你的代码，只测试公有接口而且每个测试都有可能会测试多个模块。

> 为了保证你的库能够按照你的预期运行，从独立和整体的角度编写这两类测试都是非常重要的。

单元测试
* 单元测试与他们要测试的代码共同存放在位于 src 目录下相同的文件中。规范是在每个文件中创建包含测试函数的 `tests` 模块，并使用 `#[cfg(test)]` 标注模块。
* `#[cfg(test)]` 注解告诉 Rust 只在执行 cargo test 时才编译和运行测试代码，而在运行 cargo build 时不这么做。
* 测试私有函数
  * 测试社区中一直存在关于是否应该对私有函数直接进行测试的论战，而在其他语言中想要测试私有函数是一件困难的事
  * Rust 私有性规则确实允许你测试私有函数

集成测试
* 目的：测试库的多个部分能否一起正常工作
* 项目根目录创建一个 tests 目录，与 src 同级。Cargo 知道如何去寻找这个目录中的集成测试文件。接着可以随意在这个目录中创建任意多的测试文件，Cargo 会将每一个文件当作单独的 crate 来编译。
* 不需要 `#[cfg(test)]` 注解。tests 文件夹在 Cargo 中是一个特殊的文件夹， Cargo 只会在运行 cargo test 时编译这个目录中的文件
* 可以使用 cargo test 的 --test 后跟文件的名称来运行某个特定集成测试文件中的所有测试
* 如何在集成测试中创建公共函数
  * 由于直接创建会被当成集成测试文件，因此我们需要一个方式来区分模块还是文件
  * 举例说明，创建 tests/common/mod.rs ，而不是创建 tests/common.rs 。这是一种 Rust 的命名规范，这样命名告诉 Rust 不要将 common 看作一个集成测试文件

> 只有库 crate 才会向其他 crate 暴露了可供调用和使用的函数；二进制 crate 只意在单独运行。