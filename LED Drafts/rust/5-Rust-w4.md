## 集合
不同于内建的数组和元组类型，这些集合指向的数据是储存在堆上的，这意味着数据的数量不必在编译时就已知，并且还可以随着程序的运行增长或缩小。

三个在 Rust 程序中被广泛使用的集合
* vector 允许我们一个挨着一个地储存一系列数量可变的值
* 字符串（String）是一个字符的集合
* 哈希 map（hash map）允许我们将值与一个特定的键（key）相关联。

### vector
vector
* `Vec<T>`
* 特点
  * 内存中彼此相邻地排列所有的值
  * 在 vector 的结尾增加新元素时，在没有足够空间将所有所有元素依次相邻存放的情况下，可能会要求分配新内存并将老的元素拷贝到新的空间中
  * **枚举的成员都被定义为相同的枚举类型，所以当需要在 vector 中储存不同类型值时，我们可以定义并使用一个枚举**
  * 如果在编写程序时不能确切无遗地知道运行时会储存进 vector 的所有类型，枚举技术就行不通了。这时，你可以使用 **trait** 对象
* 新建 vector
  * Vec::new：当没有向 vec 中插入任何值时，此时 Rust 并不知道我们想要存储什么类型的数据，此时必须使用类型注解声明类型，一旦插入值 Rust 就可以推断出想要存放的类型，所以你很少会需要这些类型注解
  * vec! 宏：使用初始值来创建一个 Vec
* 更新操作
  * push
  * pop
* 访问操作
  * 索引语法：& + [] 的方式获取引用，比如 &v[2]，这种情况如何访问越界，则会导致程序奔溃
  * get 语法：以索引作为参数来返回一个 `Option<&T>`
* 遍历操作
  * 不可变 `for i in &v`，可变 `for i in &mut v`
  * **解引用符号**：`*`

### 字符串
String 的类型是由标准库提供的，而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。
* 新建字符串
  * String::new
  * 字符串字面值的 to_string() 函数，等同于使用 String::from()
* 更新字符串
  * 使用 push_str 和 push 附加字符串
  * 使用 + 运算符或 format! 宏拼接字符串：解引用强制多态，&String 可以被强转成 &str
* 索引字符串
  * Rust 的字符串不支持索引：String 是一个 `Vec<u8>` 的封装，由于编码的问题，一个字符串字节值的索引并不总是对应一个有效的 Unicode 标量值
  * 索引字符串通常是一个坏点子，因为字符串索引应该返回的类型是不明确的：字节值、字符、字形簇或者字符串 slice。为了更明确索引并表明你需要一个字符串 slice，相比使用 [] 和单个值的索引，可以使用 [] 和一个 range 来创建含特定字节的字符串 slice
* 遍历字符串
  * for-in 遍历 chars() 函数返回值
  * bytes() 返回每一个原始字节

### HashMap
通过一个 哈希函数（hashing function）来实现映射，决定如何将键和值放入内存中。很多编程语言支持这种数据结构，不过通常有不同的名字：哈希、map、对象、哈希表等
* 哈希 map 可以用于需要任何类型作为键来寻找数据的情况，而不是像 vector 那样通过索引
* 新建 HashMap
  * use 标准库中集合部分的 HashMap，在这三个常用集合中，HashMap 是最不常用的，所以并没有被 prelude 自动引用。
  * HashMap::new()
  * 元组的 vector 的 collect 方法
  ```rust
  let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();
  ```
* 哈希 map 和所有权
  * 对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map。对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者
  * 如果将值的引用插入哈希 map，这些值本身将不会被移动进哈希 map。但是这些引用指向的值必须至少在哈希 map 有效时也是有效的
* 访问哈希 map 中的值
  * get：返回 `Option<V>`
  * for-in 循环，不同于 vector 的是，循环出来的每一项是 (key, value) 元组
* 更新元素
  * 覆盖一个值：insert
  * 只在键没有对应值时插入：entry(key).or_insert(value)
  * 根据旧值更新一个值
* 哈希函数：如果性能监测显示此哈希函数非常慢，以致于你无法接受，你可以指定一个不同的 hasher 来切换为其它函数。hasher 是一个实现了 BuildHasher trait 的类型。

## 错误处理
Rust 将错误类型组合成两个主要类别：可恢复错误（recoverable）和 不可恢复错误（unrecoverable）。
* 可恢复错误通常代表向用户报告错误和重试操作是合理的情况，比如未找到文件。
* 不可恢复错误通常是 bug 的同义词，比如尝试访问超过数组结尾的位置。

### panic!
Rust 有 `panic!` 宏。当执行这个宏时，程序会打印出一个错误信息，展开并清理栈数据，然后接着退出。
* 当出现 panic 时，程序默认会开始展开（unwinding），这意味着 Rust 会回溯栈并清理它遇到的每一个函数的数据，不过这个回溯并清理的过程有很多工作。另一种选择是直接终止（abort），这会不清理数据就退出程序。那么程序所使用的内存需要由操作系统来清理。
* 通过设置环境变量 `RUST_BACKTRACE` 为非零的值，来查看整个 panic 过程中函数调用相关信息

### Result
大部分错误并没有严重到需要程序完全停止执行。这时我们可以通过 `Result` 枚举来实现可恢复的错误。详细定义如下
```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

> 注意与 Option 枚举一样，Result 枚举和其成员也被导入到了 prelude 中，所以就不需要在 match 分支中的 Ok 和 Err 之前指定 Result::

在处理错误时，**unwrap** 这类方法可以消除大量嵌套的 match 表达式。

有趣的写法
```rust
use std::fs::File;
use std::io::Error;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}

// 也可以采用如下的写法
fn main() {
    fn handle_error(error: Error) -> File {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    }
    let f = File::open("hello.txt").unwrap_or_else(handle_error);
}
```

失败时 panic 的简写：unwrap 和 expect
* `Result<T, E>` 类型定义了很多辅助方法来处理各种情况。其中之一叫做 unwrap。如果 Result 值是成员 Ok，unwrap 会返回 Ok 中的值。如果 Result 是成员 Err，unwrap 会为我们调用 panic!
* 使用 expect 而不是 unwrap 并提供一个好的错误信息可以表明你的意图并更易于追踪 panic 的根源。

传播错误：自行编写的函数，也可以通过返回 Result 的方式，将错误向上传播。

传播错误的模式在 Rust 是如此的常见，以至于 Rust 提供了 `?` 问号运算符来使其更易于处理。Result 值之后的 ? 被定义为：如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序将继续执行。如果值是 Err，Err 中的值将作为整个函数的返回值。有一点需要注意：? 运算符所使用的错误值被传递给了 from 函数，其用来将错误从一种类型转换为另一种类型。当 ? 运算符调用 from 函数时，收到的错误类型被转换为定义为当前函数返回的错误类型。这在当一个函数返回一个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败。只要每一个错误类型都实现了 from 函数来定义如将其转换为返回的错误类型，? 运算符会自动处理这些转换。

> ? 运算符消除了大量样板代码并使得函数的实现更简单。我们甚至可以在 ? 之后直接使用链式方法调用来进一步缩短代码

### 如何选择
何时应该 panic! 以及何时应该返回 Result 呢？
* 示例、代码原型和测试都非常适合 panic!
* 当我们比编译器知道更多的情况：当你有一些其他的逻辑来确保 Result 会是 Ok 值时，调用 unwrap 也是合适的
* 错误处理指导原则
  * 在当有可能会导致有害状态的情况下建议使用 panic!
  * 如果别人调用你的代码并传递了一个没有意义的值，最好的情况也许就是 panic! 并警告使用你的库的人他的代码中有 bug 以便他能在开发时就修复它
  * 当错误预期会出现时，返回 Result 仍要比调用 panic! 更为合适
  * 当代码对值进行操作时，应该首先验证值是有效的，并在其无效时 panic!
  * 虽然在所有函数中都拥有许多错误检查是冗长而烦人的。幸运的是，可以利用 Rust 的类型系统（以及编译器的类型检查）为你进行很多检查。如果函数有一个特定类型的参数，可以在**知晓编译器已经确保其拥有一个有效值的前提下**进行你的代码逻辑。
* 创建自定义类型进行有效性验证
  * 类似于 i32 类型，编译器会保证不能输入负数
  * 我们也可以自定义类型，比如 SmallNum 类型，限制就是小于 100

## 泛型、trait 和生命周期
泛型的具体应用有
* 泛型函数
* 泛型结构体
* 泛型枚举
* 泛型方法

关于泛型的具体使用，和大部分支持泛型的语言基本一致，比较有趣的是针对泛型方法的定义
```rust
struct Point<T> {
    x: T,
    y: T,
}

// impl 必须带 T 声明
impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

// 或者只针对某种类型添加方法，意味着只有当 T 是 f32 的实例有这个方法
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

泛型代码的性能
* Rust 实现了泛型，使得使用泛型类型参数的代码相比使用具体类型并没有任何速度上的损失。
* Rust 通过在编译时进行泛型代码的 单态化（monomorphization）来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。

trait，这是一个定义泛型行为的方法。trait 可以与泛型结合来将泛型限制为拥有特定行为的类型，而不是任意类型。可以通过 trait 以一种抽象的方式定义共享的行为。可以使用 trait bounds 指定泛型是任何拥有特定行为的类型。**类比 interface**
* 定义 trait
  * 直接通过 trait 关键字
  * trait 定义是一种将方法签名组合起来的方法，目的是定义一个实现某些目的所必需的行为的集合。
* 实现 trait
  * 具体语法 impl TraitName for StructName
* 默认实现
  * 定义默认实现，这样某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为
  * 默认实现允许调用相同 trait 中的其他方法，哪怕这些方法没有默认实现
  * 注意无法从相同方法的重载实现中调用默认方法
* trait 作为参数：函数类型声明为 impl Trait
* Trait Bound 语法
  * impl Trait 只不够是 Trait Bound 语法糖
  * trait bound 与泛型参数声明在一起，位于尖括号中的冒号后面，从而构成**泛型约束**
  * 通过 `+` 指定多个 trait bound
  * 通过 where 简化 trait bound：在函数签名之后的 where 从句中指定 trait bound 的语法
* 返回实现了 trait 的类型
* 使用 trait bound 有条件地实现方法

trait 和 trait bound 让我们使用泛型类型参数来减少重复，并仍然能够向编译器明确指定泛型类型需要拥有哪些行为。因为我们向编译器提供了 trait bound 信息，它就可以检查代码中所用到的具体类型是否提供了正确的行为。在动态类型语言中，如果我们尝试调用一个类型并没有实现的方法，会在运行时出现错误。Rust 将这些错误移动到了编译时，甚至在代码能够运行之前就强迫我们修复错误。另外，我们也无需编写运行时检查行为的代码，因为在编译时就已经检查过了，这样相比其他那些不愿放弃泛型灵活性的语言有更好的性能。

### 生命周期与引用有效性
这是 Rust 最与众不同的功能。大部分时候生命周期是隐含并可以推断的，正如大部分时候类型也是可以推断的一样。类似于当因为有多种可能类型的时候必须注明类型，也会出现引用的生命周期以一些不同方式相关联的情况，所以 Rust 需要我们使用泛型生命周期参数来注明他们的关系，这样就能确保运行时实际使用的引用绝对是有效的。

生命周期（lifetimes），它是一类允许我们向编译器提供引用如何相互关联的泛型。Rust 的生命周期功能允许在很多场景下借用值的同时仍然使编译器能够检查这些引用的有效性。

> 因为生命周期也是泛型，所以语法和泛型类型是一致的

生命周期
* 生命周期避免了悬垂引用
* 借用检查器：编译器有一个借用检查器，它比较作用域来确保所有的借用都是有效的，被引用的对象比它的引用者存在的时间更短时，程序被拒绝编译

生命周期注解
* 生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期。
* 语法：生命周期参数名称必须以撇号（'）开头，其名称通常全是小写，类似于泛型其名称非常短。`'a` 是大多数人默认使用的名称。

函数生命周期注解例子
```rust
// 参数中的引用和返回值之间的限制是他们都必须拥有相同的生命周期
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

> 生命周期语法是用于将函数的多个参数与其返回值的生命周期进行关联的。一旦他们形成了某种关联，Rust 就有了足够的信息来允许内存安全的操作并阻止会产生悬垂指针亦或是违反内存安全的行为。

生命周期省略规则：一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。

函数或方法的参数的生命周期被称为**输入生命周期**（input lifetimes），而返回值的生命周期被称为**输出生命周期**（output lifetimes）。

编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。
* 第一条规则是每一个是引用的参数都有它自己的生命周期参数
* 第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数
* 第三条规则是如果方法有多个输入生命周期参数，不过其中之一因为方法的缘故为 &self 或 &mut self，那么 self 的生命周期被赋给所有输出生命周期参数。第三条规则使得方法更容易读写，因为只需更少的符号。

静态生命周期
* `'static`，其生命周期能够存活于整个程序期间。所有的字符串字面值都拥有 `'static` 生命周期
* 使用之前，思考一下这个引用是否真的在整个程序的生命周期里都有效

## 测试
Rust 在语言本身包含了软件测试的支持。这里我们主要学习
* 编写测试时会用到的注解和宏
* 运行测试的默认行为和选项
* 将测试组织成单元测试和集成测试

如何编写测试
* 通过在 fn 行之前加上 `#[test]` 注解来将一个函数变成测试函数。当使用 cargo test 命令运行测试时，Rust 会构建一个测试执行程序用来调用 test 属性的函数，并报告每一个测试是通过还是失败
* 当测试函数中出现 panic 时测试就失败了。每一个测试都在一个新线程中运行，当主线程发现测试线程异常了，就将对应测试标记为失败。
* assert! 希望确保测试中一些条件为 true 时使用
* assert_eq! 和 assert_ne! 宏来测试相等，当断言失败时，会打印出这两个值具体是什么，以便于观察测试为什么失败

更多测试内容
* 如何忽略和过滤测试
* 性能测试
* 文档注释作为测试